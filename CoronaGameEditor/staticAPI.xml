<?xml version="1.0" encoding="utf-8"?>
<CoronaAPI>
  <Ads>
    <ads.hide>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Removes the currently shown ad from the screen and prevents new ads from being retrieved until ads.show() has been called again.
        For more help on usage, check out our guides for InMobi and inneractive.


      </Description>
      <Syntax>

        ads.hide()





      </Syntax>
      <Example>

        Example for InMobi:

        local ads = require "ads"
         
        ads.init( "inmobi", "myAppId" )
        ads.show( "banner320x48", { x=0, y=100, interval=60, testMode=false } )
         
        -- Some time later ...
         
        ads.hide()
        Example for inneractive:

        local ads = require "ads"
         
        ads.init( "inneractive", "myAppId" )
        ads.show( "banner", { x=0, y=0, interval=60 } )
         
        -- Some time later ...
         
        ads.hide()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </ads.hide>
    <ads.init>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Initialize the Ads service library by specifying the name of the Ads service provider and the appId.
        Currently, inneractive and inMobi are supported. For more information see the Corona Dashboard.
        For more help on usage, check out our guides for InMobi and inneractive.


      </Description>
      <Syntax>

        ads.init( providerName, appId [, listener] )





      </Syntax>
      <Example>

        How to use InMobi ads:

        local ads = require "ads"
         
        local function adListener( event )
            if event.isError then
                -- Failed to receive an ad.
            end
        end
         
        ads.init( "inmobi", "myAppId", adListener )
        ads.show( "banner320x48", { x=0, y=100, interval=60, testMode=false } )
        How to use interactive ads:

        local ads = require "ads"
         
        local function adListener( event )
            if event.isError then
                -- Failed to receive an ad.
            end
        end
         
        ads.init( "inneractive", "myAppId", adListener )
        ads.show( "banner", { x=0, y=0, interval=60 } )





      </Example>
      <Parameters>

        providerName

        String containg the provider's name.
        appID

        String containing the app ID (from xyz site)
        listener

        Function that will receive an event indicating if showing an ad succeeded or failed.  Will be called for every new ad that is requested according to the interval given to the ads.show() function.  Provides a property event.isError which will be set true if the system failed to retrieve an ad which can happen if the ad network is unreachable or is out of inventory/ads, in which case nothing is shown on screen.  event.isError will be set true if an ad was successfully retrieved and displayed on screen.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Adding "require ads" to your code will enable Corona Launchpad regardless of the setting in config.lua.




      </Remarks>
    </ads.init>
    <ads.show>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Begin showing the ads at the given screen location and the given refresh period.
        For more help on usage, check out our guides for InMobi and inneractive.
        Note: The ad dimensions are in "points" and not pixels. This means the display size in pixels will be double on a retina display device (e.g., iPhone4).


      </Description>
      <Syntax>

         ads.show( adUnitType [, params] )





      </Syntax>
      <Example>

        How to use InMobi ads:

        local ads = require "ads"
         
        local function adListener( event )
            if event.isError then
                -- Failed to receive an ad.
            end
        end
         
        ads.init( "inmobi", "myAppId", adListener )
        ads.show( "banner320x48", { x=0, y=100, interval=60, testMode=false } )
        How to use interactive ads:

        local ads = require "ads"
         
        local function adListener( event )
            if event.isError then
                -- Failed to receive an ad.
            end
        end
         
        ads.init( "inneractive", "myAppId", adListener )
        ads.show( "banner", { x=0, y=0, interval=60 } )





      </Example>
      <Parameters>

        adUnitType

        String indicating the type of ad to show on screen.

        InMobi supports the following ad types on all devices:

        "banner320x48"
        "banner300x250"

        InMobi supports the following larger ad banners types on iPad only:

        "banner728x90"
        "banner468x60"
        "banner120x600"

        inneractive supports the following ad types on all devices:

        "banner"
        "text"
        "fullscreen"

        params
        Optional parameters (table).

        x = value  -- Top left x position in points, not content coordinates. Defaults to 0.
        y = value -- Top left y position in points, not content coordinates. Defaults to 0.
        interval = time -- Ad refresh time (in seconds). Defaults to 10.
        testMode = true|false -- Set to true for testing account. Defaults to false.






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Be aware that if you are developing a "universal app" (between iPhone3/4 and iPAD), ADs will not dynamically scale to the iPAD. If your config.lua file defines a 320x480 screen, a "320 x 48" ad will appear proportionally smaller on the iPAD than on the iPhone3/4. It's recommended that you detect the device type and choose the proper ad dimensions.




      </Remarks>
    </ads.show>
  </Ads>
  <Analytics>
    <analytics.init>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Initializes the analytics library.


      </Description>
      <Syntax>

        analytics.init(applicationKey)





      </Syntax>
      <Example>

        require "analytics"
        analytics.init("1234567890ABCDEFG")





      </Example>
      <Parameters>

        applicationKey

        The key provided by Flurry to track your application's events. To obtain a key, visit flurry.com and follow instructions there.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Create an account on Flurry. Go to www.flurry.com and sign up for an account. Once you have logged in to flurry, go to Manage Applications. Click "Create a new app". Choose iPhone, iPad, or Android as appropriate. This will create an "Application key" which you must enter in the code.
        You use the analytics.logEvent(string) API in your app to log events. In your Flurry account, choose "View analytics" to see the data created by your app.
        Note that it takes some time for the analytics data to appear in the Flurry statistics, it does not appear immediately.




      </Remarks>
    </analytics.init>
    <analytics.logEvent>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Reports an event to the Flurry analytics service. The event can be any string value.
        Regardless of whether you call logEvent(), the Flurry client sends basic analytics data to the Flurry service like number of users, session length, etc, that developers can track/graph on flurry.com.


      </Description>
      <Syntax>

        analytics.logEvent(eventID)





      </Syntax>
      <Example>

        The following code logs a new event named "New Game" with the Flurry service when the user taps the newGameBtn display object.
        require "analytics"
        local appKey = "1234567890ABCDEFG"
        analytics.init(appKey)
         
        function newGame(event)
          -- Log event
          analytics.logEvent("New Game")
          -- New game code follows...
        end
         
        newGameBtn:addEventListener("touch", newGame)





      </Example>
      <Parameters>

        eventID

        String: Contains the event information to be logged with the analytics service.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </analytics.logEvent>
  </Analytics>
  <Animation />
  <Easing>
    <easing.inExpo>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Starts motion from a zero velocity and then accelerates motion as it executes.


      </Description>
      <Syntax>

        easing.inExpo


      </Syntax>
      <Example>

        local currentTarget = display.newCircle(100, 100, 100)
        currentTarget:setFillColor(0,0,255)
        transition.to(currentTarget, { time=400, y=current, transition=easing.inExpo})





      </Example>
      <Parameters>

        None. 





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.inExpo>
    <easing.inOutExpo>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Starts motion from a zero velocity, accelerates, then decelerate to a zero velocity using an exponential easing equation.


      </Description>
      <Syntax>

        easing.inOutExpo


      </Syntax>
      <Example>

        local currentTarget = display.newCircle(100, 100, 100)
        currentTarget:setFillColor(0,0,255)
        transition.to(currentTarget, { time=400, y=current, transition=easing.inOutExpo})





      </Example>
      <Parameters>

        None. 





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.inOutExpo>
    <easing.inOutQuad>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Starts animation from a zero velocity, accelerates, then decelerate to a zero velocity.


      </Description>
      <Syntax>

        easing.inOutQuad


      </Syntax>
      <Example>

        This example creates and animates a circle across the stage.
        local currentTarget = display.newCircle(100, 100, 100)
        currentTarget:setFillColor(255,000,000)
        transition.to(currentTarget, { time=400, y=300, transition=easing.inOutQuad})





      </Example>
      <Parameters>

        None. 





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.inOutQuad>
    <easing.inQuad>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Performs a quadratic interpolation of animated property values in a transition.


      </Description>
      <Syntax>

        easing.inQuad


      </Syntax>
      <Example>

           local circle1 = display.newCircle(65, 60, 10 )
           circle1:setFillColor(255,0,255,255)      
           transition.to(circle1, {time=3000, x=300,y=400, transition = easing.inQuad})





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.inQuad>
    <easing.linear>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Defines a constant motion with no acceleration.


      </Description>
      <Syntax>

        easing.linear





      </Syntax>
      <Example>

            circle2 = display.newCircle(65, 60, 10 )
            circle2:setFillColor(255,0,255,255)      
            transition.to(circle2, {time=3000, y=460, transition = easing.linear})





      </Example>
      <Parameters>

        None. 





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.linear>
    <easing.outExpo>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Starts motion fast and then decelerates motion to a zero velocity as it executes.


      </Description>
      <Syntax>

        easing.outExpo

      </Syntax>
      <Example>

        local currentTarget = display.newCircle(100, 100, 100)
        currentTarget:setFillColor(0,0,255)
        transition.to(currentTarget, { time=400, y=current, transition=easing.outExpo})





      </Example>
      <Parameters>

        None. 





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.outExpo>
    <easing.outQuad>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Starts motion fast and then decelerates motion to a zero velocity as it executes.


      </Description>
      <Syntax>

        easing.outQuad


      </Syntax>
      <Example>

        local currentTarget = display.newCircle(100, 100, 100)
        transition.to(currentTarget, { time=400, y=300, transition=easing.outQuad})





      </Example>
      <Parameters>

        None.

         





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Easing is intended to be used with transition.to and transition.from APIs.




      </Remarks>
    </easing.outQuad>
  </Easing>
  <Movieclips>
    <movieclip.newAnim>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates an animated sprite from a list of images. You can then use methods of the returned animation object to control its playback (such as play(), stop(), and reverse()) to control the playback of the animation.


      </Description>
      <Syntax>

        movieclip.newAnim( framesTable )

      </Syntax>
      <Example>

        The following example creates a new animation from a sequence of images that reside in the project folder and then plays that animation using the play() method.

        require "movieclip"
        local myAnim = movieclip.newAnim( { "img1.png", "img2.png", "img3.png", "img4.png" } )
        myAnim:play()





      </Example>
      <Parameters>

        framesTable

        A table that contains the images from which the animation is created.





      </Parameters>
      <Returns>

        An animation object.





      </Returns>
      <Remarks>

        Note: Lua allows the parameter to a function to be called without parenthees if the parameter is a literal string or table.




      </Remarks>
    </movieclip.newAnim>
    <object..nextFrame>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Resets any animation sequence in progress, moves the animation to the next image in the total sequence, and stops. This can be used with a two-frame movieclip to make an image toggle between two states.


      </Description>
      <Syntax>

        object:nextFrame()





      </Syntax>
      <Example>

        myAnim = movieclip.newAnim{ "img1.png", "img2.png", "img3.png", "img4.png" }
         
        function step(event)
           myAnim:nextFrame()
        end
         
        Runtime:addEventListener("touch", step)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..nextFrame>
    <object..play>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Starts an animated sprite created with animation.newAnim() playing in the forward direction. When the end of the image set is reached, the sequence cycles back to the first image and continues playing. If a specific frame sequence has already been constructed, calling play() with no parameters will simply resume playing within that sequence.


      </Description>
      <Syntax>

        object:play()

      </Syntax>
      <Example>

        This sample creates a new animation from an image sequence and then plays it.

        myAnim = movieclip.newAnim{"cube1.png", "cube2.png", "cube3.png", "cube4.png", "cube5.png", "cube6.png"}
        myAnim:play()
        This sample plays a limited frame sequence from the animation, loops the animation three times, and then deletes the animation object.

        myAnim = movieclip.newAnim{"cube1.png", "cube2.png", "cube3.png", "cube4.png", "cube5.png", "cube6.png"}
        myAnim:play{ startFrame=1, endFrame=6, loop=3, remove=true }





      </Example>
      <Parameters>

        startFrame

        Number: The frame at which the animation should start. The default is the first image passed to the newAnim() function.

        endFrame

        Number: The frame at which the animation should end. The default is the last image passed to the newAnim() function.

        loop

        Number: The number of times to loop the sequence. The default is 0 indicating that it should loop forever.

        shouldRemove

        Boolean: If true, the movieclip will automatically delete itself when the given sequence is complete. The default is false.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..play>
    <object..previousFrame>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Resets any animation sequence in progress, moves the animation to the previous image in the total sequence, and stops.


      </Description>
      <Syntax>

        object:previousFrame()





      </Syntax>
      <Example>

        myAnim = movieclip.newAnim{ "img1.png", "img2.png", "img3.png", "img4.png" }
         
        function stepBack(event)
           myAnim:previousFrame()
        end
         
        Runtime:addEventListener("touch", stepBack)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..previousFrame>
    <object..reverse>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Starts the animated sprite playing in the reverse direction. When the beginning of the image set is reached, it will cycle back to the last image and continue playing backwards. If a specific frame sequence has already been constructed, calling reverse() with no parameters will simply resume playing backwards within that sequence.


      </Description>
      <Syntax>

        object:reverse()

      </Syntax>
      <Example>

        This sample creates a new animation from an image sequence and then plays it in reverse.

        myAnim = movieclip.newAnim{"cube1.png", "cube2.png", "cube3.png", "cube4.png", "cube5.png", "cube6.png"}
        myAnim:reverse()





      </Example>
      <Parameters>

        startFrame

        Number: The frame at which the animation should start. The default is the first image passed to the newAnim() function.
        endFrame

        Number: The frame at which the animation should end. The default is the last image passed to the newAnim() function.
        loop

        Number: The number of times to loop the sequence. The default is 0 indicating that it should loop forever.
        shouldRemove

        Boolean: If true, the movieclip will automatically delete itself when the given sequence is complete. The default is false.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..reverse>

    <object..setLabels>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Associates labels (strings) with the frame numbers of an Animation object.


      </Description>
      <Syntax>

        object:setLabels{ frameLabel1=num1, frameLabel2=num2, ..., frameLabelN = numN }





      </Syntax>
      <Example>

        myAnim:setLabels{ startFrame=1, endFrame=30 }





      </Example>
      <Parameters>

        labels

        table: Each element of the table associates a string (label) with a frame number in the associated animation object.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Note: Lua allows the parameter to a function to be called without parenthees if the parameter is a literal string or table.




      </Remarks>
    </object..setLabels>
    <object..stop>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Stops an animation, if playing.


      </Description>
      <Syntax>

        object:stop()





      </Syntax>
      <Example>

        -- Create and play the animation
        local myAnim = movieclip.newAnim{"cube1.png", "cube2.png", "cube3.png", "cube4.png", "cube5.png", "cube6.png"}
        myAnim:play()
         
        -- Later
        myAnim:stop()





      </Example>
      <Parameters>

        None. 





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..stop>
    <object..stopAtFrame>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Jumps the animation to the specified frame number or frame label specified by the setLabels() function.


      </Description>
      <Syntax>

        object:stopAtFrame( frame )





      </Syntax>
      <Example>

        This sample illustrates how to perform â€œgo to and playâ€ from a specified frame. You first issue a stopAtFrame() command followed by a play() or reverse() command. Both commands will execute before the display updates again, and so the transition will be immediate:
        myAnim:stopAtFrame(4)
        myAnim:play()
         





      </Example>
      <Parameters>

        frame

        Either a frame number or string label associated with that frame number specified with setLabels( ).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..stopAtFrame>
  </Movieclips>
  <Transitions>
    <transition.cancel>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Cancels a transition in progress.


      </Description>
      <Syntax>

        transition.cancel(tween)





      </Syntax>
      <Example>

        local trans1 = transition.to(currentTarget, { time=400, y=upperLimit, transition=easing.outQuad})  
         
        -- Later cancel the tween
        transition.cancel(trans1)





      </Example>
      <Parameters>

        tween

        Object: The tween to cancel.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>





      </Remarks>
    </transition.cancel>
    <transition.dissolve>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </transition.dissolve>
    <transition.from>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Similar to transition.to() except the starting property values are specified in the function's parameter table and the final values are the corresponding property values in target prior to the call.


      </Description>
      <Syntax>

        handle = transition.from( target, params )





      </Syntax>
      <Example>

        local square = display.newRect( 0, 0, 100, 100 )
        square:setFillColor( 255,255,255 )
         
        local w,h = display.viewableContentWidth, display.viewableContentWidth
         
        local listener = function( obj )
                print( "Transition completed on object: " .. tostring( obj ) )
        end
         
        -- Move square from bottom right corner to upper right corner; subtract half side-length
        -- since its local origin is the square's center;
        transition.from( square, { time=1500, x=(w-50), y=(h-50), onComplete=listener } )
         





      </Example>
      <Parameters>

        target

        Object: A display object that will be the target of the transition.
        param

        Table: A table that specifies the properties of the display object which will be animated, and one or more of the following optional non-animated properties:

        params.time specifies the duration of the transition in milliseconds. By default, the duration is 500 ms (0.5 seconds).
        params.transition is by default easing.linear . See Easing for more functions.
        params.delay specifies the delay (none by default) before the tween begins.
        params.delta is a boolean specifying whether non-control parameters are interpreted as final ending values or as changes in value. The default is nil meaning false.
        params.onStart is a function or table listener called before the tween begins. Table listeners must have an onStart method. When invoked, the listener is given target instead of an event.
        params.onComplete is a function or table listener called after the tween completes. The listener is called with "obj" that points to the "target" used in the transition.

        Most of the Display Object Common Properties can be used as part of the transition parameters. http://developer.anscamobile.com/reference/index/common-properties





      </Parameters>
      <Returns>

        handle

        A reference to the new transition (used by transition.cancel) to cancel the transition.





      </Returns>
      <Remarks>

        The transition timer is updated every frame count (30 or 60 FPS). Specifying a time faster than the frame count (33 ms. or 16 ms.) will default to the frame rate time.
        Note: There is currently a timing bug in this API when invoked from a timer.performWithDelay listener. The bug will generate a warning message then trying to transition the Alpha property of an object from 1.0 to 0.0 or 0.0 to 1.0.
        The work-around to eliminate the warning message is to add the "delay = 1" parameter as in this example:
        transition.from( square, { delay=1, time=500, alpha=0.0, onComplete=listener2 } )
        This is FB case# 1041.




      </Remarks>
    </transition.from>
    <transition.to>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Animates a display object's properties over time using the "easing" transitions.


      </Description>
      <Syntax>

        handle = transition.to( target, params )





      </Syntax>
      <Example>

        local square = display.newRect( 0, 0, 100, 100 )
        square:setFillColor( 255,255,255 )
         
        local w,h = display.stageWidth, display.stageHeight
         
        local square = display.newRect( 0, 0, 100, 100 )
        square:setFillColor( 255,255,255 )
         
        local w,h = display.stageWidth, display.stageHeight
         
        local listener1 = function( obj )
                print( "Transition 1 completed on object: " .. tostring( obj ) )
        end
         
        local listener2 = function( obj )
                print( "Transition 2 completed on object: " .. tostring( obj ) )
        end
         
        -- (1) move square to bottom right corner; subtract half side-length
        --     b/c the local origin is at the square's center; fade out square
        transition.to( square, { time=1500, alpha=0, x=(w-50), y=(h-50), onComplete=listener1 } )
         
        -- (2) fade square back in after 2.5 seconds
        transition.to( square, { time=500, delay=2500, alpha=1.0, onComplete=listener2 } )





      </Example>
      <Parameters>

        target

        Object: A display object that will be the target of the transition.
        param

        Table: A table that specifies the properties of the display object which will be animated, and one or more of the following optional non-animated properties:

        params.time specifies the duration of the transition in milliseconds. By default, the duration is 500 ms (0.5 seconds).
        params.transition is by default easing.linear . See Easing for more functions.
        params.delay specifies the delay, in milliseconds, (none by default) before the tween begins.
        params.delta is a boolean specifying whether non-control parameters are interpreted as final ending values or as changes in value. The default is nil meaning false.
        params.onStart is a function or table listener called before the tween begins. Table listeners must have an onStart method. When invoked, the listener is given target instead of an event.
        params.onComplete is a function or table listener called after the tween completes. The listener is sent an "obj" parameter that points to the "target" used in the transition.

        Most of the Display Object Common Properties can be used as part of the transition parameters. http://developer.anscamobile.com/reference/index/common-properties





      </Parameters>
      <Returns>

        handle

        A reference to the new transition (used by transition.cancel) to cancel the transition.





      </Returns>
      <Remarks>

        The transition timer is updated every frame count (30 or 60 FPS). Specifying a time faster than the frame count (33 ms. or 16 ms.) will default to the frame rate time.
        Note: There is currently a timing bug in this API when invoked from a timer.performWithDelay listener. The bug will generate a warning message then trying to transition the Alpha property of an object from 1.0 to 0.0 or 0.0 to 1.0.
        The work-around to eliminate the warning message is to add the "delay = 1" parameter as in this example:
        transition.to( square, { delay=1, time=500, alpha=0.0, onComplete=listener2 } )
        This is FB case# 1041. This bug has been fixed starting in build 484




      </Remarks>
    </transition.to>
  </Transitions>
  <Arrays>
    <table.concat>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Concatenate the elements of a table together to form a string.  Each element must be able to be coerced into a string. A separator can be specified which is placed between concatenated elements.


      </Description>
      <Syntax>

        table.concat (table [, sep [, i [, j]]])





      </Syntax>
      <Example>

        t = { 1, 2, "three", 4, "five" }
        print (table.concat(t))              --&gt; 12three4five
        print (table.concat(t, ", "))        --&gt; 1, 2, three, 4, five
        print (table.concat(t, ", ", 2, 4))  --&gt; 2, three, 4





      </Example>
      <Parameters>

        table

        Table: The Lua table whose elements will be concatenated.

        sep

        (Optional) String: The string to insert between concatenated table values. The default value is an empty string ("").

        i

        (Optional) Number: The index in the table at which the concatenation should start. The default values is 1.

        j

        (Optional) Number: The index in the table at which the concatenation should end. The default value is the length of the table.





      </Parameters>
      <Returns>

        The concatenated string.





      </Returns>
      <Remarks>





      </Remarks>
    </table.concat>
    <table.copy>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a shallow copy of array, i.e. the portion of the array (table) with integer keys. A variable number of additional arrays can be passed in as optional arguments. If an array has a hole (a nil entry), copying in a given source array stops at the last consecutive item prior to the hole.
        Note: In Lua, the function table.concat() is equivalent to JavaScript's array.join(). Hence, the following function is called copy().


      </Description>
      <Syntax>

        table.copy( t1, t2, ... )





      </Syntax>
      <Example>

        local t1 = {1,3,5,7,9}
        local t2 = {2,4,6,333}
        t2[6] = 555 -- create hole
        local t3 = {11,13,17,19}
         
        local c = table.copy( t1, t2, t3 )
        print( table.concat( c, ", " ) ) -- output: 1, 3, 5, 7, 9, 2, 4, 6, 333, 11, 13, 17, 19





      </Example>
      <Parameters>

        t1, t2, ...

        table objects.





      </Parameters>
      <Returns>

        Returns a shallow copy of combined arrays.





      </Returns>
      <Remarks>





      </Remarks>
    </table.copy>
    <table.indexOf>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the integer index of object in array. Returns 'nil' if not in array. The search goes through the length of the array as determined by #array, whose value is undefined if there are holes.


      </Description>
      <Syntax>

        table.indexOf( t, object )





      </Syntax>
      <Example>

        local t = {1,3,5,7,9}
        print( table.indexOf( t, 9 ) ) -- output: 5





      </Example>
      <Parameters>

        t

        Table (array) to be searched.
        object

        object in the array.





      </Parameters>
      <Returns>

        number

        Returns the index within the array where the object was found or 'nil' if not found.





      </Returns>
      <Remarks>





      </Remarks>
    </table.indexOf>
    <table.insert>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Insert a given value into a table. If a position is given insert the value before the element currently at that position


      </Description>
      <Syntax>

        table.insert (table, [pos,] value)





      </Syntax>
      <Example>

        t = { 1, "three", 4, "five" }
        print (table.concat(t, ", "))        --&gt; 1, three, 4, five
        table.insert(t, 2, "two")  
        print (table.concat(t, ", "))        --&gt; 1, two, three, 4, five





      </Example>
      <Parameters>

        table

        Table: A reference to the Lua table to which the new value will be added.  When a table has an element inserted both the size of the table and the element indices are updated.
        pos

        (Optional) Number: The index of the table at which the new element will be inserted. The default value is the length of the table + 1 so that table.insert(t,x) inserts x at the end of table t.  Note that it is faster to use the length operator: t[#t + 1] = x.
        value

        (Optional) Object: The new value to assign to the table element.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </table.insert>
    <table.maxn>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the largest positive numerical index of the given table, or zero if the table has no positive numerical indices.


      </Description>
      <Syntax>

         table.maxn (t)





      </Syntax>
      <Example>

        t = { 1,1,2,3,5,8,13 }
        print (table.maxn (t))   --&gt; 7





      </Example>
      <Parameters>

        t

        A table.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </table.maxn>
    <table.remove>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Removes an element from a table.


      </Description>
      <Syntax>

        table.remove (t [, pos])





      </Syntax>
      <Example>

        t = { 1,1,2,3,5,8,13 }
        print (table.maxn (t))      --&gt; 7
        print (table.remove (t,4))  --&gt; 3
        print (table.maxn (t))      --&gt; 6
        print (table.remove (t))    --&gt; 13





      </Example>
      <Parameters>

        t

        A table.
        pos

        (Optional)  Position of the element to remove.  Its default value is the length of the table, so table.remove(t) removes the last element of t.





      </Parameters>
      <Returns>

        The element that was removed.





      </Returns>
      <Remarks>





      </Remarks>
    </table.remove>
    <table.sort>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sorts table elements in place.


      </Description>
      <Syntax>

         table.sort (t [, comp])





      </Syntax>
      <Example>

        t = { 3,2,5,1,4 }
        table.sort(t, function(a,b) return ab end)
        print (table.concat(t, ", "))  --&gt; 1, 2, 3, 4, 5





      </Example>
      <Parameters>

        t

        The table to sort.
        comp

        (Optional) If not given, the standard Lua operator  is used.

        If specified, compmust be a function that

        receives two table elements
        returns false when the first is less than the second (so that not comp(a[i+1],a[i]) will be

        false after the sort).


        The sort algorithm is not stable; that is, elements considered equal by the given order may have their relative positions changed by the sort.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </table.sort>
  </Arrays>
  <Audio>
    <audio.dispose>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Releases audio memory associated with the handle.


      </Description>
      <Syntax>

        audio.dispose( audioHandle )





      </Syntax>
      <Example>

        laserSound = audio.loadSound( "laserSound.wav" )
        backgroundMusic = audio.loadStream( "backgroundMusic.m4a" )
        audio.dispose( laserSound )
        audio.dispose( backgroundMusic )
        laserSound = nil  -- This makes sure we can't use the handle again
        backgroundMusic = nil  -- This makes sure we can't use the handle again





      </Example>
      <Parameters>

        audioHandle

        Object: The handle (aka "object") returned by the audio.load* functions that you want to free.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        You must not use the handle once the memory is freed. The audio should not be active (playing or paused) on any channel when you try to free it.




      </Remarks>
    </audio.dispose>
    <audio.fade>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This fades a playing sound in a specified amount to a specified volume. The audio will continue playing after the fade completes. This is known as "ducking" in some circles.


      </Description>
      <Syntax>

        audio.fade( [ { [channel=c] [, time=t] [, volume=v ] } ] )





      </Syntax>
      <Example>

        audio.fade({ channel=1, time=5000, volume=0.5 } )





      </Example>
      <Parameters>

        channel

        integer: The channel number you want to fade on. 1 to the maximum number of channels (currently 32) are valid channels. Specify 0 to apply fade to all the channels.
        time

        integer: The amount of time from now (in milliseconds) that you want the audio to fade over and stop. Omitting this parameter invokes a default fade time which is currently 1000 milliseconds.
        volume

        number: The target volume you want to change (fade) to. Valid numbers are 0.0 to 1.0 where 1.0 is the max volume. If this parameter is omitted, the default value is currently 0.0.





      </Parameters>
      <Returns>

        The number of channels fade is actually applied to.





      </Returns>
      <Remarks>

        Note: When you fade the volume, you are changing the volume of the channel. This value is persistent and it is your responsibility to reset the volume on the channel (see audio.setVolume) if you want to use the channel again later.




      </Remarks>
    </audio.fade>
    <audio.fadeOut>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This stops a playing sound in a specified amount of time and fades to min volume while doing it. The audio will stop at the end of the time and the channel will be freed. The onComplete callback will be triggered at the end of playback. If the audio does not finish naturally before the fadeOut time, the completed flag in the event callback will be set to false.


      </Description>
      <Syntax>

        audio.fadeOut( [ { [channel=c] [, time=t] } ] )





      </Syntax>
      <Example>

        audio.fadeOut({ channel=1, time=5000 } )





      </Example>
      <Parameters>

        channel

        integer: The channel number you want to fadeOut on. 1 to the maximum number of channels (currently 32) are valid channels. Specify 0 to apply fadeOut to all the channels.
        time

        integer: The amount of time from now (in milliseconds) that you want the audio to fade out over and stop. Omitting this parameter invokes a default fade out time which is currently 1000 milliseconds.





      </Parameters>
      <Returns>

        The number of channels fadeOut is actually applied to.





      </Returns>
      <Remarks>

        Note: When you fade the volume, you are changing the volume of the channel. This value is persistent and it is your responsibility to reset the volume on the channel (see audio.setVolume) if you want to use the channel again later.




      </Remarks>
    </audio.fadeOut>
    <audio.findFreeChannel>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Will look for an available channel for playback. You can provide a start channel number as parameter which will start searching from that channel and increase upward to the highest channel. The search does not include reserved channels.


      </Description>
      <Syntax>

        audio.findFreeChannel(  [ startChannel ]  )





      </Syntax>
      <Example>

        local availableChannel = audio.findFreeChannel()
        audio.play( laserSound, { channel=availableChannel } )





      </Example>
      <Parameters>

        startChannel

        integer: The channel number you want to start looking at. Search will increase upwards from this channel. 0 or no parameter start at the lowest possible value.





      </Parameters>
      <Returns>

        The channel number of an available channel or 0 if none could be found.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.findFreeChannel>
    <audio.freeChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of channels that are currently available for playback (not playing, not paused).


      </Description>
      <Syntax>

        audio.freeChannels





      </Syntax>
      <Example>

        local result = audio.freeChannels





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Returns the number of channels that are currently available for playback (not playing, not paused).





      </Returns>
      <Remarks>





      </Remarks>
    </audio.freeChannels>
    <audio.getDuration>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the total time in milliseconds of the audio resource. If the total length cannot be determined, -1 will be returned.


      </Description>
      <Syntax>

        audio.getDuration( audioHandle )





      </Syntax>
      <Example>

        backgroundMusic = audio.loadStream( "backgroundMusic.m4a" )
        totalTime = audio.getDuration( backgroundMusic )





      </Example>
      <Parameters>

        audioHandle

        object: The audio object returned by audio.loadStream() or audio.loadSound().





      </Parameters>
      <Returns>

        Returns the total time in milliseconds of the audio resource.





      </Returns>
      <Remarks>

        Assuming a duration can actually be determined, the number returned may not be completely accurate. Particularly for sounds loaded with loadStream(), the information may be a estimate or may just be slightly off due to inaccurate metadata. The type of file and encoding you use may have an impact on the accuracy of this value.




      </Remarks>
    </audio.getDuration>
    <audio.getMaxVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the max volume for a specific channel.


      </Description>
      <Syntax>

        audio.getMaxVolume( { channel=c } )





      </Syntax>
      <Example>

        channel1MaxVolume = audio.getMaxVolume( { channel=1 } ) -- get the max volume on channel 1





      </Example>
      <Parameters>

        channel

        integer: The channel number you want to get the max volume on. 1 to the maximum number of channels (currently 32) are valid channels. Specifying 0 will return the average volume across all channels.





      </Parameters>
      <Returns>

        Returns the channel max volume if requesting a channel volume.

        Returns the average max volume across all channels if channel=0 is specified.





      </Returns>
      <Remarks>

        There is no max volume for the master volume.




      </Remarks>
    </audio.getMaxVolume>
    <audio.getMinVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the min volume for a specific channel.


      </Description>
      <Syntax>

        audio.getMinVolume( { channel=c } )





      </Syntax>
      <Example>

        channel1MinVolume = audio.getMinVolume( { channel=1 } ) -- get the min volume on channel 1





      </Example>
      <Parameters>

        channel

        integer: The channel number you want to get the min volume on. 1 to the minimum number of channels (currently 32) are valid channels. Specifying 0 will return the average min volume across all channels.





      </Parameters>
      <Returns>

        Returns the channel min volume if requesting a channel volume.

        Returns the average min volume across all channels if channel=0 is specified.





      </Returns>
      <Remarks>

        There is no min volume for the master volume.




      </Remarks>
    </audio.getMinVolume>
    <audio.getVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the volume either for a specific channel or gets the master volume.


      </Description>
      <Syntax>

        audio.getVolume( [ { [channel=c]  } ] )





      </Syntax>
      <Example>

        masterVolume = audio.getVolume()  -- get the master volume
        channel1Volume = audio.getVolume( { channel=1 } ) -- get the volume on channel 1





      </Example>
      <Parameters>

        channel

        integer: The channel number you want to get the volume on. 1 to the maximum number of channels (currently 32) are valid channels. Specifying 0 will return the average volume across all channels. Omitting this parameter entirely gets the master volume which is different than the channel volume. All channel volumes are scaled by the master volume.





      </Parameters>
      <Returns>

        Returns the channel volume if requesting a channel volume.

        Returns the master volume if no parameters are given.

        Returns the average volume across all channels if channel=0 is specified.





      </Returns>
      <Remarks>

        Note that the master volume is not necessarily the device's ringer volume. But all volumes are scaled proportionally to the ringer volume.




      </Remarks>
    </audio.getVolume>
    <audio.isChannelActive>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the specified channel is currently playing or paused.


      </Description>
      <Syntax>

        audio.isChannelActive( channel )





      </Syntax>
      <Example>

        local isChannel1Active = audio.isChannelActive( 1 )
        if isChannel1Active then
            audio.stop( 1 )
        end





      </Example>
      <Parameters>

        channel

        integer:  The channel you want to know is active or not.





      </Parameters>
      <Returns>

        True for active, false otherwise





      </Returns>
      <Remarks>





      </Remarks>
    </audio.isChannelActive>
    <audio.isChannelPaused>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the specified channel is currently paused.


      </Description>
      <Syntax>

        audio.isChannelPaused( channel )





      </Syntax>
      <Example>

        local isChannel1Paused = audio.isChannelPaused( 1 )
        if isChannel1Paused then
            audio.resume( 1 )
        end





      </Example>
      <Parameters>

        channel

        integer:  The channel you want to know is paused or not.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </audio.isChannelPaused>
    <audio.isChannelPlaying>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the specified channel is currently playing.


      </Description>
      <Syntax>

        audio.isChannelPlaying( channel )





      </Syntax>
      <Example>

        local isChannel1Playing = audio.isChannelPlaying( 1 )
        if isChannel1Playing then
            audio.pause( 1 )
        end





      </Example>
      <Parameters>

        channel

        integer:  The channel you want to know is playing or not.





      </Parameters>
      <Returns>

        True for playing, false otherwise





      </Returns>
      <Remarks>





      </Remarks>
    </audio.isChannelPlaying>
    <audio.loadSound>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Loads an entire file completely into memory and returns a reference to the audio data. Files that are loaded completely into memory may be reused/played/shared simultaneously on multiple channels so you only need to load one instance of the file. You should use this to load all your short sounds, especially ones you may play frequently. For best results, load all the sounds at the launch of your app or the start of a new level.


      </Description>
      <Syntax>

        audio.loadSound( audiofileName [, baseDir ]  )





      </Syntax>
      <Example>

        laserSound = audio.loadSound("laserBlast.wav")
        explosionSound = audio.loadSound("explosion.mp3")





      </Example>
      <Parameters>

        audiofileName

        String: Specifies the name of the audio file you want to load. Supported file formats are determined by the platform you are running on.
        baseDir

        By default sound files are expected to be in the application resources directory. If the sound file is in the application documents directory, use system.DocumentsDirectory.





      </Parameters>
      <Returns>

        A handle to a sound file.





      </Returns>
      <Remarks>

        Please note that you are responsible for unloading (cleaning up) any audio files you load with this API. Use the audio.dispose() API to clean up audio handles you are completely done with them and want to unload from memory to get back more RAM.
        In many usage cases, you may want to use the audio file for the entire program in which case you do not need to worry about disposing of the resource.
        Audio formats supported are determined by the platform you are running on. But note that the same formats are supported between audio.loadSound() and audio.loadStream().
        Sound Formats

        All platforms support 16-bit uncompressed .wav files.
        iOS and Mac Simulator support .mp3, .caf, and .aac.
        Windows Simulator supports .mp3 along with .wav.
        As of build 269, Android now supports .mp3 and .ogg formats.




      </Remarks>
    </audio.loadSound>
    <audio.loadStream>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Loads (opens) a file to be read as a stream. Streamed files are read in little chunks at a time to minimize memory use. These  are intended for large/long files like background music and speech. Unlike files loaded with audio.loadSound(), these cannot be shared simultaneously across multiple channels. If you need to play multiple simulataneous instances of the same file, you must load multiple instances of the file.


      </Description>
      <Syntax>

        audio.loadStream( audioFileName [, baseDir ]  )





      </Syntax>
      <Example>

        backgroundMusic = audio.loadStream("backgroundMusic.m4a")
        narrationSpeech = audio.loadStream("narrationSpeech.wav")





      </Example>
      <Parameters>

        audiofileName

        String: Specifies the name of the audio file you want to load. Supported file formats are determined by the platform you are running on.
        baseDir

        By default sound files are expected to be in the application resources directory. If the sound file is in the application documents directory, use system.DocumentsDirectory.





      </Parameters>
      <Returns>

        A handle to a sound file.





      </Returns>
      <Remarks>

        Please note that you are responsible for unloading (cleaning up) any audio files you load with this API. Use the audio.dispose() API to clean up audio handles you are completely done with them and want to unload from memory to get back more RAM.
        In many usage cases, you may want to use the audio file for the entire program in which case you do not need to worry about disposing of the resource.
        Also note that streamed files may have slightly higher latency costs than files loaded with audio.loadSound(). They also may have slightly higher runtime (CPU) cost to play than files loaded with audio.loadSound().
        Audio formats supported are determined by the platform you are running on. But note that the same formats are supported between audio.loadSound() and audio.loadStream(). Also, please be aware that on some platforms and devices, hardware decoding is available for certain formats (e.g. iOS and AAC). However, only one file at a time may use the hardware decoder, in which case a software fallback is used. If you are trying to play multiple streaming sources simultaneously, you need to be prepared for the possibility of overtaxing your CPU because you are doing too much software-based on-the-fly audio decoding. Using simple formats like WAV or IMA4 do not tax the CPU hard.




      </Remarks>
    </audio.loadStream>
    <audio.pause>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Pauses playback on a channel. Has no effect on channels that aren't playing.


      </Description>
      <Syntax>

        audio.pause( [channel] )


      </Syntax>
      <Example>

        backgroundMusicChannel = audio.play( backgroundMusic, { loops=-1 }  )
        audio.pause( backgroundMusicChannel )





      </Example>
      <Parameters>

        No Parameters

        Pauses all active channels.
        channel

        integer: The channel to pause. Specifying 0 pauses all channels.





      </Parameters>
      <Returns>

        integer: The number of channels actually paused or -1 on error.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.pause>
    <audio.play>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Plays audio.
        Plays the audio specified by the audio handle on a channel. If a channel is not explicitly specified, an available channel will be automatically chosen for you if available.


      </Description>
      <Syntax>

        audio.play( audioHandle [, { [channel=c] [, loops=l] [, duration=d] [, fadein=f] [, onComplete=o]  } ] )





      </Syntax>
      <Example>

        function NarrationFinished(event)
            print("Narration Finished on channel", event.channel)
            if event.completed then
                print("Narration completed playback naturally")
            else
                print("Narration was stopped before completion")
            end
        end
         
        backgroundMusic = audio.loadStream("backgroundMusic.m4a")
        narrationSpeech = audio.loadStream("narrationSpeech.wav")
        laserSound = audio.loadSound("laserBlast.wav")
         
        backgroundMusicChannel = audio.play( backgroundMusic, { channel=1, loops=-1, fadein=5000 }  )  -- play the background music on channel 1, loop infinitely, and fadein over 5 seconds
        narrationChannel = audio.play( narrationSpeech, { duration=30000, onComplete=NarrationFinished } )  -- play the speech on any available channel, for at most 30 seconds, and invoke a callback when the audio finishes playing
        laserChannel = audio.play( laserSound )  -- play the laser on any available channel





      </Example>
      <Parameters>

        audioHandle

        object: This is the audio data you want to play.
        channel

        integer: The channel number you want to play on. 1 to the maximum number of channels (currently 32) are valid channels. Specify 0 or omit this parameter to have a channel automatically picked for you.
        loops

        integer: The number of times you want the audio to loop. Notice that 0 means the audio will loop 0 times which means that the sound will play once and not loop. Continuing that thought, 1 means the audio will play once and loop once which means you will hear the sound a total of 2 times. Passing -1 will tell the system to infinitely loop the sample.
        duration

        integer: In milliseconds, this will cause the system to play the audio for the specified amount of time and then auto-stop the playback regardless of whether the audio has finished or not.
        fadein

        integer: In milliseconds, this will cause the system to start playing a sound at the minimum channel volume and linearly ramp up to the normal channel volume over the specified number of milliseconds.
        onComplete

        function: A callback function you want to be called when playback ends. Name = "soundCompletion".
        The onComplete callback function passes back an event parameter. There are several properties available for you to use:
        channel

        integer: The channel number which just finished playing.
        handle

        object: This is the audioHandle you passed into audio.play().
        completed

        boolean: This value will be true if the audio stopped because it finished playing normally (played to the end of the sound). This value will be false if the audio was stopped because of other reasons.





      </Parameters>
      <Returns>

        integer: The channel number which the audio plays on. Returns 0 if the audio could not be played.
        Note: Issue with Android. Sound delayed by 1 to 2 seconds when started.





      </Returns>
      <Remarks>

        Currently we support 32 channels (which happens to map to an iOS OpenAL limit).

        You may not play new audio on a channel that is currently active (paused or playing).




      </Remarks>
    </audio.play>
    <audio.reserveChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Allows you to reserve a certain number of channels so they won't be automatically assigned to play on. This function blocks off the lower number channels up to the number you specify so they won't be automatically assigned to be played on when you call various play functions.
        For example, if there are 32 channels available, and you pass 2 into this function, channels 1 and 2 will be reserved so they won't be played on automatically when you specify you want to play a sound on any available channel. You can  still play on channels 1 and 2 if you explicitly designate you want to play on their channel number.
        Setting back to 0 will clear all the reserved channels so all will be available again for auto-assignment.
        As an example, this feature can be useful if you always want your music to be on channel 1 and speech on channel 2 and you don't want sound effects to ever occupy those channels. This allows you to build in certain assumptions about your code, perhaps for example, having different volume levels for music, speech, and sound effects.
        Specifying the number of reserve channels to the maximum number of channels will effectively disable auto-assignment.


      </Description>
      <Syntax>

        audio.reserveChannels( channels )





      </Syntax>
      <Example>

        audio.reserveChannels( 2 )





      </Example>
      <Parameters>

        channels

        integer: The number of channels you want to reserve. 0 will unreserve all channels.





      </Parameters>
      <Returns>

        Returns the number of currently reserved channels.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.reserveChannels>
    <audio.reservedChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of reserved channels set by audio.reserveChannels()


      </Description>
      <Syntax>

        audio.reservedChannels





      </Syntax>
      <Example>

        local result = audio.reservedChannels





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Returns the number of reserved channels set by audio.reserveChannels()





      </Returns>
      <Remarks>





      </Remarks>
    </audio.reservedChannels>
    <audio.resume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Resumes playback on a channel that is paused. Should have no effect on channels that aren't paused.


      </Description>
      <Syntax>

        audio.resume( [channel] )


      </Syntax>
      <Example>

        backgroundMusicChannel = audio.play( backgroundMusic, { loops=-1 }  )
        audio.pause( backgroundMusicChannel )
        audio.resume( backgroundMusicChannel )





      </Example>
      <Parameters>

        No Parameters

        Resumes all paused channels.
        channel

        integer: The channel to resume. Specifying 0 resumes all channels.





      </Parameters>
      <Returns>

        integer: The number of channels actually resumed or -1 on error.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.resume>
    <audio.rewind>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Rewinds audio to the beginning position on either an active channel or directly on the audio handle.


      </Description>
      <Syntax>

        audio.rewind( [, audioHandle ] [, { channel=c } ] )





      </Syntax>
      <Example>

        audio.rewind()  -- rewind all channels
        audio.rewind( backgroundMusic ) -- rewind the audio handle
        audio.rewind( { channel=1 } )  -- rewind channel 1





      </Example>
      <Parameters>

        audioHandle

        object: The audioHandle of the data you want to rewind. Should only be used for audio loaded with audio.loadStream(). Do not use the channel parameter in the same call.
        channel

        integer: The channel you want the rewind operation to apply to. Best for audio loaded with audio.loadSound(). Do not use the audioHandle parameter in the same call.





      </Parameters>
      <Returns>

        True on success or false





      </Returns>
      <Remarks>

        There are subtle behavior differences depending on whether you used audio.loadSound() or audio.loadStream() on what you are trying to rewind.
        Audio loaded with audio.loadSound() may only rewind using the channel parameter. You may not rewind using the audioHandle. This is because audio.loadSound() is optimized to share the audio data so you can play back multiple instances of the sound simultaneously (at different positions). Seeking (rewinding) the underlying data complicates this optimization.
        In contrast, audio loaded with audio.loadStream() cannot be shared (you would load multiple instances of the same file if you needed multiple, simultaneous playback). So rewinding the data does not cause a conflict. So generally you are expected to rewind using the audioHandle parameter for audio loaded with audio.loadStream(). But if you rewind streamed data using the channel parameter, it will automatically rewind as if you used the audioHandle parameter. So you are allowed to specify either parameter safely.
        Also note that for files loaded with loadStream and are currently playing, you may not hear the audio immediate update until after the current buffer finishes playing. If you want seemingly instantaneous rewinding, you should stop the playback first using audio.stop(), rewind, then start playing.




      </Remarks>
    </audio.rewind>
    <audio.seek>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Seeks to a time position on either an active channel or directly on the audio handle.


      </Description>
      <Syntax>

        audio.seek( time [, audioHandle ] [, { channel=c } ] )





      </Syntax>
      <Example>

        audio.seek(3000)  -- seek all active channels to 3 seconds
        audio.seek(4000, backgroundMusic) -- seek the audio handle to 4 seconds
        audio.seek(5000, { channel=1 } )  -- seek channel 1 to 5 seconds





      </Example>
      <Parameters>

        time

        integer: The time in milliseconds you want to seek to
        audioHandle

        object: The audioHandle of the data you want to seek. Should only be used for audio loaded with audio.loadStream(). Do not use the channel parameter in the same call.
        channel

        integer: The channel you want the seek operation to apply to. Best for audio loaded with audio.loadSound(). Do not use the audioHandle parameter in the same call.





      </Parameters>
      <Returns>

        True on success or false





      </Returns>
      <Remarks>

        There are subtle behavior differences depending on whether you used audio.loadSound() or audio.loadStream() on what you are trying to seek.
        Audio loaded with audio.loadSound() may only seek using the channel parameter. You may not seek using the audioHandle. This is because audio.loadSound() is optimized to share the audio data so you can play back multiple instances of the sound simultaneously (at different positions). Seeking the underlying data complicates this optimization.
        In contrast, audio loaded with audio.loadStream() cannot be shared (you would load multiple instances of the same file if you needed multiple, simultaneous playback). So seeking the data does not cause a conflict. So generally you are expected to seek using the audioHandle parameter for audio loaded with audio.loadStream(). But if you seek streamed data using the channel parameter, it will automatically seek as if you used the audioHandle parameter. So you are allowed to specify either parameter safely.
        Also note that for files loaded with loadStream and are currently playing, you may not hear the audio immediate update until after the current buffer finishes playing. If you want seemingly instantaneous seeking, you should stop the playback first using audio.stop(), seek, then start playing.




      </Remarks>
    </audio.seek>
    <audio.setMaxVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Clamps the max volume to the set value. Any volumes that exceed the max volume will be played at the max volume level.


      </Description>
      <Syntax>

        audio.setMaxVolume( volume, { channel=c } )





      </Syntax>
      <Example>

        audio.setMaxVolume( 0.75, { channel=1 } ) -- set the max volume on channel 1





      </Example>
      <Parameters>

        volume

        number: The new max volume level you want to apply. Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum value.
        channel

        integer: The channel number you want to set the max volume on. 1 to the maximum number of channels (currently 32) are valid channels. Specify 0 to apply the max volume to all the channels.





      </Parameters>
      <Returns>

        True on success, false on failure.





      </Returns>
      <Remarks>

        There is no max volume for the master volume.




      </Remarks>
    </audio.setMaxVolume>
    <audio.setMinVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Clamps the min volume to the set value. Any volumes that go below the min volume will be played at the min volume level.


      </Description>
      <Syntax>

        audio.setMinVolume( volume, { channel=c } )





      </Syntax>
      <Example>

        audio.setMinVolume( 0.25, { channel=1 } ) -- set the min volume on channel 1





      </Example>
      <Parameters>

        volume

        number: The new min volume level you want to apply. Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum volume value.
        channel

        integer: The channel number you want to set the min volume on. 1 to the minimum number of channels (currently 32) are valid channels. Specify 0 to apply the min volume to all the channels.





      </Parameters>
      <Returns>

        True on success, false on failure.





      </Returns>
      <Remarks>

        There is no min volume for the master volume.




      </Remarks>
    </audio.setMinVolume>
    <audio.setVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the volume either for a specific channel or sets the master volume.


      </Description>
      <Syntax>

        audio.setVolume( volume [, { [channel=c]  } ] )





      </Syntax>
      <Example>

        audio.setVolume( 0.5 )  -- set the master volume
        audio.setVolume( 0.75, { channel=1 } ) -- set the volume on channel 1





      </Example>
      <Parameters>

        volume

        number: The new volume level you want to apply. Valid numbers range from 0.0 to 1.0, where 1.0 is the maximum volume value.
        channel

        integer: The channel number you want to set the volume on. 1 to the maximum number of channels (currently 32) are valid channels. Specify 0 to apply the volume to all the channels. Omitting this parameter entirely sets the master volume which is different than the channel volume. All channel volumes are scaled by the master volume.





      </Parameters>
      <Returns>

        True on success, false on failure.





      </Returns>
      <Remarks>

        Note that the master volume is not necessarily the device's ringer volume. But all volumes are scaled proportionally to the ringer volume.
        When you set the volume, that new volume level is persistent until you set it again. Particularly with channels, you should always keep this in mind. If you change the volume, say on channel 1, channel 1 will continue to stay set at that level even if the sound finishes playing on that channel and you start playing a new sound on that channel.
        If you are playing audio with auto-assigned channels, please understand that if you had previously changed the volume on the channel you are auto-assigned, the volume will play at that level for your new sound. For defensive programming, you may consider using manual channel assignment for channels you intend to change the volume for (e.g. background music channel) and use the reserveChannels API to prevent those channels from being auto-assigned.
        Or alternatively, if you wish to simply reset the volume after playback, you can utilize the onComplete function callbacks as an opportunity to reset the volume.
        Also be aware that volumes may affect OpenAL effects if/when Corona exposes them.




      </Remarks>
    </audio.setVolume>
    <audio.stop>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Stops playback on a channel and clears the channel so it can be played on again. Callbacks will still be invoked, but the completed flag will be set to false.


      </Description>
      <Syntax>

        audio.stop( [channel] )

      </Syntax>
      <Example>

        backgroundMusicChannel = audio.play( backgroundMusic, { loops=-1 }  )
        audio.stop( backgroundMusicChannel )





      </Example>
      <Parameters>

        No Parameters

        Stops all active channels.
        channel

        integer: The channel to stop. Specifying 0 stops all channels.





      </Parameters>
      <Returns>

        integer: The number of channels actually stopped or -1 on error.





      </Returns>
      <Remarks>

        Currently, passing nil as a parameter is treated the same as passing 0 or passing no parameter which means all active channels are stopped. This behavior may change in the future.
        Also note that audio.stop does not take any handles from audio.loadSound/audio.loadStream. This is by design. You are intended to stop specific channels, not sound handles. Imagine multiple explosion effects all going off at about the same time. (I should also point out that all the explosions may not have started at exactly the same time and the effects overlap like in a chain reaction.) In this case, it doesn't really make any sense to call audio.stop() on just the explosion_handle because the question becomes, which specific explosion did you want to stop? If you wanted to stop all of them (remember they may be starting at different times and are not sync'd), why would you only want to stop just the explosions and not the other sound effects like the bullets or fuses or whatever. Usually in this kind of case, you want to stop everything and not a specific handle. But if you did have some specific weird usage case where this is useful to you, this can be accomplished by tracking the channels you are playing specific effects on yourself.
        For audio loaded with audio.loadStream, the position of the audio will not be reset when stop is called. So when if you call audio.play again on the same handle, it will continue approximately where it left off (approximately meaning it might be a little further down because all the pre-filled buffers were discarded on the audio.stop). This contrasts with audio loaded with audio.loadSound which will start playing at the beginning of the starting position of the buffer (e.g. beginning of the sound unless you modified it with audio.seek). So for audio.loadStream, you may want to call audio.rewind() on the handle if you reuse the audio handle.




      </Remarks>
    </audio.stop>
    <audio.stopWithDelay>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Stops the playing a currently playing sound at the specified amount of time.


      </Description>
      <Syntax>

        audio.stopWithDelay( duration [, { [ channel = c ] } ] )





      </Syntax>
      <Example>

        backgroundMusicChannel = audio.play( backgroundMusic, { loops=-1 }  )
        audio.stopWithDelay( 30000, { channel = backgroundMusicChannel }  )





      </Example>
      <Parameters>

        duration

        integer: In milliseconds, when to stop playing
        channel

        integer: The channel to stop. Specifying 0 stops all channels.





      </Parameters>
      <Returns>

        integer: The number of channels actually applied to or -1 on error.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.stopWithDelay>
    <audio.totalChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the total number of channels. (Should be 32 for now, but this limit may be subject to change in the future.)


      </Description>
      <Syntax>

        audio.totalChannels





      </Syntax>
      <Example>

        local result = audio.totalChannels





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Returns the total number of channels. (Should be 32 for now, but this limit may be subject to change in the future.)





      </Returns>
      <Remarks>





      </Remarks>
    </audio.totalChannels>
    <audio.unreservedFreeChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of channels that are currently available for playback (not playing, not paused), excluding the channels that have been reserved.


      </Description>
      <Syntax>

        audio.unreservedFreeChannels





      </Syntax>
      <Example>

         local result = audio.unreservedFreeChannels





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Returns the number of channels that are currently available for playback (not playing, not paused), excluding the channels that have been reserved.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.unreservedFreeChannels>
    <audio.unreservedUsedChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of channels that are currently in use (playing/paused), excluding the channels that have been reserved.


      </Description>
      <Syntax>

        audio.unreservedUsedChannels





      </Syntax>
      <Example>

        local result = audio.unreservedUsedChannels





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Returns the number of channels that are currently in use (playing/paused), excluding the channels that have been reserved.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.unreservedUsedChannels>
    <audio.usedChannels>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of channels that are currently in use (playing/paused).


      </Description>
      <Syntax>

        audio.usedChannels





      </Syntax>
      <Example>

         local result = audio.usedChannels





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Returns the number of channels that are currently in use (playing/paused). The count includes both reserved and unreserved channels.





      </Returns>
      <Remarks>





      </Remarks>
    </audio.usedChannels>
  </Audio>
  <Basic_Functions>
    <_G>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A global variable (not a function) that holds the global environment (that is, _G._G = _G). Lua itself does not use this variable; changing its value does not affect any environment, nor vice-versa. (Use setfenv to change environments.)


      </Description>
      <Syntax>

        _G





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </_G>
    <assert>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Issues an error and aborts the program when the value of its argument v is false (i.e., nil or false); otherwise, returns all its arguments. message is an error message; when absent, it defaults to "assertion failed!" The error message is displayed in the Terminal or Console.


      </Description>
      <Syntax>

        assert ( v [, message] )





      </Syntax>
      <Example>

        -- This will abort the program if the image is not found (in the Resource directory)
        local img = display.newImage("imageWithWrongName.png")
        assert( img, "Error: Image not found!" )





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        Assert is a useful tool to catch unexpected situations.




      </Remarks>
    </assert>
    <error>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Terminates the last protected function called and returns message as the error message. Function error never returns.
        Usually, error adds some information about the error position at the beginning of the message. The level argument specifies how to get the error position. With level 1 (the default), the error position is where the error function was called. Level 2 points the error to where the function that called error was called; and so on. Passing a level 0 avoids the addition of error position information to the message.


      </Description>
      <Syntax>

        error (message [, level])





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </error>
    <getfenv>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the current environment in use by the function. f can be a Lua function or a number that specifies the function at that stack level: Level 1 is the function calling getfenv. If the given function is not a Lua function, or if f is 0, getfenv returns the global environment. The default for f is 1.


      </Description>
      <Syntax>

        getfenv ([f])





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </getfenv>
    <getmetatable>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        If object does not have a metatable, returns nil. Otherwise, if the object's metatable has a "__metatable" field, returns the associated value. Otherwise, returns the metatable of the given object.


      </Description>
      <Syntax>

        getmetatable (object)





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </getmetatable>
    <ipairs>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns three values: an iterator function, the table t, and 0, so that the construction
        for i,v in ipairs(t) do body end
        will iterate over the pairs (1,t[1]), (2,t[2]), ..., up to the first integer key absent from the table.


      </Description>
      <Syntax>

        ipairs (t)





      </Syntax>
      <Example>

        local t = { "every", "word", "is", "on", "a", "separate", "line." }
        for i,v in ipairs(t) do
           print( v ) -- print each array element on a separate line
        end
        NOTE: for performance reasons, we encourage you to do the following instead:
        local t = { "every", "word", "is", "on", "a", "separate", "line." }
        for i=1,#t do
           local v = t[i]
           print( v ) -- print each array element on a separate line
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </ipairs>
    <next>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Allows a program to traverse all fields of a table. Its first argument is a table and its second argument is an index in this table. next returns the next index of the table and its associated value. When called with nil as its second argument, next returns an initial index and its associated value. When called with the last index, or with nil in an empty table, next returns nil. If the second argument is absent, then it is interpreted as nil. In particular, you can use next(t) to check whether a table is empty.
        The order in which the indices are enumerated is not specified, even for numeric indices. (To traverse a table in numeric order, use a numerical for or the ipairs function.)
        The behavior of next is undefined if, during the traversal, you assign any value to a non-existent field in the table. You may however modify existing fields. In particular, you may clear existing fields.


      </Description>
      <Syntax>

        next (table [, index])





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </next>
    <pairs>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns three values: the next function, the table t, and nil, so that the construction
             for k,v in pairs(t) do body end
        will iterate over all keyâ€“value pairs of table t.
        See function next for the caveats of modifying the table during its traversal.


      </Description>
      <Syntax>

        pairs (t)





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </pairs>
    <pcall>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Calls function f with the given arguments in protected mode. This means that any error inside f is not propagated; instead, pcall catches the error and returns a status code. Its first result is the status code (a boolean), which is false if the call succeeds without errors. In such case, pcall also returns all results from the call, after this first result. In case of any error, pcall returns false plus the error message.


      </Description>
      <Syntax>

        pcall (f, arg1, ...)





      </Syntax>
      <Example>

        -- This function will fail and normally stop the simulator because
        -- we are trying to concatenate a nil value. The pcall will
        -- catch and display the error without stopping the simulator.
        --
        function myPrint( value )
            local foo = value .. nil
        end
         
        print( pcall( myPrint, "hello" ) ) -- print false and error message





      </Example>
      <Parameters>

        f

        The function to be called.
        arg

        One or more arguments for the called function.





      </Parameters>
      <Returns>

        status

        True is the function worked or false if the function failed and generated a run-time error.
        results/error

        The results of the function (if status is true), otherwise the error message generated by the called function.





      </Returns>
      <Remarks>

        The function and parameters may need to be enclosed in a function called by "pcall" in order to catch all errors. The calling function's parameters may generate an error that would not otherwise be caught by "pcall". See the example above.




      </Remarks>
    </pcall>
    <print>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Receives any number of arguments, and prints their values to stdout (terminal, Xcode, ADB, etc.), using the tostring function to convert them to strings. print is not intended for formatted output, but only as a quick way to show a value, typically for debugging. For formatted output, use string.format.
        This API is useful for debugging your application to verify the value of variables and Display Objects and program flow.


      </Description>
      <Syntax>

        print (...)





      </Syntax>
      <Example>

        local rect = display.newRect( 0, 0, 100, 200 )
        local value = 125
        print( "Hello world" ) -- Hello world
        print( 5 )  -- 5
        print( "Value = " .. 5 ) -- Value = 5
        print( "Values", 5, 10 ) -- Values     5     10
        print( "Value = " .. tonumber( value ) ) -- Value = 125
        print( "Display Object: " .. tostring( rect ) ) -- Display Object: table: 0x19a21df0





      </Example>
      <Parameters>

        1
        String(s) or number(s) to print.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        On the Mac Simulator and Windows Simulator, the print output goes to the terminal window.
        On iOS devices, the Xcode console will display the print messages if the device is connected to the Xcode console.
        On Android devices, the ADB (debugger) will display the print messages.




      </Remarks>
    </print>
    <rawequal>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Checks whether v1 is equal to v2, without invoking any metamethod. Returns a boolean.


      </Description>
      <Syntax>

        value = rawequal (v1, v2)





      </Syntax>
      <Example>

        local v1 = 5
        local v2 = 5
        print( rawequal( v1, v2) ) -- true





      </Example>
      <Parameters>

        v1, v2

        Two values to be compared. Can be numbers or strings.





      </Parameters>
      <Returns>

        Boolean: True if the two values are equal or false if they are not.





      </Returns>
      <Remarks>





      </Remarks>
    </rawequal>
    <rawget>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the real value of table[index], without invoking any metamethod. table must be a table; index may be any value.


      </Description>
      <Syntax>

        value = rawget (table, index)





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        table

        Table.
        index

        Index into table.





      </Parameters>
      <Returns>

        Value from table at index.





      </Returns>
      <Remarks>





      </Remarks>
    </rawget>
    <rawset>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the real value of table[index] to value, without invoking any metamethod. table must be a table, index any value different from nil, and value any Lua value.
        This function returns table.


      </Description>
      <Syntax>

        rawset (table, index, value)





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        table

        Table.
        index

        Index into table.
        value

        Value to be written into table at index.





      </Parameters>
      <Returns>

        Table.





      </Returns>
      <Remarks>





      </Remarks>
    </rawset>
    <select>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        If index is a number, returns all arguments after argument number index. Otherwise, index must be the string "#", and select returns the total number of extra arguments it received.


      </Description>
      <Syntax>

        select (index, ... )





      </Syntax>
      <Example>

        The following sample demonstrates how to use select() to access individual return values from a function that returns multiple values:
          print(string.find("hello hello", " hel"))         --&gt; 6  9
          print(select(1, string.find("hello hello", " hel"))) --&gt; 6
          print(select(2, string.find("hello hello", " hel"))) --&gt; 9
        This example prints the total number of extra arguments passed to the select() function:
          print(select("#", a,b,c)) --&gt; 3





      </Example>
      <Parameters>

        index

        This parameter can either be a number, in which case the select() returns all arguments after argument number index. Otherwise, index must be the string "#", and select() returns the total number of extra arguments it received.





      </Parameters>
      <Returns>

        Returns all arguments after argument number index, if index is a number. Otherwise, index must be the string "#", and select returns the total number of extra arguments it received.





      </Returns>
      <Remarks>





      </Remarks>
    </select>
    <setfenv>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the environment--or the table where Lua keeps all its global variables--to be used by the given function.


      </Description>
      <Syntax>

        setfenv (f, table)





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        f

        Function or Number: If f is a function, then setfenv() sets the environment for that function. If a number is specified, the environment for the function at that stack level is set. Number 1 means the current function, number 2 means the function calling the current function, and so on. As a special case, when set to 0 setfenv() changes the environment of the running thread. In this last case, nothing is returned.
        table

        Lua table: The table containing the new environment.





      </Parameters>
      <Returns>

        The given function f.





      </Returns>
      <Remarks>





      </Remarks>
    </setfenv>
    <setmetatable>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the metatable for the given table. (You cannot change the metatable of other types from Lua, only from C). If metatable is nil, removes the metatable of the given table. If the original metatable has a "__metatable" field, raises an error.
        This function returns table.


      </Description>
      <Syntax>

        setmetatable (table, metatable)





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        table

        Table: The Lua table whose metatable you want to modify.

        metatable

        Table: The Lua table to set as the new metatable for table





      </Parameters>
      <Returns>

        The table provided as the first parameter.





      </Returns>
      <Remarks>





      </Remarks>
    </setmetatable>
    <tonumber>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Tries to convert its argument to a number. If the argument is already a number or a string convertible to a number, then tonumber returns this number; otherwise, it returns nil.
        An optional argument specifies the base to interpret the numeral. The base may be any integer between 2 and 36, inclusive. In bases above 10, the letter 'A' (in either upper or lower case) represents 10, 'B' represents 11, and so forth, with 'Z' representing 35. In base 10 (the default), the number can have a decimal part, as well as an optional exponent part. In other bases, only unsigned integers are accepted.


      </Description>
      <Syntax>

        tonumber (e [, base])





      </Syntax>
      <Example>

        This sample converts the string "42" to a number.

          local numString = "42"
          local numValue = tonumber(numString)
          if numValue ~= nil then
            -- got a number back
          end





      </Example>
      <Parameters>

        e

        The value to to convert to a number.
        base (optional)

        Number: Specifies the base to interpret the numeral. See the Description above for more information.





      </Parameters>
      <Returns>

        A number, or nil if the first argument can't be converted to a number.





      </Returns>
      <Remarks>





      </Remarks>
    </tonumber>
    <tostring>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Converts any argument to a string.
        This API is useful debug tool for displaying or concatenating "nil" values or displaying Display Object table information
        Note: For complete control of how numbers are converted to strings, use string.format().


      </Description>
      <Syntax>

        tostring (e)





      </Syntax>
      <Example>

        local rect = display.newRect( 0, 0, 100, 200 )
        print( "Display Object: " .. tostring( rect ) ) -- Display Object: table: 0x19a21df0





      </Example>
      <Parameters>

        e

        (Any type) Item to convert.





      </Parameters>
      <Returns>

        A string.
        If the metatable of e has a __tostring field, then tostring() calls the corresponding value with e as argument, and passes the result of the call as its result.





      </Returns>
      <Remarks>





      </Remarks>
    </tostring>
    <type>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the type of its argument.


      </Description>
      <Syntax>

         value = type( v )





      </Syntax>
      <Example>

        local rect = display.newRect( 0, 0, 100, 200 )
        print( type( rect ) ) -- table
         
        print( type( "Hello World" ) ) -- string





      </Example>
      <Parameters>

        v

        The item whose type is to be determined.





      </Parameters>
      <Returns>

        string: The possible results of this function are:

        "nil" (a string, not the value nil)
        "number"
        "string"
        "boolean"
        "table"
        "function"
        "thread", and
        "userdata"






      </Returns>
      <Remarks>





      </Remarks>
    </type>
    <unpack>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the elements from the given table. This function is equivalent to the following:
        return list[i], list[i+1], ..., list[j]
        The difference is that the above code can be written only for a fixed number of elements. By default, i is 1 and j is the length of the list, as defined by the length operator.


      </Description>
      <Syntax>

        unpack( list [, i [, j ]])





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        list

        The table whose elements will be unpacked.
        i

        Number: The index of the table element at which the function will begin unpacking values. By default, this is 1.
        j

        Number: The index of the table element at which  the function will stop unpacking values. By default, this is the length of the given table provided by the lengthoperator.





      </Parameters>
      <Returns>

        The elements of the given table between i and j.





      </Returns>
      <Remarks>





      </Remarks>
    </unpack>
  </Basic_Functions>
  <Credits_Virtual_Currency>
    <credits.init>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Initializes the Super Rewards API in an app with a specific Application Identifier (string provided by Super Rewards) and a callback function (listener) to handle Super Rewards events.
        To learn more, go to the Credits (Virtual Currency) Guide.
        Note: Adding "require credits" to your code will enable Corona Launchpad regardless of the setting in config.lua.


      </Description>
      <Syntax>

        credits.init( appId, [, uid], listener )





      </Syntax>
      <Example>

        local credits = require "credits"
         
        local creditsListener = function( event )
         
            print( event.name ) -- outputs "creditsRequest"
         
            if ( event.isError ) then
                print( "An error occurred. Request failed" )
            else
                print( event.newCredits ) -- number of new credits earned
                print( event.totalCredits ) -- total available credits
            end
        end
         
        credits.init( "yourAppIdHere", creditsListener )
        credits.showOffers()
        credits.requestUpdate()





      </Example>
      <Parameters>

        appId

        Application Identifier (string provided by Super Rewards).
        uid

        The optional uid argument in the function is used to set a "test user id" for your build, so you can test offer completion without having to actually complete a real offer. In the Admin section when you manage your app (in the Super Rewards back-end), you must specify this same test user id in the field provided (recommended uids: 1001, 1002, 1003, and so on).
        It's important to note that once you test and unlock a test offer with a uid, you must create a new build with a different uid. There's no way to reset a uid and unlock an offer again.
        For your final app build, you should not set the uid argument in the function above.
        listener

        Callback function (listener) to handle Super Rewards events.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </credits.init>
    <credits.requestUpdate>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sends an async http request to fetch the number of credits (new and total amounts). This function also sends events to the listener specified in credits.init().
        To learn more, go to the Credits (Virtual Currency) Guide.


      </Description>
      <Syntax>

        credits.requestUpdate()





      </Syntax>
      <Example>

        local credits = require "credits"
         
        local creditsListener = function( event )
         
            print( event.name ) -- outputs "creditsRequest"
         
            if ( event.isError ) then
                print( "An error occurred. Request failed" )
            else
                print( event.newCredits ) -- number of new credits earned
                print( event.totalCredits ) -- total available credits
            end
        end
         
        credits.init( "yourAppIdHere", creditsListener )
        credits.showOffers()
        credits.requestUpdate()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </credits.requestUpdate>
    <credits.showOffers>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Displays a native overlay that will present offers to the user via a scrolling list. Users can complete offers from this overlay, or dismiss it and return to the app.
        To learn more, go to the Credits (Virtual Currency) Guide.


      </Description>
      <Syntax>

        credits.showOffers()





      </Syntax>
      <Example>

        local credits = require "credits"
         
        local creditsListener = function( event )
         
            print( event.name ) -- outputs "creditsRequest"
         
            if ( event.isError ) then
                print( "An error occurred. Request failed" )
            else
                print( event.newCredits ) -- number of new credits earned
                print( event.totalCredits ) -- total available credits
            end
        end
         
        credits.init( "yourAppIdHere", creditsListener )
        credits.showOffers()
        credits.requestUpdate()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </credits.showOffers>
  </Credits_Virtual_Currency>
  <Crypto>
    <crypto.digest>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Generates the message digest of the input string and returns it.


      </Description>
      <Syntax>

        crypto.digest (algorithm, string [, raw] )





      </Syntax>
      <Example>

        require "crypto"
        print (crypto.digest( crypto.md4, "test" ))        --&gt;  db346d691d7acc4dc2625db19f9e3f52





      </Example>
      <Parameters>

        algorithm

        A constant specifying the hashing algorithm.
        string

        The input string.
        raw

        (Optional)  Boolean indicating whether the output should be a direct binary equivalent of the message digest.  If false (the default), the result is formatted as a hexadecimal string.





      </Parameters>
      <Returns>

        The message digest, a string.





      </Returns>
      <Remarks>





      </Remarks>
    </crypto.digest>
    <crypto.hmac>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Computes HMAC (Key-Hashing for Message Authentication Code) of the string and returns it.


      </Description>
      <Syntax>

         crypto.hmac( algorithm, string, key [, raw] )





      </Syntax>
      <Example>

        require "crypto"
        print (crypto.hmac( crypto.md5, "key", "test" ))   --&gt;  171d80f9cebec0767287d2eb2e4b2abc





      </Example>
      <Parameters>

        algorithm

        A constant specifying the hashing algorithm.  Note: HMAC is not available for crypto.md4.
        string

        The input string.
        key

        String to use as the seed for the HMAC generation.
        raw

        (Optional)   Boolean indicating whether the output should be a direct binary equivalent of the message digest. If false (the default), the result is formatted as a hexadecimal string.





      </Parameters>
      <Returns>

        A string.





      </Returns>
      <Remarks>





      </Remarks>
    </crypto.hmac>
  </Crypto>
  <Display_Objects />
  <CommonMethods>
    <object..addEventListener>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Adds a listener to the objectâ€™s list of listeners.   When the named event occurs, the listener will be invoked and be supplied with a table representing the event.


      </Description>
      <Syntax>

        object:addEventListener( eventName, listener )





      </Syntax>
      <Example>

        Listeners can be either functions or table objects.
        When a function listener is invoked, it is passed a table representing the event:

        local myListener = function( event )
                print( "Listener called with event of type " .. event.name )
        end
        Runtime:addEventListener( "touch", myListener )
        Runtime:addEventListener( "enterFrame", myListener )
        Sometimes a function listener is not convenient because certain variables are not in scope when the listener is triggered (invoked). In these situations, object listeners should be used. Object listeners must have an instance method with a name corresponding to the event name:
        -- assume MyClass and MyClass:new() already exist
         
        function MyClass:enterFrame( event )
                print( "enterFrame called at time: " .. event.time )
        end
         
        function MyClass:touch( event )
                print( "touch occurred at ("..event.x..","..event.y..")" )
        end
         
        local myObject = MyClass:new()
         
        Runtime:addEventListener( "touch", myObject )
        Runtime:addEventListener( "enterFrame", myObject )





      </Example>
      <Parameters>

        eventName

        String specifying the name of the event to listen for.
        listener

        If the event's event.name matches this string, listener will be invoked.  Event listeners are either functions or objects (a.k.a. table listeners).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: You cannot add an object event listener within the listener event for that object. You should add the listener event outside of the current listener using the timer.performWithDelay() API. Failing to do so will cause the new listener to be called immediately after the current listener returns.
        Another solution to the problem is using a single event listener for the object and adding a "state" variable to control what function is performed when invoked.
        1
        2
        3
        4
        5
        6
        7
        8
        9
        10
        11
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
        29
        30
        31
        32
        33
        34
        local addListener1, addListener2        -- forward references
         
        -- create a large button
        local rect = display.newRect( 0, 0, display.contentWidth, display.contentHeight )
        rect:setFillColor( 128, 64, 64 )
         
        -- state1
        function state1Cb( event )
            print("state1")
            rect:removeEventListener( "tap", state1Cb )
            --rect:addEventListener( "tap", state2Cb )  -- ** Don't do this
            timer.performWithDelay( 1, addListener2 )   -- ** Do this instead
            return true  
        end
         
        -- state2
        function state2Cb( event )
            print("state2")
            rect:removeEventListener( "tap", state2Cb )
            --rect:addEventListener( "tap", state1Cb )  -- ** Don't do this
            timer.performWithDelay( 1, addListener1 )   -- ** Do this instead
            return true  
        end
         
        function addListener2( )
            rect:addEventListener( "tap", state2Cb )
        end
         
        function addListener1()
            rect:addEventListener( "tap", state1Cb )
        end
         
        -- start
        addListener1()  -- add first listener




      </Remarks>
    </object..addEventListener>
    <object..contentToLocal>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Maps given x and y values in content (or stage) coordinates to the target object's local coordinates (center point).


      </Description>
      <Syntax>

        x_local, y_local = object:contentToLocal(x_content, y_content)





      </Syntax>
      <Example>

        The following sample draws a full screen rectangle on the screen and displays the touch event's x and y coordinates in stage (content) and local coordinates as you drag your finger (or mouse) around the screen.
        -- Rectangle that fills screen
        local rect = display.newRect( 0, 0, display.contentWidth, display.contentHeight )    
        rect:setStrokeColor(255,255,255)      
        rect.strokeWidth = 5
        rect:setFillColor(0,0,0)              
        display.setDefault( "textColor", 255, 255,255 )
         
        -- Text objects to display content and local coordinates
        local contentText = display.newText("", 0, 0, display.nativeSystemFont, 16)
        local localText = display.newText("", 0, 0, display.nativeSystemFont, 16)
        localText:setReferencePoint(display.TopLeftReferencePoint)
        contentText:setReferencePoint(display.TopLeftReferencePoint)
         
        function showCoordinates( event )                      
        --      Get x, y of touch event in content coordinates
                local contentx, contenty = event.x, event.y
        --      Convert to local coordinates of
                local localx, localy = event.target:contentToLocal(contentx, contenty)        
        --      Display content and local coordinate values
                contentText.text = tostring(contentx) .. ", " .. tostring(contenty)
                localText.text = tostring(localx) .. ", " .. tostring(localy)
                contentText.x, contentText.y = event.x + 20, event.y
                localText.x, localText.y = event.x+20, event.y +20                  
                localText:setReferencePoint(display.TopLeftReferencePoint)
                contentText:setReferencePoint(display.TopLeftReferencePoint)
            return true
        end
         
        rect:addEventListener("touch", showCoordinates)  





      </Example>
      <Parameters>

        x

        Number: The x coordinate in content (display) space.

        y

        Number: The y coordinate in content (display) space.





      </Parameters>
      <Returns>

        The x and y coordinates of the given values in the object's local coordinate space.
        Note: The values returned are relative to the Display Object's center point. The reference point is not used for calculating the returned values -- they are fixed at the object's center.  (display.setReferencePoint will not change the returned value.) The returned values will be negative if the given x,y point is above or left of the local object's center point.





      </Returns>
      <Remarks>

        This method may be useful for determining how close touch events are to grouped display objects. Also, see object.contentBounds.




      </Remarks>
    </object..contentToLocal>
    <object..dispatchEvent>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Dispatches event to object. The event parameter must be a table with a name property which is a string identifying the type of event. The object parameter must be either a display object or the global Runtime object. If object has a listener registered to receive name events. We recommend you also include a target property to the event so that your listener can know which object received the event.
        In Corona, you can register custom events with both display objects and the global Runtime object. In both cases, you will have to manually dispatch the event yourself using this object method.


      </Description>
      <Syntax>

        object:dispatchEvent( event )





      </Syntax>
      <Example>

        -- Create an object that listens to events
        local image = display.newImage( "image.png" )
         
        -- Setup listener
        local myListener = function( event )
                print( "Event " .. event.name )
                print( "Target has width: " .. event.target.stageWidth )
        end
         
        image:addEventListener( "myEventType", myListener )
         
        -- Sometime later, create an event and dispatch it
        local event = { name="myEventType", target=image }
        image:dispatchEvent( event )





      </Example>
      <Parameters>

        event

        table: contains event properties





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </object..dispatchEvent>
    <object..localToContent>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Maps given x and y coordinates (center) in local coordinates to content (or stage) coordinates.
        This method is useful for mapping the coordinates of a display object within a group to the content (viewable display screen).


      </Description>
      <Syntax>

        x_content, y_content = object:localToContent(x, y)





      </Syntax>
      <Example>

        local group = display.newGroup() -- Create a group
         
        local rect = display.newRect( 0, 0, 10, 20 ) -- Create a rectangle object
        group:insert( rect ) -- add rect to group
         
        group.x = 100; group.y = 200    -- move the group
         
        rect:setReferencePoint( display.TopLeftReferencePoint )
         
        rect.x = 5
        rect.y = 10
         
        rectContentX, rectContentY = rect:localToContent( 0, 0 )
        groupContentX, groupContentY = group:localToContent( 0, 0 )
         
        print( "group's position on screen: ", groupContentX, groupContentY )  -- prints 100, 200
        print( "group.x,y: ", group.x, group.y )  -- prints 100,200
         
        print( "rect's position on screen: ", rectContentX, rectContentY  )  -- prints 110, 220
        print( "rect.x,y: ", rect.x, rect.y ) -- prints 5, 10





      </Example>
      <Parameters>

         

        The x and y values are coordinates relative to the display object's center point. Point 0,0 references the center point of the object.





      </Parameters>
      <Returns>

        numbers: X and Y Content coordinates. Content coordinates are relative to the Top Left position (0,0) on the screen in both portrait and landscape modes.
        Note: The values returned are relative to the Display Object's center point. The reference point is not used for calculating the returned values -- they are fixed at the object's center.  (display.setReferencePoint will not change the returned value.)





      </Returns>
      <Remarks>

        This method is useful for comparing the location of display objects in different groups. When a display object is inserted into a group, the x,y properties for the object is relative to it's group (parent)  and not the content (stage). object.localTocontent could be used to return the Content coordinates of each of the objects (from different groups) to determine the physical relationship between the objects.
        This method is similar to object.contentBounds, but only returns the x,y point of the object. (contentBounds returns the content coordinates of xMin, yMin, xMax, yMax).




      </Remarks>
    </object..localToContent>
    <object..removeEventListener>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Removes the specified listener from the object's list of listeners so that it no longer is notified of events corresponding to the specified event.


      </Description>
      <Syntax>

        object:removeEventListener( eventName, listener )





      </Syntax>
      <Example>

        -- define motion and limits
        local DX, DY = 3, 3
        local XMIN, XMAX = 1, display.contentWidth - 1
        local YMIN, YMAX = 20, display.contentHeight - 1
         
        -- create a shape
        local button = display.newRoundedRect( XMIN, YMIN, 150, 50, 5 )
        button:setFillColor( 100, 0, 255 )
        button.strokeWidth = 6
        button:setStrokeColor( 200,200,200,255 )
         
        -- move the shape until it hits the limits
        local function onFrame (event)
            if button.x + button.width/2 &gt; XMAX or button.x  XMIN
            or button.y + button.height/2 &gt; YMAX or button.y  YMIN then
                -- stop
                Runtime:removeEventListener("enterFrame", onFrame)
            else
                -- move
                button.x = button.x + DX
                button.y = button.y + DX
            end
        end
         
        -- update the position every frame
        Runtime:addEventListener( "enterFrame", onFrame )





      </Example>
      <Parameters>

        eventName

        String specifying the name of the event whose corresponding listener should be removed from the list.
        listener

        Name of the listener to remove from the list.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..removeEventListener>
    <object..removeSelf>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Removes the display object and frees its memory, assuming there are no other references to it. This is equivalent to calling group:remove(IndexOrChild) on the same display object, but is syntactically simpler. The removeSelf() syntax is also supported in other cases, such as removing physics joints in the Physics engine.
        See the section on removing objects properly in the Application Programming Guide for more on memory management and display object removal.
        removeSelf converts a display object into a normal Lua table that will be garbage collected if there are not other references to the object. You should also set the object to nil after removing it.


      </Description>
      <Syntax>

        object:removeSelf( )





      </Syntax>
      <Example>

        -- Cull offscreen objects
        local function removeOffscreenItems()
                for i = 1, #allItems do
                        local anItem = allItems[i]
                        if (anItem.x) then                        
                                if anItem.x  -100 or anItem.x &gt; display.contentWidth + 100
                                    or anItem.y  -100 or anItem.y &gt; display.contentHeight + 100 then
                                        anItem:removeSelf()
                                end    
                        end
                end
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        When an object is removed, the rendering-related resources of the removed object are deleted immediately. What remains of object is simply a plain Lua table with all non-display object properties (the metatable is set to nil and all properties relating to display object are removed). Thus, if there are still references to object in Lua, they will simply be references to a normal Lua table.
        See http://developer.anscamobile.com/content/memory-management-changes-corona-sdk-beta-8
        Note: [3/12/2011] It has been found that a small Lua memory leak can occur if the children of the group are not first removed before removing the group. When removing a group, first remove the display object listeners and then the display objects before removing the group.

        This is been fixed in daily build #318, and will be part of the next Corona SDK release.




      </Remarks>
    </object..removeSelf>
    <object..rotate>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Effectively adds deltaAngle to the rotation property.
        The rotation occurs around the object's reference point. The default reference point for most Display Objects is center.


      </Description>
      <Syntax>

        object:rotate( deltaAngle )





      </Syntax>
      <Example>

        -- another way to animate the stars in PolyLine sample app
        function stars:enterFrame( event )
                for i,v in ipairs( self ) do
                        v:rotate(v.dr)
                end
        end





      </Example>
      <Parameters>

        deltaAngle

        number: degrees to rotate. A positive number rotates the object clockwise and a negative number rotates the object counter-clockwise.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Use object.rotation to get the current rotation value of the object.
        Note: When a Display Object is converted into a physics object, rotating the Display Object will change the physical rotation but NOT affect the physics view of he object. This could result in unpredictable results when interacting with other physics bodies.




      </Remarks>
    </object..rotate>
    <object..scale>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Effectively multiplies xScale and yScale properties by sx and sy respectively. The scaling occurs around the object's reference point. The default reference point for most Display Objects is center.


      </Description>
      <Syntax>

        object:scale( sx, sy )





      </Syntax>
      <Example>

        -- Alternative animation for PolyLines sample
        function stars:enterFrame( event )
                for i,v in ipairs( self ) do
                        v:rotate(v.dr)
                        if v.stageWidth  1.5 * display.contentWidth then
                                v:scale(1.02, 1.02)
                        else
                                v:scale(0.1, 0.1)
                        end
                end
        end





      </Example>
      <Parameters>

        sx

        number: factor by which to change the scale in the x-direction
        sy

        number: factor by which to change the scale in the y-direction
        Value examples: 1.0 is 100%, 2.0 is 200%, 0.5 is 50%.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Note: When a Display Object is converted into a physics object, scaling the Display Object will change the physical size but NOT affect the physics view of he object. This could result in unpredictable results when interacting with other physics bodies.




      </Remarks>
    </object..scale>
    <object..setMask>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Associates a mask with a display object. To remove an object's mask, use object:setMask(nil). You can modify a display object's mask's x and y position, x-scale and y-scale factors, and rotation (see related properties below).
        Note: Starting with build 2011.505, bit masks can now be applied to text objects and display groups. Masks can be nested (masked groups of groups or other masked display objects within masked groups). Some platforms (e.g. Android) may have a mask nesting limit.


      </Description>
      <Syntax>

        object:setMask( mask )





      </Syntax>
      <Example>


        This sample code uses images from the Graphics/Flashlight sample in the Corona SDK. It applies a mask to the image and then scales the mask to twice its original size.

        -- Create and position image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
        image:translate( display.contentCenterX, display.contentCenterY )
         
        -- Create mask and apply to image
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
         
        -- Transform mask
        image.maskScaleX, image.maskScaleY = 2,2

        Here is an example of how to add a bit mask to a display group.

        local g = display.newGroup()
        -- Create and position image to be masked, and insert into group
        local image = display.newImageRect( g, "image.png", 768, 1024 )
        image:translate( display.contentCenterX, display.contentCenterY )
         
        local mask = graphics.newMask("circlemask.png")
        g:setMask(mask)
         
        -- Center the mask over the Display Group
        g:setReferencePoint( display.CenterReferencePoint )
        g.maskX = g.x
        g.maskY = g.y





      </Example>
      <Parameters>

        mask

        The mask object created with graphics.newMask(). Set to nil to remove the mask.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        There is currently a problem when applying bit masks to groups. Because a display group has the reference point at TopLeftReference (instead of CenterReference), the mask is also centered at TopLeft when it should be centered over a group as it is for vector objects. The workaround to the problem is to add the following code after creating and applying the mask to the group (g):
        g:setReferencePoint( display.CenterReferencePoint )
        g.maskX = g.x
        g.maskY = g.y




      </Remarks>
    </object..setMask>
    <object..setReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the reference point either to the center of the object (default) or to one of several convenient points along the bounding box of the object.
        By design, an object's reference point is statically positioned relative to the object's local origin. This means that if you explicitly set an object's reference point using setReferencePoint() and then later modify the height or width of the object, the reference point may no longer refer to the same point.
        This can cause unexpected results, especially when working with text objects: assigning a different string to the object's text property changes the object's width, but not its reference point, which changes the object's alignment. The workaround is to reset the object's reference point and x-position after assigning the new string. The following code illustrates this behavior and workaround. (These concepts also apply to other types of display objects, such as image and shapes.)


      </Description>
      <Syntax>

        object:setReferencePoint( referencePoint )





      </Syntax>
      <Example>

        -- A text object is created and is aligned left at point x=20
        local textObj = display.newText("A short string", 0,0, nil, 14);
        textObj:setReferencePoint(display.CenterLeftReferencePoint);
        textObj.x = 20;
         
        -- Later, the textObj.text property is assigned a new string value of different length,
        -- causing the object's width to change, but not its reference point.
        -- Consequently, the text is no longer aligned left at point x =20
        textObj.text = "This string has several more characters than before..."
         
        -- Work-around:
        -- Reset the text object's reference point and x position
        -- after you update its text property:
        textObj.text = "This string has several more characters than before..."
        textObj:setReferencePoint(display.CenterLeftReferencePoint);
        textObj.x = 20





      </Example>
      <Parameters>

        referencePoint

        number: A point along the bounding box of the object. Should be one of:

        display.CenterReferencePoint
        display.TopLeftReferencePoint
        display.TopCenterReferencePoint
        display.TopRightReferencePoint
        display.CenterRightReferencePoint
        display.BottomRightReferencePoint
        display.BottomCenterReferencePoint
        display.BottomLeftReferencePoint
        display.CenterLeftReferencePoint






      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Note: When a Display Object is converted into a physics object, the Physics engine assumes the reference point of the object is the center of the object. Calling object:setReferencePoint() may change the reference point from Corona's Display Object point of view but not for the Physics engine.




      </Remarks>
    </object..setReferencePoint>
    <object..toBack>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Moves the target object to the visual back of its parent group (object.parent).


      </Description>
      <Syntax>

        object:toBack()





      </Syntax>
      <Example>

        The following sample creates a group of display objects (playing cards). Clicking on any one of the cards sends it to the bottom of the parent group's visual stack.
        local cards = display.newGroup()    
         
        function bringToFront( event )
                if event.phase == "began" then
                   event.target:toBack()
                end                        
                return true
        end
         
        for i=1,5 do
         
                local cardGroup = display.newGroup()
         
                -- Card outline
                local cardRect = display.newRoundedRect(0, 0, 125, 175, 12)
                cardRect.strokeWidth = 2
                cardRect:setFillColor(255, 255, 255)    
                cardRect:setStrokeColor(0,0,0, 75)                                        
                cardGroup:insert(cardRect)
         
                -- Card values
                local cardValue = display.newText(cardGroup, i, cardRect.contentWidth - 25, 0, native.systemFontBold, 24)    
                cardValue:setTextColor(255, 0, 0)
                local cardValue2 = display.newText(cardGroup, i, 0, cardRect.contentHeight - 40 , native.systemFontBold, 24)    
                cardValue2:setTextColor(255, 0, 0)      
         
                cardGroup.x = (i * 25)      
               
                cards:insert(cardGroup)
               
                cardGroup:addEventListener("touch", bringToFront)        
         
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..toBack>
    <object..toFront>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Moves the target object to the visual front of its parent group (object.parent).


      </Description>
      <Syntax>

        object:toFront()





      </Syntax>
      <Example>

        The following sample creates a group of display objects (playing cards). Clicking on any one of the cards brings it to the top of the visual stack.
        local cards = display.newGroup()    
         
        function bringToFront( event )
                if event.phase == "began" then
                   event.target:toFront()
                end                        
                return true
        end
         
        for i=1,5 do
         
                local cardGroup = display.newGroup()
         
                -- Card outline
                local cardRect = display.newRoundedRect(0, 0, 125, 175, 12)
                cardRect.strokeWidth = 2
                cardRect:setFillColor(255, 255, 255)    
                cardRect:setStrokeColor(0,0,0, 75)                                        
                cardGroup:insert(cardRect)
         
                -- Card values
                local cardValue = display.newText(cardGroup, i, cardRect.contentWidth - 25, 0, native.systemFontBold, 24)    
                cardValue:setTextColor(255, 0, 0)
                local cardValue2 = display.newText(cardGroup, i, 0, cardRect.contentHeight - 40 , native.systemFontBold, 24)    
                cardValue2:setTextColor(255, 0, 0)      
         
                cardGroup.x = (i * 25)      
               
                cards:insert(cardGroup)
               
                cardGroup:addEventListener("touch", bringToFront)        
         
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..toFront>
    <object..translate>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Effectively adds deltaX and deltaY to the x and y properties respectively.


      </Description>
      <Syntax>

        object:translate( deltaX, deltaY )





      </Syntax>
      <Example>

        -- From FrameAnimation1 sample code
        local screenTop = display.screenOriginY
        local screenBottom = display.viewableContentHeight + display.screenOriginY
        local screenLeft = display.screenOriginX
        local screenRight = display.viewableContentWidth + display.screenOriginX
        local function animate(event)
                xpos = xpos + ( xspeed * xdirection );
                ypos = ypos + ( yspeed * ydirection );
         
                if ( xpos &gt; screenRight - radius or xpos  screenLeft + radius ) then
                        xdirection = xdirection * -1;
                end
                if ( ypos &gt; screenBottom - radius or ypos  screenTop + radius ) then
                        ydirection = ydirection * -1;
                end
         
                fruit:translate( xpos - fruit.x, ypos - fruit.y)
        end





      </Example>
      <Parameters>

        deltaX

        number: amount to add to the object's x property
        deltaY

        number: amount to add to the object's y property





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>





      </Remarks>
    </object..translate>
  </CommonMethods>
  <CommonProperties>
    <object.alpha>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </object.alpha>
    <object.contentBounds>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A table with properties xMin, xMax, yMin, yMax in screen coordinates.
        Equivalent to object.stageBounds, which is deprecated.


      </Description>
      <Syntax>

        object.contentBounds





      </Syntax>
      <Example>

        local rect = display.newRect(100, 100, 50, 50)
        rect:setFillColor(170, 170, 170)
         
        local bounds = rect.contentBounds
        print("xMin: ".. bounds.xMin) -- xMin: 100
        print("yMin: ".. bounds.yMin) -- yMin: 100
        print("xMax: ".. bounds.xMax) -- xMax: 150
        print("yMax: ".. bounds.yMax) -- yMax: 150





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </object.contentBounds>
    <object.contentHeight>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The height of the object in stage coordindates.
        This is similar to object.height except it's value is affected by Y-scaling and rotation.
        This is equivalent to object.stageHeight, which has been deprecated.


      </Description>
      <Syntax>

        object.contentHeight





      </Syntax>
      <Example>

        local rect = display.newRect(100, 100, 50, 50)
        rect:setFillColor(170, 170, 170)
         
        print("contentHeight: ".. rect.contentHeight) -- contentHeight: 50





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        number: Value of the object's height in stage coordinates.
        Note: This value may not be the same as object.height if the object has been scaled or rotated.





      </Returns>
      <Remarks>





      </Remarks>
    </object.contentHeight>
    <object.contentWidth>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Width of the object in screen coordinates.
        This is similar to object.width except it's value is affected by X-scaling and rotation.
        Equivalent to object.stageWidth, which has been deprecated.


      </Description>
      <Syntax>

        object.contentWidth





      </Syntax>
      <Example>

        local rect = display.newRect(100, 100, 50, 50)
        rect:setFillColor(170, 170, 170)
         
        print("contentWidth: ".. rect.contentWidth) -- contentWidth: 50





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        number: Value of the object's width in stage coordinates.
        Note: This value may not be the same as object.width if the object has been scaled or rotated.





      </Returns>
      <Remarks>





      </Remarks>
    </object.contentWidth>
    <object.isHitTestMasked>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Limits touch events to the masked portion of the object. This property can be read or set.
        By default this property is true, meaning touch events for the object only occur on the masked portion of the object. Setting this property to false generates touch events when a touch occurs on any portion of the object.
        Currently for a bitmap mask created by graphics.newMask(), the touch sensitive area corresponds to the image bounds, i.e. it is rectangular regardless of the image contents.


      </Description>
      <Syntax>

        local value = object.isHitTestMasked





      </Syntax>
      <Example>

        -- Create and position image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
        image:translate( display.contentCenterX, display.contentCenterY )
         
        -- Create mask and apply to image
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
         
        -- Touch events on the image will be masked to the mask bounds
        -- (always rectangular for an image, regardless of the image contents)
        image.isHitTestMasked = true
         
        -- Transform mask
        image.maskScaleX, image.maskScaleY = 2,2





      </Example>
      <Parameters>

        boolean

        true to only generate touch events for the masked portion of the object. false generates touch events for any portion of the object.





      </Parameters>
      <Returns>

        boolean

        Returns true of false (when reading property).





      </Returns>
      <Remarks>





      </Remarks>
    </object.isHitTestMasked>
    <object.isVisible>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </object.isVisible>
    <object.maskRotation>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieve or set the rotation of the display object's corresponding mask object, if one exists.


      </Description>
      <Syntax>

        object.maskRotation


      </Syntax>
      <Example>

        -- Image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
         
        -- Mask
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
        image.maskRotation = 180





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number: maskRotation value of object.





      </Returns>
      <Remarks>





      </Remarks>
    </object.maskRotation>
    <object.maskScaleX>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieve or set the x-scale factor for the display object's corresponding mask object, if any.


      </Description>
      <Syntax>

        value = object.maskScaleX





      </Syntax>
      <Example>

        -- Image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
         
        -- Mask
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
        image.maskScaleX = 0.5
        image.maskScaleY = 0.5





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number: maskScaleX of object.





      </Returns>
      <Remarks>





      </Remarks>
    </object.maskScaleX>
    <object.maskScaleY>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieves or sets the y-scale factor for the display object's corresponding mask object, if any.


      </Description>
      <Syntax>

        value = object.maskScaleY





      </Syntax>
      <Example>

        -- Image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
         
        -- Mask
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
        image.maskScaleX = 0.5
        image.maskScaleY = 0.5





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number: maskScaleY of object.





      </Returns>
      <Remarks>





      </Remarks>
    </object.maskScaleY>
    <object.maskX>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieve or set the x-position of the mask applied to the display object using object:setMask().


      </Description>
      <Syntax>

        value = object.maskX





      </Syntax>
      <Example>

        This sample moves the mask applied to the corresponding image to the position where the user moves their finger on the display.
        -- Image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
        image:translate( halfW, halfH )
         
        -- Mask
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
         
        function onTouch( event )
                local t = event.target
                local phase = event.phase
                if "moved" == phase then
                        t.maskX = event.x
                        t.maskY = event.y
                 end
        end
         
        image:addEventListener( "touch", onTouch )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number: maskX of object.





      </Returns>
      <Remarks>





      </Remarks>
    </object.maskX>
    <object.maskY>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieve or set the y-position of the mask applied to the display object using object:setMask().


      </Description>
      <Syntax>

        value = object.maskY





      </Syntax>
      <Example>

        This sample moves the mask applied to the corresponding image to the position where the user moves their finger on the display.
        -- Image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
        image:translate( halfW, halfH )
         
        -- Mask
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
         
        function onTouch( event )
                local t = event.target
                local phase = event.phase
                if "moved" == phase then
                        t.maskX = event.x
                        t.maskY = event.y
                 end
        end
         
        image:addEventListener( "touch", onTouch )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number: maskY of object.





      </Returns>
      <Remarks>





      </Remarks>
    </object.maskY>
  </CommonProperties>
  <ContentSizeProperties>
    <display.contentCenterX>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Equivalent to display.contentWidth/2.


      </Description>
      <Syntax>

        display.contentCenterX





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </display.contentCenterX>
    <display.contentCenterY>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Equivalent to display.contentHeight/2


      </Description>
      <Syntax>

        display.contentCenterY





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </display.contentCenterY>
    <display.contentScaleX>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The ratio between content pixel and screen pixel width.
        This value will always be 1 unless your project's config.lua file specifies your content's height and width (see example below). Different scale modes (letterbox, zoomEven, and so forth) will result in different scale factors.


      </Description>
      <Syntax>

        scalex = display.contentScaleX





      </Syntax>
      <Example>

        -- main.lua
        scalex = display.contentScaleX
        scaley = display.contentScaleY
        -- display scale values
        print("scalex", "scaley", scalex, scaley)
        -- config.lua
        application =
                {
                        content =
                        {
                                width = 320,
                                height = 480,
                                scale = "letterbox"
                        },
         }                      
        Sample output on various devices:
        -- iPhone
        scale_x scale_y 1       1
         
        -- iPhone 4
        scale_x scale_y 0.5     0.5
         
        -- Droid
        scale_x scale_y 0.66666668653488        0.66666668653488
         
        -- iPad
        scale_x scale_y 0.46875 0.46875





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        The ratio between content pixel and screen pixel width.





      </Returns>
      <Remarks>





      </Remarks>
    </display.contentScaleX>
    <display.contentScaleY>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The ratio between content pixel and screen pixel height.
        This value will always be 1 unless your project's config.lua file specifies your content's height and width (see example below). Different scale modes (letterbox, zoomEven, and so forth) will result in different scale factors.


      </Description>
      <Syntax>

        display.contentScaleY





      </Syntax>
      <Example>

        -- main.lua
        scalex = display.contentScaleX
        scaley = display.contentScaleY
        -- display scale values
        print("scalex", "scaley", scalex, scaley)
        -- config.lua
        application =
                {
                        content =
                        {
                                width = 320,
                                height = 480,
                                scale = "letterbox"
                        },
         }                      
        Sample output on various devices:
        -- iPhone
        scale_x scale_y 1       1
         
        -- iPhone 4
        scale_x scale_y 0.5     0.5
         
        -- Droid
        scale_x scale_y 0.66666668653488        0.66666668653488
         
        -- iPad
        scale_x scale_y 0.46875 0.46875





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        The ratio between content pixel and screen pixel height.





      </Returns>
      <Remarks>





      </Remarks>
    </display.contentScaleY>
    <display.statusBarHeight>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property representing the height of the status bar in pixels on iOS devices.
        Android 2.x devices are supported starting with build 635. Android 3.x devices do not support Status Bar and return a height of 0.


      </Description>
      <Syntax>

        value = display.statusBarHeight





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value: The height of the status bar in pixels.





      </Returns>
      <Remarks>

        Android devices are supported starting with build 635.




      </Remarks>
    </display.statusBarHeight>
    <display.viewableContentHeight>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that contains the height of the viewable screen area in pixels, within the coordinate system of the original content. This is useful since depending on which dynamic scaling mode is used, and the aspect ratio of the device used to view the content, some of the original content may be scaled in such a way that portions are off-screen.


      </Description>
      <Syntax>

        display.viewableContentHeight





      </Syntax>
      <Example>

        print( display.viewableContentHeight )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        The height of the viewable screen area in pixels.





      </Returns>
      <Remarks>





      </Remarks>
    </display.viewableContentHeight>
    <display.viewableContentWidth>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that contains the width of the viewable screen area in pixels, within the coordinate system of the original content. This is useful since depending on which dynamic scaling mode is used, and the aspect ratio of the device used to view the content, some of the original content may be scaled in such a way that portions are off-screen.


      </Description>
      <Syntax>

        display.viewableContentWidth





      </Syntax>
      <Example>

        print( display.viewableContentWidth )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        The width of the viewable screen area in pixels.





      </Returns>
      <Remarks>





      </Remarks>
    </display.viewableContentWidth>
  </ContentSizeProperties>
  <FactoryFunctions>

    <display.CenterReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.CenterReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.CenterReferencePoint>

    <display.TopLeftReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.TopLeftReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.TopLeftReferencePoint>

    <display.TopCenterReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.TopCenterReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.TopCenterReferencePoint>

    <display.TopRightReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.TopRightReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.TopRightReferencePoint>

    <display.CenterRightReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.CenterRightReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.CenterRightReferencePoint>

    <display.BottomRightReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.BottomRightReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.BottomRightReferencePoint>

    <display.BottomCenterReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.BottomCenterReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.BottomCenterReferencePoint>

    <display.BottomLeftReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.BottomLeftReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.BottomLeftReferencePoint>

    <display.CenterLeftReferencePoint>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>

        display.CenterLeftReferencePoint

      </Syntax>
      <Example></Example>
      <Parameters></Parameters>
      <Returns></Returns>
      <Remarks></Remarks>
    </display.CenterLeftReferencePoint>



    <display.loadRemoteImage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This  a convenience method, similar to network.download(), which returns a display object containing the image, as well as saving the image to file.


      </Description>
      <Syntax>

        object = display.loadRemoteImage( url, method, listener [, params], destFilename [, baseDir] [, x, y] )





      </Syntax>
      <Example>



        The following example downloads a remote image to a local file copy, and then displays it on the screen at (50, 50) after a short alpha transition:
        local function networkListener( event )
                if ( event.isError ) then
                        print ( "Network error - download failed" )
                else
                        event.target.alpha = 0
                        transition.to( event.target, { alpha = 1.0 } )
                end
               
                print ( "RESPONSE: " .. event.response )
        end
         
        display.loadRemoteImage( "http://developer.anscamobile.com/demo/hello.png", "GET", networkListener, "helloCopy.png", system.TemporaryDirectory, 50, 50 )





      </Example>
      <Parameters>

        url

        String: The HTTP request URL.
        method

        String: The HTTP method; valid values are "GET" (the default) or "POST".
        listener

        Function: The listener function invoked when the HTTP operation has completed.  It is passed an event object that contains the following properties:

        event.response

        A string containing the destination filename. This is useful if you're writing a general event handler for a variety of file downloads.
        event.target

        The new display object created after the image is downloaded.
        event.isError

        A boolean value: true in the case of a network error, false otherwise.

        params

        Table: An optional table that specifies custom HTTP headers or body to include in the request. To specify custom headers, attach a headers table that specifies header values with string keys. To specify a custom body message, attach a body property to this table whose string value is the HTTP body.

        params.headers
        A table specifying header values with string keys.
        params.body
        A string containing the HTTP body.

        destFilename

        String: The name of the file to which the HTTP response will be saved.
        baseDir

        String: The folder path to which the file will be saved.
        x

        The x position of the newly created display object; default is 0.
        y

        The y position of the newly created display object; default is 0.





      </Parameters>
      <Returns>

        Nothing is returned from calling this method. The listener callback will contain the Display Object value (event.target) if the download was successful.





      </Returns>
      <Remarks>

        Image Guidelines

        Images should not contain an embedded ICC profile. Use "Save for Web" when exporting images to be used on the device.
        To avoid images from using too much texture memory, make sure the image is between 72 and 170 DPI.
        Be aware of the gamma and color differences between your development system (Mac and Windows machines) and the device. For best results color calibrate the display used for creating the images.




      </Remarks>
    </display.loadRemoteImage>
    <display.newCircle>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a circle with radius radius centered at (xCenter, yCenter). The local origin is at the center of the circle. The reference point is initialized to this local origin.


      </Description>
      <Syntax>

        display.newCircle( [parentGroup,] xCenter, yCenter, radius )





      </Syntax>
      <Example>


        display.setStatusBar( display.HiddenStatusBar )
         
        local myCircle = display.newCircle( 100, 100, 30 )
        myCircle:setFillColor(128,128,128)
        You also set a border around the circle, along with it's color.

        myCircle.strokeWidth = 5
        myCircle:setStrokeColor(128,0,0)  -- red





      </Example>
      <Parameters>

        parentGroup

        object: display group in which to insert the rectangle. (optional)
        xCenter

        number: x-coordinate for the center of the circle
        yCenter

        number: y-coordinate for the center of the circle
        radius

        number: radius for the circle from x, y. The radius must be greater than 0.





      </Parameters>
      <Returns>

        Display object





      </Returns>
      <Remarks>

        By default, there is no stroke color. and the fill color is white (rgb 255, 255, 255).




      </Remarks>
    </display.newCircle>
    <display.newEmbossedText>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates text with an embossed (inset) effect.


      </Description>
      <Syntax>

        display.newEmbossedText( [parentGroup,] string, left, top,[width, height,] font, size, [color] )





      </Syntax>
      <Example>

        local myText = display.newEmbossedText("Hello World!", 0, 0, native.systemFont, 16, { 255, 255, 255 } )
        Update the text string and change color:

        local myText = display.newEmbossedText("", 0, 0, native.systemFont, 12, { 255, 255, 255, 255 })
        myText:setTextColor( 0 )
         
        myText:setText( "Hello World!" )
         
        print( myText.text ) -- terminal output: Hello World!





      </Example>
      <Parameters>

        parentGroup

        object: display group in which to insert the text.
        string

        string: specify text to display.
        left, top

        number: coordinates for the object's top left corner
        width, height

        number: optional arguments to enable multi-line text. Text will be wrapped at width (pixels) and be cropped at height (pixels).
        font

        string: Names the font. Obtain an array of available fonts via native.getFontNames() . Alternatively, you can also pass the following constants instead of a string:
        native.systemFont

        native.systemFontBold
        size

        number: size of the text in pixels
        color

        table: optional table that holds values which correspond to red, green, blue, alpha channels for the text color. ex. { r, g, b, a }. default is white: { 255, 255, 255, 255 }
        Methods
        setTextColor( r, [g, b, a] )

        Used to change the color of your text.
        setText( string )

        Required to change the actual text string. Unlike normal text objects, since display.newEmbossedText() returns a display group, you cannot change the text by simply modifying the .text property.





      </Parameters>
      <Returns>

        Display Group with additional methods for setting text (text:setText()) and changing the text color (text:setTextColor()).





      </Returns>
      <Remarks>

        Note: There is currently a bug on all platforms that will cause text to disappear when rotated when "antialias" is set to "true" in config.lua. This does not affect the text if the rotation is 0, 90, or 180 degrees. If you need rotated text, the only solution is to set antialias to false.




      </Remarks>
    </display.newEmbossedText>
    <display.newGroup>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </display.newGroup>
    <display.newImage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Displays an image on the screen from a file.
        Note: display.newImageRect should be used to load images when Dynamic Scaling is enabled, instead of display.newImage.
        Beginning with build 2011.612, tinting can be added using object:setFillColor.


      </Description>
      <Syntax>

        object = display.newImage(filename [,baseDirectory] [,left,top])

      </Syntax>
      <Example>

        myImage = display.newImage( "image.png" )





      </Example>
      <Parameters>

        filename

        string: Filename of the image.
        baseDirectory

        path: Path to load the image data from filename. Default is  system.ResourceDirectory. See system.pathForFile for valid values of baseDirectory). Note: This is type "userdata" and not a string value.
        left

        number: Optionally specify that the image's left corner.
        top

        number:Optionally specify that the image's top corner.
        parentGroup

        object: Insert the image to a group.
        isFullResolution

        boolean: To override autoscaling and show the image at its full-resolution, use the optional isFullResolution parameter. By default, it is false, but if you specify true, then the new image is loaded at its full resolution (maximum of 2048 x 2048). See Image Auto-scaling.





      </Parameters>
      <Returns>

        display object





      </Returns>
      <Remarks>

        All loaded images are cached. To save texture memory the image in the cache memory is used when it detects an image with the same file name is displayed. This means that loading the same image multiple times doesn't increase the amount of texture memory used on the device.
        A negative side-effect to the image caching is the comparison is based on the file name and not the file content. This means if an image file is displayed and then deleted from the directory, any file loaded after that with the same file name will still display the previous cached image. Use a different file name to avoid this problem.
        Image Guidelines

        Images should not contain an embedded ICC profile. Use "Save for Web" when exporting images to be used on the device.
        To avoid images from using too much texture memory, make sure the image is between 72 and 170 DPI.
        Be aware of the gamma and color differences between your development system (Mac and Windows machines) and the device. For best results color calibrate the display used for creating the images.
        Grayscale images are not supported; images must currently be RGB.
        Indexed PNG images are not supported.
        The maximum full-resolution image supported is 2048 x 2048. This value may be less on older devices (e.g., iPhone 3G).
        You should NOT use progressive JPGs since they will take much longer to load than non-progressive JPGs.





      </Remarks>
    </display.newImage>
    <display.newImageRect>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </display.newImageRect>
    <display.newLine>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </display.newLine>
    <display.newRect>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </display.newRect>
    <display.newRetinaText>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a retina-display compatible (double-pixel display) text object with its top-left corner at (left, top). The local origin is at the center of the text; the reference point is initialized to this local origin. By default, the text color is white (255, 255, 255). See Text for more.
        Beginning with build 2011.612, gradients can be added using object:setTextColor.
        Build 2011.640, added multiple lines support to display.newText and display.newRetinaText. This is enabled by specifying the width and height when the object is created.
        Minor limitations:
        You cannot change the text size by adjusting the .size property as you can with display.newText().
        Because retina text may be scaled, you cannot use object.height to return the height of the retina text object. Use object.contentHeight instead.
        To remain consistent with the behavior of display.newText(), whenever you set a different reference point for a text object created using display.newRetinaText(), be sure to also reposition it by setting the x/y properties (even if they are the same as before).


      </Description>
      <Syntax>

        display.newRetinaText( [parentGroup,] string, left, top,[width, height,] font, size )





      </Syntax>
      <Example>

        local myText = display.newRetinaText("Hello World!", 0, 0, native.systemFont, 16)
        myText:setTextColor(255)
        Update the text string and size:

        local myText = display.newRetinaText("", 0, 0, native.systemFont, 12)
        myText:setTextColor(255)
         
        -- Change the text
        myText.text = "Hello World!"
         
        print( myText.text ) -- terminal output: "Hello World!"





      </Example>
      <Parameters>

        parentGroup

        object: display group in which to insert the text.
        string

        string: specify text to display.
        left, top

        number: coordinates for the object's top left corner
        width, height

        number: optional arguments to enable multi-line text. Text will be wrapped at width and be cropped at height. Set height to 0 and the height will change according to amount of text â€” except it will *not* exceed the maximum texture height for the device
        font

        string: Names the font. Obtain an array of available fonts via native.getFontNames() . Alternatively, you can also pass the following constants instead of a string:
        native.systemFont

        native.systemFontBold
        size

        number: size of the text in pixels
        Properties and Methods
         

        object.text

        string. Read-only property that holds text that the object is currently displaying.
         

        object.text = "newText"

        This method is used to change the text that is currently displayed by the object. newText is a string representing the text you want the object to display.





      </Parameters>
      <Returns>

        Retina text display group object.





      </Returns>
      <Remarks>

        Note: There is currently a bug on all platforms that will cause text to disappear when rotated when "antialias" is set to "true" in config.lua. This does not affect the text if the rotation is 0, 90, or 180 degrees. If you need rotated text, the only solution is to set antialias to false.




      </Remarks>
    </display.newRetinaText>
    <display.newRoundedRect>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </display.newRoundedRect>
    <display.newText>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
      </Description>
      <Syntax>
      </Syntax>
      <Example>
      </Example>
      <Parameters>
      </Parameters>
      <Returns>
      </Returns>
      <Remarks>
      </Remarks>
    </display.newText>






  </FactoryFunctions>
  <GroupDisplayObjects>
    <group..insert>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Inserts an object into a group.


      </Description>
      <Syntax>

        group:insert( [index,] child, [, resetTransform] )





      </Syntax>
      <Example>

        local txt=display.newText('Hello',0,0)
        local g1=display.newGroup()
        local g2=display.newGroup()
                     
        -- Insert text object into g1
        g1:insert(txt)              
        -- Insert same text object into g2
        g2:insert(txt)
         
        print("g1[1]: " .. tostring(g1[1])) -- prints nil
        print("g2[1]: " .. tostring(g2[1])) -- prints textObject
        print( "number of children in g1 and g2: " .. g1.numChildren, g2.numChildren )          





      </Example>
      <Parameters>

        index

        number: Inserts child at index into group, shifting up other elements as necessary. The default value index is n+1 where n is the number of children in the group.
        An easy way to move an object above all its siblings (top) is to re-insert it: object.parent:insert( object ).
        If a group has 3 display objects:

        group[1] is at the bottom of the group.

        group[2] is in the middle of the group.

        group[3] is at the top of the group.
        Objects at the higher index numbers will be displayed on top of objects with lower index numbers (if the objects overlap).
        child

        object: An object to insert into the group.
        resetTransform

        boolean: Determines what happens to child’s transform. When false, child’s local position, rotation, and scale properties are preserved, except the local origin is now relative to the new parent group, not its former parent; when true, child’s transform is reset (i.e. the x, y, rotation, xScale, and yScale properties of child are reset to 0, 0, 0, 1, and 1, respectively). The default value for resetTransform is false.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Inserting display objects into a group, removes the object from it current group (objects cannot be in multiple groups). All display objects are part of "current stage" when first created. (At this time Corona only has one stage, which is the entire screen area. You could think of this as the "main stage" group.)




      </Remarks>
    </group..insert>
    <group..remove>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Remove an object from a group by either an index number or a reference to the object.
        Note: If an object is being removed, it is recommended to use the object.removeSelf API instead.


      </Description>
      <Syntax>

        group:remove( indexOrChild )





      </Syntax>
      <Example>

        display.getCurrentStage():remove( 2 )  -- removes the second object from the group





      </Example>
      <Parameters>

        indexOrChild

        number or object: Removes from group the display object specified, shifting down other elements as needed. The argument is either the index position of the child within group or the child display object itself.





      </Parameters>
      <Returns>

        object: Removed display object





      </Returns>
      <Remarks>

        When an object is removed, the rendering-related resources of the removed object are deleted immediately. What remains of object is simply a plain Lua table with all non-display object properties (the metatable is set to nil and all properties relating to display object are removed). Thus, if there are still references to object in Lua, they will simply be references to a normal Lua table.
        Note: [3/12/2011] It has been found that a small Lua memory leak can occur if the children of the group are not first removed before removing the group. When removing a group, first remove the display object listeners and then the display objects before removing the group.

        This is been fixed in daily build #318, and will be part of the next Corona SDK release.




      </Remarks>
    </group..remove>
  </GroupDisplayObjects>
  <OtherDisplayFunctions>
    <display.captureScreen>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Captures the contents of the screen and returns it as an image object positioned so that the top-left of the screen is at the origin.
        Note1: Calling this method displays the captured image on the screen on top of all other display objects. Use object:removeSelf() to remove this object from the screen.
        Note2: Screen capture only works for openGL content and not for any of the native display objects.


      </Description>
      <Syntax>

        object = display.captureScreen( saveToAlbum )





      </Syntax>
      <Example>


        display.setStatusBar( display.HiddenStatusBar )
         
        -- Fill the screen with a green rectangle
        local rect = display.newRect(0, 0, display.contentWidth, display.contentHeight)
        rect:setFillColor(0, 255, 0)
         
        -- Draw a circle on the screen
        local circle = display.newCircle(155, 100, 36)
        circle:setFillColor(255, 0, 0)
         
        -- Capture the screen
        local screenCap = display.captureScreen( true )
         
        -- Remove the objects from the screen
        rect:removeSelf()
        circle:removeSelf()
         
        -- Scale the screen capture, now on the screen, to half it's size
        screenCap:scale(.5,.5)
         
        -- Alert the user to look in the library (device)
        -- or on the desktop (simulator) for the screen capture
        local alert = native.showAlert( "Success", "Screen Capture Saved to Library", { "OK" } )





      </Example>
      <Parameters>

        saveToAlbum

        boolean: If true, then it adds the image to your deviceâ€™s Photo album (jpeg file); on the simulator, it saves to the desktop (png file). (For Android devices, you must set the permission level as shown in the remarks section below.)





      </Parameters>
      <Returns>

        image object





      </Returns>
      <Remarks>

        Higher resolution image saved to jpeg file in build #299.
        Note: There is a problem with screen captures when the device orientation is different from the initial orientation. There is also a problem capturing the entire screen on iPad and iPhone4 devices when Dynamic Scaling (in config.lua) is enabled. [case #928]
        If the saveToAlbum parameter is true, you must set the permission level in the build.settings file for Android devices.

        1
        2
        3
        4
        5
        6
        7
        settings =
        {
           androidPermissions =
           {
               "android.permission.WRITE_EXTERNAL_STORAGE"
           },
        }
        Note: Doing a screen capture in landscape mode incorrectly captures the screen as a portrait. [case #928]
        Windows build #518

        - Saves screen capture image to Window's "My Pictures\Corona Simulator" directory if display.captureScreen(true) is called.

        - Saves screen shots in PNG format.

        - Automatically names files names to "Picture #.png", where # is set to a unique number in the directory.

        - It never overwrites an existing image file.

        - Saves up to 10,000 files. That is, it'll never go beyond "Picture 10000.png".




      </Remarks>
    </display.captureScreen>
    <display.remove>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Removes a group or object if not nil.
        This was added as a convenience method of calling object:removeSelf().
        The code would be equivalent to the following:

        if object ~= nil then
            object:removeSelf()
        end


      </Description>
      <Syntax>

        display.remove( object )





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        object

        The display object (vector, image or group) to be removed.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        It's always a good practice to test a Display Object for nil before removing. This method does the testing and removal in one step.
        This API is available starting with daily build #305.




      </Remarks>
    </display.remove>
    <display.save>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Renders the display object referenced by displayObject into a JPEG image and saves it in filename. The display object must currently be in the display hierarchy; otherwise no image is saved. If the display object is a group object, then all children are rendered. The object to be saved must be on the screen and fully within the screen boundary.
        Note: When Dynamic Scaling is enabled, display.save saves the image in the device's native resolution. For example, if this method is used to save a 100 x 200 pixel Display Object, it will be saved as a 100 x 200 image on iPhone3 but it will be a 200 x 400 image on iPhone4. (This assumes that the config.lua file specifies the content width/height as 320x480).
        display.newImageRect should be used to load images when Dynamic Scaling is enabled, instead of display.newImage.


      </Description>
      <Syntax>

        display.save( displayObject, filename [, baseDirectory] )





      </Syntax>
      <Example>

        local myObject1 = display.newRect( 50, 50, 100, 150 ) -- Create a rectangle object
        local myObject2 = display.newCircle( 100, 300, 50 )   -- Create a circle object
         
        local g = display.newGroup()
         
        g:insert(myObject1)
        g:insert(myObject2)
         
        local baseDir = system.DocumentsDirectory
        display.save( g, "entireGroup.jpg", baseDir )





      </Example>
      <Parameters>

        displayObject

        object: Name of display object to save.
        filename

        string: Name of the file to save the JPEG.
        baseDirectory

        system path: Optional. Can be either system.DocumentsDirectory (the default) or system.TemporaryDirectory.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Higher resolution image saved to jpeg file in build #299.
        Note1: There is a problem with object captures when the device orientation is different from the initial orientation. There is also a problem capturing the entire object on iPad and iPhone4 devices when Dynamic Scaling (in config.lua) is enabled. [case #928]
        Note2: display.save uses the openGL buffer viewport for saving the specified Display Object. When using the Simulator, the size of the saved image will be smaller than expected if the simulator "skin" is not displayed full size. This generally occurs when the simulator skin is displayed on a smaller monitor (e.g., 13") or when Zoomed Out. When the skin is displayed full size, the saved image will match that of the simulated device.




      </Remarks>
    </display.save>
    <display.setDefault>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Set default colors for display objects. Colors default to white if not set.


      </Description>
      <Syntax>

        display.setDefault( key, r, g, b, alpha )





      </Syntax>
      <Example>

        -- set default fill color for vector objects to red
        display.setDefault( "fillColor", 255, 0, 0 )





      </Example>
      <Parameters>

        key

        String: Specifies which default color value to set: "fillColor", "strokeColor", "textColor", "lineColor", "background".

        "background" corresponds to the default color for that the screen is cleared with. The default is initially black. (Available to subscribers starting in daily build 2011.505)
        "fillColor" corresponds to the default color for vector objects (e.g. display.newRect). The default is initially white.
        "strokeColor" corresponds to the default color for vector objects (e.g. display.newRect). The default is initially white.
        "lineColor" corresponds to the default color for line objects (e.g. display.newLine). The default is initially white.
        "textColor" corresponds to the default color for text objects (e.g. display.newText). The default is initially white.

        gray, r, g, b, alpha

        Color values between 0 and 255.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </display.setDefault>
    <display.setStatusBar>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Hides or changes the appearance of the status bar on iOS devices (iPad, iPhone and iPod Touch).
        Starting with daily build 635, Android 2.x devices are now supported.
        Note: Android 3.x devices are not supported.


      </Description>
      <Syntax>

        display.setStatusBar( mode )





      </Syntax>
      <Example>

        display.setStatusBar( display.HiddenStatusBar )  -- hide the status bar





      </Example>
      <Parameters>

        mode

        display property: The argument should be one of:

        display.HiddenStatusBar
        display.DefaultStatusBar
        display.TranslucentStatusBar
        display.DarkStatusBar






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Android 2.x devices are supported starting with build 635. Android 3.x devices do not support Status Bar.
        On iOS devices, there is a parameter in the plist section that also controls whether the status bar is hidden or not. This API overrides the plist setting after the app loads. While the app is loading (when the splash screen is visible), the plist setting will control whether the status bar is visible or not. If your app turns off the status bar, setting the plist parameter "true", will keep it off while the splash screen is visible.

        UIStatusBarHidden = true,
        Sample Code

        /Sample Code/Platform Specific/StatusBar-iphone




      </Remarks>
    </display.setStatusBar>
  </OtherDisplayFunctions>
  <StageDisplayObjects>
    <display.getCurrentStage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a reference to the current stage object, which is the root group for all display objects and groups. Currently, Corona has a single stage instance, so this function always returns a reference to the same object.


      </Description>
      <Syntax>

        value = display.getCurrentStage( )





      </Syntax>
      <Example>

        local count = display.getCurrentStage().numChildren
        print( "Number of objects on the screen = " .. count )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        stage object





      </Returns>
      <Remarks>

        The "stage" can be considered a "group" that includes all of the objects on the visible screen.




      </Remarks>
    </display.getCurrentStage>
    <stage..setFocus>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets displayObject as the target for all future hit events. Pass nil  to restore default behavior for hit event dispatches. This is typically used to implement buttons that change appearance when a user initially presses them.
        When calling this method when multitouch is enabled (system.active) with the optional parameter (touchID) means that the specified touch has focus on that object, but other touches do not. Using this API, it is possible to create an object that will "own" the first touch it gets, for the lifetime of that touch, and for multiple objects to obtain their own focused touches at the same time. See the "Interface/DragMeMultitouch" sample code for a demonstration of this behavior.
        With multitouch enabled, focus will be on a per-object basis. To turn off focus, you must specify the object and pass nil for the touchID.


      </Description>
      <Syntax>

        stage:setFocus(displayObject [,touchID])





      </Syntax>
      <Example>

        This example creates a button (rectangle) whose alpha/transparency is reduced when the user touches the button, and returned to its initial alpha when the user ends the touch operation, even if their finger is outside the button's bounds.
        local button = display.newRect( 50, 50, 100, 50 )
         
        function doTouch( event )
         
            if event.phase == "began" then      
                print("began phase")
                event.target.alpha = 0.5
                display.getCurrentStage():setFocus(event.target)
            elseif event.phase == "ended" or event.phase == "cancelled" then
                event.target.alpha = 1
                print("end phase")
                display.getCurrentStage():setFocus(nil)
            end
           
        end
         
        button:addEventListener("touch", doTouch)





      </Example>
      <Parameters>

        displayObject

        object: Name of an object.
        touchID

        Userdata: The touch ID passed to the touch event for the touched object (when Multitouch is enabled).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: When multitouch is not enabled (the default state), stage:setFocus() works as follows:
        stage:setFocus( obj, nil ) behaves like stage:setFocus( nil )
        stage:setFocus( obj, touchID ) behaves like stage:setFocus( obj )
        As a result, library code that supports multitouch (e.g.,  ui.lua) will work as expected in both multitouch and non-multitouch modes.




      </Remarks>
    </stage..setFocus>
  </StageDisplayObjects>
  <TextDisplayObjects>
    <object.size>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieves or sets the size of the text in a text object.


      </Description>
      <Syntax>

        value = object.size

      </Syntax>
      <Example>

        local myText = display.newText("", 0, 0, native.systemFont, 12)
        myText:setTextColor(255, 255, 255)
         
        myText.text = "Hello World!"
        myText.size = 16





      </Example>
      <Parameters>

        number: set the size of the text.





      </Parameters>
      <Returns>

        number: returns the size of the text.





      </Returns>
      <Remarks>





      </Remarks>
    </object.size>
    <object.text>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieves or sets the text string of a text object.


      </Description>
      <Syntax>

        string = object.text

      </Syntax>
      <Example>

        local myText = display.newText("", 0, 0, native.systemFont, 12)
        myText:setTextColor(255, 255, 255)
         
        myText.text = "Hello World!"
        myText.size = 16





      </Example>
      <Parameters>

        string: new text string.





      </Parameters>
      <Returns>

        string: text string of object.





      </Returns>
      <Remarks>





      </Remarks>
    </object.text>
    <object..setTextColor>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the text color of a text object.
        Starting with build 2011.612, gradients can be added to text objects.


      </Description>
      <Syntax>


        object:setTextColor( red, green, blue, alpha )

      </Syntax>
      <Example>

        local myText = display.newText("", 0, 0, native.systemFont, 12)
        myText:setTextColor(255, 255, 255)
         
        myText.text = "Hello World!"
        myText.size = 16
        Gradient Example:
        local g = graphics.newGradient(
          { 255, 255, 255 },
          { 200, 200, 200 },
          "down" )
         
        -- sets gradient 'g' on text
        local text = display.newText("Hello World!", 0, 0, native.systemFont, 16)
        text:setTextColor( g )





      </Example>
      <Parameters>

        r

        number: Red channel, between 0 and 255.
        g

        number: Green channel, between 0 and 255.
        b

        number: Blue channel, between 0 and 255.
        a

        number:  Alpha channel, between 0 and 255. Optional value and is 255 (opaque) by default.
        gray

        number:  Gray is optional and between 0 and 255 (used when RGB or gradient is not used).
        gradient

        object: A gradient object created using graphics.newGradient().





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Gradients is only available starting with daily build 2011.612.




      </Remarks>
    </object..setTextColor>
  </TextDisplayObjects>
  <VectorDisplayObjects>
    <object.strokeWidth>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the stroke width in pixels of vector objects (display.newRect, display.newRoundedRect, and display.newCircle).
        Note that stroke widths are broken up to inner and outer parts. The stroke is centered on the boundaries of the object, but when the stroke width is odd, Corona does an integer divide by 2 (e.g. 3 / 2 = 1; 1 / 2 = 0) and set the inner width to that; the remainder is the outer width. This avoids blurring around the edges of the stroke. For example, a stroke width of 3 results in an inner width of 1 and an outer width of 2.
        One specific consequence is that if a rectangle fills the screen, a stroke width of 1 will be drawn entirely offscreen. Also, adding a stroke increases the width and height of the object by twice the amount of the outer stroke.


      </Description>
      <Syntax>

        object.strokeWidth





      </Syntax>
      <Example>


        display.setStatusBar( display.HiddenStatusBar )
         
        local rect = display.newRect(135, 100, 50, 50)
        rect:setFillColor(255, 255, 255)
        rect:setStrokeColor(140, 140, 140)
        rect.strokeWidth = 5





      </Example>
      <Parameters>

        number: stroke width.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        The stroke width of an object is 0 if not set.




      </Remarks>
    </object.strokeWidth>
    <object..append>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Append one or more segments to an existing display.newLine object.


      </Description>
      <Syntax>

        object:append( x,y [,...]





      </Syntax>
      <Example>

        local star = display.newLine( 0,-110, 27,-35 )
        star:append( 105,-35, 43,16, 65,90, 0,45, -65,90, -43,15, -105,-35, -27,-35, 0,-110 )
        star:setColor( 255, 102, 102, 255 )
        star.width = 3





      </Example>
      <Parameters>

        One or more x,y pairs specifying a new point to extent the existing line.





      </Parameters>
      <Returns>

        nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..append>
    <object..setColor>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the color for a display.newLine object.


      </Description>
      <Syntax>

        object:setColor( r, g, b, [a] )





      </Syntax>
      <Example>

        local star = display.newLine( 0,-110, 27,-35 )
        star:append( 105,-35, 43,16, 65,90, 0,45, -65,90, -43,15, -105,-35, -27,-35, 0,-110 )
        star:setColor( 255, 102, 102, 255 )
        star.width = 3





      </Example>
      <Parameters>

        r

        number: Red channel, between 0 and 255.
        g

        number: Green channel, between 0 and 255.
        b

        number: Blue channel, between 0 and 255.
        a

        number: Alpha is optional and is 255 (opaque) by default.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..setColor>
    <object..setFillColor>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the fill color of vector objects (display.newRect, display.newRoundRect, and display.newCircle).
        Starting with build 2011.612, gradients can be added to display.newRect objects.
        Starting with build 2011.612, tinting can be added to display.newImage and display.newImageRect objects, but not if they have a bitmap mask applied to them (known limitation at the moment).


      </Description>
      <Syntax>

        image:setFillColor( red, green, blue, alpha  )


      </Syntax>
      <Example>

        Vector object example:

        -- Draw some colored balls
        local ball = {}
        local stroke = 3
        local ballRadius = 20
        local n = 0
        local rows = 5
        local h = 2*math.sqrt(2/3)
        local X0, Y0 = display.contentWidth/2 - rows * ballRadius,
                        display.contentHeight/2 - rows * ballRadius
        local ballColors = {
            {0, 0, 0},     {128, 0, 0},     {255, 0, 0},    {255, 0, 255},
            {0,128, 128},    {0, 128, 0},    {0, 255, 0},    {0, 255, 255},
            {0, 0, 128},    {128, 0, 128},    {0, 0, 255},    {192, 192, 192},
            {128, 128, 128},     {192, 128, 0},    {255, 255, 0},    {255, 255, 255}
          }
        for i = 1, rows do
                for j = 1, (rows + 1 - i) do
                        n = n + 1
                        local x = X0 + ballRadius * ((j-1)*2 + i)
                        local y = Y0 + i*(ballRadius*h)
                        local c
                        ball[n] = display.newCircle(x, y, ballRadius-stroke)
                        local rgb = ballColors[n]
                        ball[n]:setFillColor( rgb[1], rgb[2], rgb[3])
                        ball[n].strokeWidth = stroke
                        ball[n]:setStrokeColor( 255, 255, 255 )
                        ball[n].x = x
                        ball[n].y = y
                end
        end
        Gradient Example:

        local g = graphics.newGradient(
          { 255, 255, 255 },
          { 200, 200, 200 },
          "down" )
         
        -- sets gradient 'g' on rect
        local rect = display.newRect( 0, 0, 100, 200 )
        rect:setFillColor( g )
        Image Tinting Example:

            local image = display.newImage( "image.png" )
            image:setFillColor( 185, 231, 40, 200 )  -- tints to green
        Color Examples:

            object:setFillColor( 0, 0, 0 )  -- black
            object:setFillColor( 255, 255, 255 )  -- white
            object:setFillColor( 255, 0, 0 )  -- red
            object:setFillColor( 0, 255, 0 )  -- green
            object:setFillColor( 0, 0, 255 )  -- blue
            ...





      </Example>
      <Parameters>

        r

        number: Red channel, between 0 and 255.
        g

        number: Green channel, between 0 and 255.
        b

        number: Blue channel, between 0 and 255.
        a

        number:  Alpha is optional and is 255 (opaque) by default.
        gray

        number:  Gray is optional and between 0 and 255 (used when RGB or gradient is not used).
        gradient

        object: A gradient object created using graphics.newGradient().
        Note: To remove tint from an image, set the fill color to white:

        image:setFillColor( 255, 255, 255 )





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Gradient and tinting are only available starting with daily build 2011.612.




      </Remarks>
    </object..setFillColor>
    <object..setStrokeColor>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the stroke color of vector objects (display.newRect, display.newRoundRect, and display.newCircle).


      </Description>
      <Syntax>

        object:setStrokeColor( r, g, b [, a] )





      </Syntax>
      <Example>

        local rect = display.newRect(135, 100, 50, 50)
        rect:setFillColor(255, 255, 255)
        rect:setStrokeColor(140, 140, 140)
        rect.strokeWidth = 5





      </Example>
      <Parameters>

        r

        number: Red channel, between 0 and 255.
        g

        number: Green channel, between 0 and 255.
        b

        number: Blue channel, between 0 and 255.
        a

        number:  Alpha is optional and is 255 (opaque) by default.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </object..setStrokeColor>
  </VectorDisplayObjects>
  <Events>
    <memoryWarningiOSonly>
      <IsFunction>false</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The iOS low memory warning is exposed as a Corona event type named "memoryWarning", sent to the global Runtime object. This event has no fields.
        When this event fires, the OS reserves the right to forcibly shut down the application in about five seconds (although it may or may not do so). Apple advises developers to listen for this warning, and to handle it by freeing as much memory as possible when it is received.


      </Description>
      <Syntax>

        Runtime:addEventListener("memoryWarning", listenerFunction )





      </Syntax>
      <Example>

        Here is an example of a listener for this event:
        local function handleLowMemory( event )
            print( "memory warning received!" )
        end
         
        Runtime:addEventListener( "memoryWarning", handleLowMemory )





      </Example>
      <Parameters>

        listenerFunction

        An event listener function to be notified when a low memory situation occurs.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        You can monitor texture memory used by calling display.getInfo("textureMemoryUsed" ). This returns the texture memory usage (in bytes). Texture memory (for graphics/images) tends to be the most sharply limited resource in mobile development, since it runs out before normal memory.




      </Remarks>
    </memoryWarningiOSonly>
  </Events>
  <DetectNetworkStatus>
    <event.address>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the host associated with this network status change event. This information is potentially useful if you are monitoring multiple hosts with the same callback function and need to distinguish between them.


      </Description>
      <Syntax>

        local result = event.address





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print( "address", event.address )
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        string: Returns the host associated with this network status change event.





      </Returns>
      <Remarks>





      </Remarks>
    </event.address>
    <event.isConnectionOnDemand>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the connection will come up automatically.


      </Description>
      <Syntax>

        local result = event.isConnectionOnDemand





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print("isConnectionOnDemand", event.isConnectionOnDemand)
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Boolean: Returns true if the connection will come up automatically, false otherwise.





      </Returns>
      <Remarks>





      </Remarks>
    </event.isConnectionOnDemand>
    <event.isConnectionRequired>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the connection is up.


      </Description>
      <Syntax>

        local result = event.isConnectionRequired





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print("isConnectionRequired", event.isConnectionRequired)
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Boolean: Returns true if the connection is up.





      </Returns>
      <Remarks>





      </Remarks>
    </event.isConnectionRequired>
    <event.isInteractionRequired>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the user will be required to interact with the application to (re)connect to the host. For example, this will return true if the user will need to enter a password.


      </Description>
      <Syntax>

        local result = event.isInteractionRequired





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print("IsInteractionRequired", event.isInteractionRequired)
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Boolean: Returns true if the user will be required to interact with the application to (re)connect to the host.





      </Returns>
      <Remarks>





      </Remarks>
    </event.isInteractionRequired>
    <event.isReachable>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the specified host is reachable.


      </Description>
      <Syntax>

        local result = event.isReachable





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print( "isReachable", event.isReachable )
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Boolean: True if the host is reachable, false otherwise.





      </Returns>
      <Remarks>





      </Remarks>
    </event.isReachable>
    <event.isReachableViaCellular>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the host is reachable through the cellular network.


      </Description>
      <Syntax>

        local result = event.isReachableViaCellular





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print("IsReachableViaCellular", event.isReachableViaCellular)
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Boolean: true if reachable through cellular, false otherwise.





      </Returns>
      <Remarks>

        On Mac, this always returns false.




      </Remarks>
    </event.isReachableViaCellular>
    <event.isReachableViaWiFi>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if the requested host is reachable via WiFi.


      </Description>
      <Syntax>

        local result = event.isReachableViaWiFi





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print("IsReachableViaWiFi", event.isReachableViaWiFi)  
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Boolean: True if reachable through WiFi, false otherwise.





      </Returns>
      <Remarks>

        On Mac, ethernet also counts as WiFi.




      </Remarks>
    </event.isReachableViaWiFi>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        For network reachability events this property is set to "networkStatus".


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print( "name", event.name )
                print( "address", event.address )
                print( "isReachable", event.isReachable )
                print("isConnectionRequired", event.isConnectionRequired)
                print("isConnectionOnDemand", event.isConnectionOnDemand)
                print("IsInteractionRequired", event.isInteractionRequired)
                print("IsReachableViaCellular", event.isReachableViaCellular)
                print("IsReachableViaWiFi", event.isReachableViaWiFi)  
        end
         
        if network.canDetectNetworkStatusChanges then
                network.setStatusListener( "www.apple.com", MyNetworkReachabilityListener )
        else
                print("network reachability not supported on this platform")
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns name of event, "networkStatus".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
  </DetectNetworkStatus>
  <In-AppPurchases>
    <event.invalidProducts>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When store.loadProducts() returns its requested list of products, any products you requested that are not available for sale will be returned in a array. You can access the array of invalid products through the event.invalidProducts property.
        It is a Lua array with each element containing the product identifier string you originally requested from store.loadProducts().


      </Description>
      <Syntax>

        event.invalidProducts





      </Syntax>
      <Example>

        function loadProductsCallback( event )
                print(event.invalidProducts)   
                for i=1, #event.invalidProducts do
                        print(event.invalidProducts[i])
                end
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </event.invalidProducts>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        For transaction events, then string is "storeTransaction".

        For loadProducts events, the string is "productList".


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </event.name>
    <event.products>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When store.loadProducts() returns its requested list of products, you can access the array of product information through the event.products property.
        It is a Lua array with each element containing a Lua table which contains various product information like title, description, price, and the product identifier.


      </Description>
      <Syntax>

        event.products





      </Syntax>
      <Example>

        function loadProductsCallback( event )
                print("#event.products", #event.products)
                for i=1, #event.products do
                        print(event.products[i].title)
                        print(event.products[i].description)
                        print(event.products[i].price)
                        print(event.products[i].localizedPrice)
                        print(event.products[i].productIdentifier)
                end
        end





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        Each element in the event.products array supports the following fields

        title -- The localized name of the item.
        description -- The localized description of the item.
        price -- The price of an item (as a number, e.g. 0.99)
        localizedPrice -- The price of an item (as a localized currency string, e.g. $0.99) (Available starting in Build 296)
        productIdentifier -- The product identifier.






      </Returns>
      <Remarks>

        localizedString was introduced in 2011.296
        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </event.products>
    <event.transaction>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When a transaction event occurs, you can get the transaction object through the event.transaction property.
        The transaction object has various properties you can access to get more information about the transaction.


      </Description>
      <Syntax>

        event.transaction





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>

        The transaction object supports the following read-only properties

        state -- A string containing the state of the transaction. Valid values are "purchased", "restored", "cancelled", and "failed".
        productIdentifier -- The product identifier associated with the transaction.
        receipt -- A unique receipt returned from the Store. It is returned as a hexadecimal string.
        identifier -- A unique transaction identifier returned from the Store. It is a string.
        date -- The date of when the transaction occurred.
        originalReceipt -- A unique receipt returned from the Store from the original purchase attempt. This is mostly relevant in a case of a restore. It is returned as a hexadecimal string.
        originalIdentifier -- A unique transaction identifier returned from the Store from the original purchase attempt. This is mostly relevant in a case of a restore. It is a string.
        originalDate -- The date of when the original transaction occurred. This is mostly relevant in a case of a restore.
        errorType -- The type of error that occurred when the state is "failed" (a string).
        errorString -- A (sometimes) more descriptive error message of what went wrong in the "failed" case.






      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </event.transaction>
  </In-AppPurchases>
  <Runtime>
    <Runtime..addEventListener>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Adds a global listener to the list of listeners. When the named event occurs, the listener will be invoked and be supplied with a table representing the event.


      </Description>
      <Syntax>

        Runtime:addEventListener( eventName, listener )





      </Syntax>
      <Example>

        Listeners can be either functions or table objects.
        When a function listener is invoked, it is passed a table representing the event:
        local myListener = function( event )
                print( "Listener called with event of type " .. event.name )
        end
        Runtime:addEventListener( "enterFrame", myListener )





      </Example>
      <Parameters>

        eventName

        String specifying the name of the event to listen for.
        listener

        If the event's event.name matches this string, listener will be invoked. Event listeners are either functions or objects (a.k.a. table listeners).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </Runtime..addEventListener>
    <Runtime..hasEventSource>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Determines if the device is capable of providing events for a given event source such as an "accelerometer" or "gyroscope". You should call this function before calling the Runtime:addEventListener() function.


      </Description>
      <Syntax>

        Runtime:hasEventSource( eventSourceName )





      </Syntax>
      <Example>

        if Runtime:hasEventSource( "gyroscope" ) then
            Runtime:addEventListener( "gyroscope", myListener )
        end





      </Example>
      <Parameters>

         eventSourceName
        The name of the event source to check for the existence of such as "accelerometer" or "gyroscope".





      </Parameters>
      <Returns>

        boolean
        Returns true if the event source exists, meaning it is okay to call Runtime:addEventListener() to handle its events.
        Returns false if the event source does not exist. For example, if this returns false for "gyroscope" then this would indicate that that hardware was not found on the device.





      </Returns>
      <Remarks>





      </Remarks>
    </Runtime..hasEventSource>
    <Runtime..removeEventListener>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Removes the specified global listener from the list of listeners so that it no longer is notified of events corresponding to the specified event.


      </Description>
      <Syntax>

        Runtime:removeEventListener( eventName, listener )





      </Syntax>
      <Example>

        -- define motion and limits
        local DX, DY = 3, 3
        local XMIN, XMAX = 1, display.contentWidth - 1
        local YMIN, YMAX = 20, display.contentHeight - 1
         
        -- create a shape
        local button = display.newRoundedRect( XMIN, YMIN, 150, 50, 5 )
        button:setFillColor( 100, 0, 255 )
        button.strokeWidth = 6
        button:setStrokeColor( 200,200,200,255 )
         
        -- move the shape until it hits the limits
        local function onFrame (event)
            if button.x + button.width/2 &gt; XMAX or button.x  XMIN
            or button.y + button.height/2 &gt; YMAX or button.y  YMIN then
                -- stop
                Runtime:removeEventListener("enterFrame", onFrame)
            else
                -- move
                button.x = button.x + DX
                button.y = button.y + DX
            end
        end
         
        -- update the position every frame
        Runtime:addEventListener( "enterFrame", onFrame )





      </Example>
      <Parameters>

        eventName

        String specifying the name of the event whose corresponding listener should be removed from the list.
        listener

        Name of the listener to remove from the list.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </Runtime..removeEventListener>
  </Runtime>
  <accelerometer>
    <event.deltaTime>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the amount of time since the last accelerometer measurement.


      </Description>
      <Syntax>

        value = event.deltaTime





      </Syntax>
      <Example>






      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        number
        Returns a time range since the last measurement as a decimal number, where the whole part of the number is in seconds and the fractional part is sub-seconds.
        For example, a delta time of 100 milliseconds would be returned as 0.1 seconds by this property.





      </Returns>
      <Remarks>

        Accelerometer measurements will not be recorded at the exact times specified by the system.setAccelerometerInterval() function.  This means you cannot assume that a configured interval of 10 Hz (i.e.: 100 milliseconds) will yield measurements recorded exactly 100 milliseconds apart.  These measurements will likely be recorded slightly late.  This is a limitation of the operating system on both iOS and Android.  To compensate for this, event.deltaTime is provided to help make your calculations as accurate as possible.




      </Remarks>
    </event.deltaTime>
    <event.isShake>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Contains true when the user shakes the device.


      </Description>
      <Syntax>

        value = event.isShake





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        value: Returns true when the user shakes the device.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.isShake>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        For accelerometer events this property is set to "accelerometer".


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        local function onAccelerate( event )
            print( "Accelerate name and x/y gravity: " .. event.name, event.xGravity, event.yGravity )
        end
         
        Runtime:addEventListener ("accelerometer", onAccelerate);





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns name of event, "accelerometer".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.xGravity>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the acceleration due to gravity in the x-direction.


      </Description>
      <Syntax>

        value = event.xGravity





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value: The acceleration due to gravity in the x-direction.





      </Returns>
      <Remarks>





      </Remarks>
    </event.xGravity>
    <event.xInstant>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the instantaneous acceleration in the x-direction.


      </Description>
      <Syntax>

        value = event.xInstant





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value: Provides the instantaneous acceleration in the x-direction.





      </Returns>
      <Remarks>





      </Remarks>
    </event.xInstant>
    <event.yGravity>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the acceleration due to gravity in the y-direction.


      </Description>
      <Syntax>

        event.yGravity





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value: The acceleration due to gravity in the y-direction.





      </Returns>
      <Remarks>





      </Remarks>
    </event.yGravity>
    <event.yInstant>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the instantaneous acceleration in the y-direction.


      </Description>
      <Syntax>

        value = event.yInstant





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value: The instantaneous acceleration in the y-direction.





      </Returns>
      <Remarks>





      </Remarks>
    </event.yInstant>
    <event.zGravity>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the acceleration due to gravity in the z-direction.


      </Description>
      <Syntax>

        value = event.zGravity





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Value: the acceleration due to gravity in the z-direction.





      </Returns>
      <Remarks>





      </Remarks>
    </event.zGravity>
    <event.zInstant>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the instantaneous acceleration in the z-direction.


      </Description>
      <Syntax>

        value = event.zInstant





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Value: The instantaneous acceleration in the z-direction.





      </Returns>
      <Remarks>





      </Remarks>
    </event.zInstant>
  </accelerometer>
  <audio>
    <event.channel>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The channel number which just finished playing.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.channel>
    <event.completed>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This value will be true if the audio stopped because it finished playing normally (played to the end of the sound). This value will be false if the audio was stopped because of other reasons.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.completed>
    <event.handle>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This is the audioHandle you passed into audio.play()


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.handle>
  </audio>
  <collision>
    <event.phase>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Specifies the collision phase for the Physics Collision listener and can be one of the following values:

        "began" -- Indicates a collision between two bodies has started initial contact.
        "ended" -- Indicates a collision between two bodies has completed.



      </Description>
      <Syntax>

        event.phase





      </Syntax>
      <Example>

        local crate1 = display.newImage( "crate.png", 100, 200 )
        physics.addBody( crate1, { density = 1.0, friction = 0.3, bounce = 0.2 } )
        crate1.myName = "first crate"
         
        local crate2 = display.newImage( "crate.png", 100, 120 )
        physics.addBody( crate2, { density = 1.0, friction = 0.3, bounce = 0.2 } )
        crate2.myName = "second crate"
         
        local function onCollision( event )
                if ( event.phase == "began" ) then
         
                        print( "began: " .. event.object1.myName .. " &amp; " .. event.object2.myName )
         
                elseif ( event.phase == "ended" ) then
         
                        print( "ended: " .. event.object1.myName .. " &amp; " .. event.object2.myName )
         
                end
        end
         
        Runtime:addEventListener( "collision", onCollision )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: The objects involved in the collision should not be removed or any of it's properties altered during a collision event. You should use timer.performWithDelay() if they want to modify object position values or other properties within the collision events.
        Removing the object or modifying the properties in the collision event could cause the simulator to crash.




      </Remarks>
    </event.phase>
  </collision>
  <completion>
    <event.action>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When the completion event is dispatched after a user has dismissed an alert dialog displayed with native.showAlert(), the event.action property contains information about how the alert was dismissed (cancelled or accepted).
        See that API entry for native.showAlert() for details on handling this type of event property.


      </Description>
      <Syntax>

        event.action





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.action>
    <event.blob>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Listener for "completion" event with "blob" key set in gameNetwork.request. Used to download blog from game network.


      </Description>
      <Syntax>

        data = event.blob





      </Syntax>
      <Example>

        local function myListener( event )
            if string.len( event.blob ) &gt; 0
                print( "Blob received: " .. event.blob )
            else
                print( "No blob received" )
        end
         
        local gameNetwork = require "gameNetwork"
         
        --For OpenFeint:
        gameNetwork.init( "openfeint", "product-key", "secret", "display name", "appId" )
         
         
        gameNetwork.request( "downloadBlob", key, myListener ) -- listener for "completion" event with "blob" key set.





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        string

        A string that contains the requested blob data. If the length of this string is 0, then the download failed.





      </Returns>
      <Remarks>

        Note: "downloadBlob" and "uploadBlob" requests are not available on Android.




      </Remarks>
    </event.blob>
    <event.index>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The the index of the button pressed in a native alert dialog, corresponding to the index in the buttonLabels parameter passed to native.showAlert() method. See the API entry for that method for details on handling this event property.


      </Description>
      <Syntax>

        event.index





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.index>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Contains the string "completion".


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.target>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The display image object generated after a user completes a camera session initiated with media.show().


      </Description>
      <Syntax>

        event.target





      </Syntax>
      <Example>

        local onComplete = function(event)
           local photo = event.target
           print( "photo w,h = " .. photo.width .. "," .. photo.height )
        end
        media.show( media.Camera, onComplete )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Display Object

        Returns the new Display Object.





      </Returns>
      <Remarks>





      </Remarks>
    </event.target>
  </completion>
  <creditsRequest>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The string "creditsRequest".


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        "creditsRequest"





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.newCredits>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Number of new credits earned.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Number of credits.





      </Returns>
      <Remarks>





      </Remarks>
    </event.newCredits>
    <event.totalCredits>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Total available credits.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Total number of credits.





      </Returns>
      <Remarks>





      </Remarks>
    </event.totalCredits>
  </creditsRequest>
  <enterFrame>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The string "enterFrame" used with Runtime:addEventListener API to call the event listener every frame time (either 30 or 60 fps).


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

        local myListener = function( event )
                print( "Listener called with event of type " .. event.name )
        end
        Runtime:addEventListener( "enterFrame", myListener )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.time>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The time in milliseconds since the start of the application.


      </Description>
      <Syntax>

        event.time





      </Syntax>
      <Example>

        function printTimeSinceStart( event )
          print (event.time/1000 .. " seconds since app started." )
        end
        Runtime:addEventListener("enterFrame", printTimeSinceStart)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.time>
  </enterFrame>
  <gameNetwork>
    <event.data>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When a gameNetwork event needs to return information, the data field is where the information is provided. This type will change based on the specific operation.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.data>
    <event.errorCode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        If an error occurs, this will be set with an integer returning the error code of the error. If there is no error, this field is nil.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        On iOS and Mac, the error code is usually the error code that is returned by Apple.

        See event.errorMessage for a human readable string that describes the error.




      </Remarks>
    </event.errorCode>
    <event.errorMessage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        If an error occurs, this is set to a string describing the error that was occurred. If there was no error, this field is nil.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.errorMessage>
    <event.localPlayerScore>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        For specific Game Center request operations, this returns a table containing values that represent the local player's score.


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.localPlayerScore>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        An identifier of the event. Always returns a string 'gameNetwork'.


      </Description>
      <Syntax>

        local name = event.name





      </Syntax>
      <Example>

        local function = gameNetworkEvent( event )
            print( "gameNetwork name: " .. event.name )
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        String

        Returns the event name, "gameNetwork"





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.provider>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The (string) name of the gameNetwork provider the event was generated by.

        Possible values are:

        'openfeint'

        'papaya'

        'gamecenter'


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.provider>
    <event.type>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The (string) name of the operation that generated the event, e.g.

        gameNetwork.request("loadScores", {listener=requestCallback}) returns "loadScores".


      </Description>
      <Syntax>

         





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </event.type>
  </gameNetwork>
  <gyroscope>
    <event.deltaTime>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the amount of time since the last gyroscope measurement.


      </Description>
      <Syntax>

        value = event.deltaTime





      </Syntax>
      <Example>

        -- Called when a new gyroscope measurement has been received.
        local function onGyroscopeDataReceived( event )
            -- Calculate approximate rotation traveled via deltaTime.
            -- Remember that rotation rate is in radians per second.
            local deltaRadians = event.zRotation * event.deltaTime
            local deltaDegrees = deltaRadians * (180 / math.pi)
        end
         
        -- Set up the above function to receive gyroscope events if the sensor exists.
        if system.hasEventSource( "gyroscope" ) then
            Runtime:addEventListener( "gyroscope", onGyroscopeDataReceived )
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        number
        Returns a time range since the last measurement as a decimal number, where the whole part of the number is in seconds and the fractional part is sub-seconds.
        For example, a delta time of 100 milliseconds would be returned as 0.1 seconds by this property.





      </Returns>
      <Remarks>

        Gyroscope measurements will not be recorded at the exact times specified by the system.setGyroscopeInterval() function.  This means you cannot assume that a configured interval of 10 Hz (i.e.: 100 milliseconds) will yield measurements recorded exactly 100 milliseconds apart.  These measurements will likely be recorded slightly late.  This is a limitation of the operating system on both iOS and Android.  To compensate for this, event.deltaTime is provided to help make your rotational calculations as accurate as possible.
        You can use event.deltaTime to calculate the approximate rotation distance traveled since the last gyroscope measurement as follows...

        delta radians = rotation rate * delta time
        Please note that this is an approximation, because the device has not likely rotated at a constant speed since the last gyroscope measurement.  This means that the summed distance over time will grow in error.  Increasing the measurement update interval via the system.setGyroscopeInterval() function will help reduce that error.




      </Remarks>
    </event.deltaTime>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the string, "gryoscope", for gyroscope events generated by the hardware.


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        -- Called when a new gyroscope measurement has been received.
        local function onGyroscopeDataReceived( event )
            print( "Gyroscope name: " .. event.name )
        end
         
        -- Set up the above function to receive gyroscope events if the sensor exists.
        if system.hasEventSource( "gyroscope" ) then
            Runtime:addEventListener( "gyroscope", onGyroscopeDataReceived )
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        string

        Returns the name of the event.





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.xRotation>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the rotation rate around the device's x-axis in radians per second.


      </Description>
      <Syntax>

        value = event.xRotation



      </Syntax>
      <Example>

        -- Called when a new gyroscope measurement has been received.
        local function onGyroscopeDataReceived( event )
            -- Calculate approximate rotation traveled via deltaTime.
            -- Remember that rotation rate is in radians per second.
            local deltaRadians = event.xRotation * event.deltaTime
            local deltaDegrees = deltaRadians * (180 / math.pi)
        end
         
        -- Set up the above function to receive gyroscope events if the sensor exists.
        if system.hasEventSource( "gyroscope" ) then
            Runtime:addEventListener( "gyroscope", onGyroscopeDataReceived )
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        number
        Returns the rotation rate in radians per second where values are positive in the counter-clockwise direction.





      </Returns>
      <Remarks>

        You can convert radians to degrees via the following formula:

        degrees = radians * (180 / pi)




      </Remarks>
    </event.xRotation>
    <event.yRotation>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the rotation rate around the device's y-axis in radians per second.


      </Description>
      <Syntax>

        value = event.yRotation





      </Syntax>
      <Example>

        -- Called when a new gyroscope measurement has been received.
        local function onGyroscopeDataReceived( event )
            -- Calculate approximate rotation traveled via deltaTime.
            -- Remember that rotation rate is in radians per second.
            local deltaRadians = event.yRotation * event.deltaTime
            local deltaDegrees = deltaRadians * (180 / math.pi)
        end
         
        -- Set up the above function to receive gyroscope events if the sensor exists.
        if system.hasEventSource( "gyroscope" ) then
            Runtime:addEventListener( "gyroscope", onGyroscopeDataReceived )
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        number
        Returns the rotation rate in radians per second where values are positive in the counter-clockwise direction.





      </Returns>
      <Remarks>

        You can convert radians to degrees via the following formula:

        degrees = radians * (180 / pi)




      </Remarks>
    </event.yRotation>
    <event.zRotation>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the rotation rate around the device's z-axis in radians per second.


      </Description>
      <Syntax>

        value = event.zRotation





      </Syntax>
      <Example>

        -- Called when a new gyroscope measurement has been received.
        local function onGyroscopeDataReceived( event )
            -- Calculate approximate rotation traveled via deltaTime.
            -- Remember that rotation rate is in radians per second.
            local deltaRadians = event.zRotation * event.deltaTime
            local deltaDegrees = deltaRadians * (180 / math.pi)
        end
         
        -- Set up the above function to receive gyroscope events if the sensor exists.
        if system.hasEventSource( "gyroscope" ) then
            Runtime:addEventListener( "gyroscope", onGyroscopeDataReceived )
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        number
        Returns the rotation rate in radians per second where values are positive in the counter-clockwise direction.





      </Returns>
      <Remarks>

        You can convert radians to degrees via the following formula:

        degrees = radians * (180 / pi)




      </Remarks>
    </event.zRotation>
  </gyroscope>
  <headingcompass>
    <event.geographic>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the heading in degrees (clockwise) relative to the geographic North Pole, sometimes known as true North.


      </Description>
      <Syntax>

        value = event.geographic





      </Syntax>
      <Example>

        local function = updateCompass( event )
            print( "Compass name: " .. event.name )
            print( "Compass geographic: " .. event. geographic )
            print( "Compass magnetic: " .. event. magnetic )
        end
         
        Runtime:addEventListener( "heading", updateCompass );





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.geographic>
    <event.magnetic>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the heading in degrees (clockwise) relative to the magnetic North Pole.


      </Description>
      <Syntax>

        event.magnetic





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.magnetic>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        These are heading events generated by the compass hardware. Returns the string "heading".


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        local function = updateCompass( event )
            print( "Compass name: " .. event.name )
            print( "Compass geographic: " .. event.geographic )
            print( "Compass magnetic: " .. event.magnetic )
        end
         
        Runtime:addEventListener( "heading", updateCompass )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the string "heading".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
  </headingcompass>
  <key>
    <event.keyName>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used in the "key" listener to obtain the string name of the navigation key pressed. See event.phase for the state of the key (up or down).
        Note: The "home" and text keys (A-Z, 0-9, punctuation)  cannot be captured.
        ** Only available on Android devices ***


      </Description>
      <Syntax>

        keyName = event.keyName





      </Syntax>
      <Example>

        -- Key listener
        local function onKeyEvent( event )
                local phase = event.phase
                local keyName = event.keyName
                eventTxt.text = "("..phase.." , " .. keyName ..")"
         
                -- we handled the event, so return true.
                -- for default behavior, return false.
                return true
        end
         
        -- Add the key callback
        Runtime:addEventListener( "key", onKeyEvent );
        Note: Return "false" in the keyEvent listener to use the default action for the key.





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the name of the navigation key pressed: "back", "search", "menu", "volumeUp", "volumeDown".
        The D-Pad/Trackball key strings are: "up", "down", "left", "right", and "center".
        Note: The "home" key cannot be captured.





      </Returns>
      <Remarks>





      </Remarks>
    </event.keyName>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Android key pressed listener. Returns the name of the event, "key"


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        -- Key listener
        local function onKeyEvent( event )
                local phase = event.phase
                local keyName = event.keyName
                eventTxt.text = "("..phase.." , " .. keyName ..")"
         
                -- we handled the event, so return true.
                -- for default behavior, return false.
                return true
        end
         
        -- Add the key callback
        Runtime:addEventListener( "key", onKeyEvent );





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        The string "key".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.phase>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used in the "key" listener to obtain the string name of the navigation key state (up or down). See event.keyName for key names.


      </Description>
      <Syntax>

        phase = event.phase





      </Syntax>
      <Example>

        -- Key listener
        local function onKeyEvent( event )
                local phase = event.phase
                local keyName = event.keyName
                eventTxt.text = "("..phase.." , " .. keyName ..")"
         
                -- we handled the event, so return true.
                -- for default behavior, return false.
                return true
        end
         
        -- Add the key callback
        Runtime:addEventListener( "key", onKeyEvent );
        Note: Return "false" in the keyEvent listener to use the default action for the key.





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the state of the key pressed: "up" or "down".





      </Returns>
      <Remarks>





      </Remarks>
    </event.phase>
  </key>
  <locationGPS>
    <event.accuracy>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the accuracy of the GPS location in meters. If negative, then the latitude and longitude are not valid.


      </Description>
      <Syntax>

        event.accuracy





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.accuracy>
    <event.altitude>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the altitude in meters of the current GPS location.


      </Description>
      <Syntax>

        event.altitude





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.altitude>
    <event.direction>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the direction the device is traveling in degrees clockwise from true North. If negative, the direction is invalid.


      </Description>
      <Syntax>

        event.direction





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Returns the direction the device is traveling.





      </Returns>
      <Remarks>





      </Remarks>
    </event.direction>
    <event.errorCode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a platform-specific integer for an error condition that is not language dependent. This property only exists when a GPS error occurs, otherwise is nil.


      </Description>
      <Syntax>

        value = event.errorCode





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Returns a platform-specific integer for an error condition.





      </Returns>
      <Remarks>





      </Remarks>
    </event.errorCode>
    <event.errorMessage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a string that describes an error in acquiring a GPS location from the device. If no error has occurred this property is nil. The string may be localized according to the userâ€™s language setting.


      </Description>
      <Syntax>

        value = event.errorMessage





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns a string that describes an error in acquiring a GPS location from the device.





      </Returns>
      <Remarks>





      </Remarks>
    </event.errorMessage>
    <event.latitude>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the latitude in degrees of the current GPS location.


      </Description>
      <Syntax>

        value = event.latitude





      </Syntax>
      <Example>

        local locationHandler = function( event )
         
            -- Check for error (user may have turned off Location Services)
            if event.errorCode then
                native.showAlert( "GPS Location Error", event.errorMessage, {"OK"} )
                print( "Location error: " .. tostring( event.errorMessage ) )
            else
                local latitudeText = string.format( '%.4f', event.latitude )
                currentLatitude = latitudeText
                latitude:setText( latitudeText )
                       
                local longitudeText = string.format( '%.4f', event.longitude )
                currentLongitude = longitudeText
                longitude:setText( longitudeText )
                       
                local altitudeText = string.format( '%.3f', event.altitude )
                altitude:setText( altitudeText )
               
                local accuracyText = string.format( '%.3f', event.accuracy )
                accuracy:setText( accuracyText )
                       
                local speedText = string.format( '%.3f', event.speed )
                speed:setText( speedText )
               
                local directionText = string.format( '%.3f', event.direction )
                direction:setText( directionText )
               
                -- Note: event.time is a Unix-style timestamp, expressed in seconds since Jan. 1, 1970
                local timeText = string.format( '%.0f', event.time )
                time:setText( timeText )
                end
        end
         
        -- Activate location listener
        Runtime:addEventListener( "location", locationHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Returns the latitude in degrees of the current GPS location.





      </Returns>
      <Remarks>





      </Remarks>
    </event.latitude>
    <event.longitude>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the longitude in degrees of the current location.


      </Description>
      <Syntax>

        value = event.longitude





      </Syntax>
      <Example>

        local locationHandler = function( event )
         
            -- Check for error (user may have turned off Location Services)
            if event.errorCode then
                native.showAlert( "GPS Location Error", event.errorMessage, {"OK"} )
                print( "Location error: " .. tostring( event.errorMessage ) )
            else
                local latitudeText = string.format( '%.4f', event.latitude )
                currentLatitude = latitudeText
                latitude:setText( latitudeText )
                       
                local longitudeText = string.format( '%.4f', event.longitude )
                currentLongitude = longitudeText
                longitude:setText( longitudeText )
                       
                local altitudeText = string.format( '%.3f', event.altitude )
                altitude:setText( altitudeText )
               
                local accuracyText = string.format( '%.3f', event.accuracy )
                accuracy:setText( accuracyText )
                       
                local speedText = string.format( '%.3f', event.speed )
                speed:setText( speedText )
               
                local directionText = string.format( '%.3f', event.direction )
                direction:setText( directionText )
               
                -- Note: event.time is a Unix-style timestamp, expressed in seconds since Jan. 1, 1970
                local timeText = string.format( '%.0f', event.time )
                time:setText( timeText )
                end
        end
         
        -- Activate location listener
        Runtime:addEventListener( "location", locationHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Returns the longitude in degrees of the current location.





      </Returns>
      <Remarks>

        Note: In the Location event listener. errorCode should be check in case of a Location error. This flag will be non-nil if the user disables Location Services for this app (on iOS).




      </Remarks>
    </event.longitude>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        These are location events generated by the GPS hardware. Returns the string "location".


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        local function = locationHandler( event )
            print( "Location name: " .. event.name )
            print( "Location latitude: " .. event.latitude )
            print( "Location longitude: " .. event.longitude )
        end
         
        Runtime:addEventListener( "location", locationHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the string, "location".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.speed>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the instantaneous speed of the GPS device in meters per second. (Divide the results by 0.447 to get Miles Per Hour.)


      </Description>
      <Syntax>

        value = event.speed





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Returns the instantaneous speed of the GPS device in meters per second.





      </Returns>
      <Remarks>





      </Remarks>
    </event.speed>
    <event.time>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the UTC timestamp of the GPS location event.


      </Description>
      <Syntax>

        value = event.time





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        time

        Returns the UTC timestamp of the GPS location event.





      </Returns>
      <Remarks>





      </Remarks>
    </event.time>
  </locationGPS>
  <mapAddress>
    <event.city>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the  city or town in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        city = event.city





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            print( "The specified location is in: " .. event.city .. ", " .. event.country )
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns city as a string.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.city>
    <event.cityDetail>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets additional city information, such as neighborhood in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        cityDetail = event.cityDetail





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            print( "The  City Detail is: " .. event.cityDetail )
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns city information as a string.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.cityDetail>
    <event.country>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the country name in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        county = event.county





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            print( "The specified location is in: " .. event.city .. ", " .. event.country )
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        String

        Returns county as a string.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.country>
    <event.countryCode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the standard country abbreviation in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        countyCode = event.countryCode





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            print( "The specified location is in: " .. event.city .. ", " .. event.countryCode )
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns country code.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.countryCode>
    <event.errorMessage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the error message if event.isError is true, in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        message = event.errorMessage





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            if event.isError then
                print( "mapView Error: " .. event.errorMessage )
            else
                print( "The specified location is in: " .. event.city .. ", " .. event.country )
            end
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string&gt;

        Error message





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.errorMessage>
    <event.isError>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A boolean that indicates whether the reverse-geocoding server returned an error rather than a location (in response to a myMap:nearestAddress() call).
        Normally this will be false, but in the error case it will be true (and the other event attributes will be empty).  event.errorMessage will contain a string describing the error.


      </Description>
      <Syntax>

        error = event.isError





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            if event.isError then
                print( "mapView Error: " .. event.errorMessage )
            else
                print( "The specified location is in: " .. event.city .. ", " .. event.country )
            end
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        boolean

        True if error occurred, otherwise returns false.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.isError>
    <event.postalCode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the postal code in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        postalCode = event.postCode





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the postal code.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.postalCode>
    <event.region>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The state, province, or similar region within the country in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        region = event.region





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the region.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.region>
    <event.regionDetail>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The region below the state level (for example, the county in the United States) in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        regionDetail = event.regionDetail





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        The  region detail.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.regionDetail>
    <event.street>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the street name in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        street = event.street





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Street name.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.street>
    <event.streetDetail>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets the street number (or other specifier for location on the street) in response to a myMap:nearestAddress() call.


      </Description>
      <Syntax>

        streetDetail = event.streetDetail





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Street detail.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </event.streetDetail>
  </mapAddress>
  <notification>
    <event.custom>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A table that was provided at the time the notification was scheduled.


      </Description>
      <Syntax>

        event.custom





      </Syntax>
      <Example>






      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>





      </Remarks>
    </event.custom>
    <event.type>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string identifying the type of notification event. It can be:

        "local"
        for events created locally
        "remote"
        for remote push events originating from a server
        "remoteRegistration"
        for initializing remote push events. If successful, the event will also contain a "token" property which contains a string needed by your push server to communicate with Apple's Push Notification server; if not, then the event will have an "error" property.

        Check out the following guides for more information:

        Local Push Notifications on iOS
        Remote Push Notifications on iOS



      </Description>
      <Syntax>

        event.type





      </Syntax>
      <Example>






      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Remote push registration for iOS was added in 2011.711




      </Remarks>
    </event.type>
  </notification>
  <orientation>
    <event.delta>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the angular difference between the ending and starting orientation. Returns 0 if the two orientations lie in different planes.


      </Description>
      <Syntax>

        event.delta





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.delta>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the string "orientation".
        Orientation events occur when the device orientation changes (portrait, landscape). They are only sent to the global Runtime object.


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.type>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string identifying the new orientation of the device with one of the following values:

        "portrait"
        "landscapeLeft"
        "portraitUpsideDown"
        "landscapeRight"
        "faceUp"
        "faceDown"



      </Description>
      <Syntax>

        event.type





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.type>
  </orientation>
  <postCollision>
    <event.force>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The direct force of the postCollision being reported with the current event.


      </Description>
      <Syntax>

        event.force





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.force>
    <event.friction>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The frictional force of the postCollision being reported in the event.


      </Description>
      <Syntax>

        event.friction





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.friction>
    <event.object1>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When detected with a global Runtime listener, each post-collision event includes event.object1 and event.object2, which contain the table IDs of the two display objects involved.


      </Description>
      <Syntax>

        event.object1





      </Syntax>
      <Example>

        local crate1 = display.newImage( "crate.png", 100, 200 )
        physics.addBody( crate1, { density = 1.0, friction = 0.3, bounce = 0.2 } )
        crate1.myName = "first crate"
         
        local crate2 = display.newImage( "crate.png", 100, 120 )
        physics.addBody( crate2, { density = 1.0, friction = 0.3, bounce = 0.2 } )
        crate2.myName = "second crate"
         
        local function onPostCollision( event )
                if ( event.phase == "began" ) then
                        print( "began: " .. event.object1.myName .. " &amp; " .. event.object2.myName )
                elseif ( event.phase == "ended" ) then
                        print( "ended: " .. event.object1.myName .. " &amp; " .. event.object2.myName )
                end
        end
         
        Runtime:addEventListener( "postCollision", onPostCollision )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.object1>
    <event.object2>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When detected with a global Runtime listener, each post-collision event includes event.object1 and event.object2, which contain the table IDs of the two display objects involved.


      </Description>
      <Syntax>

        event.object1





      </Syntax>
      <Example>

        local crate1 = display.newImage( "crate.png", 100, 200 )
        physics.addBody( crate1, { density = 1.0, friction = 0.3, bounce = 0.2 } )
        crate1.myName = "first crate"
         
        local crate2 = display.newImage( "crate.png", 100, 120 )
        physics.addBody( crate2, { density = 1.0, friction = 0.3, bounce = 0.2 } )
        crate2.myName = "second crate"
         
        local function onPostCollision( event )
                if ( event.phase == "began" ) then
                        print( "began: " .. event.object1.myName .. " &amp; " .. event.object2.myName )
                elseif ( event.phase == "ended" ) then
                        print( "ended: " .. event.object1.myName .. " &amp; " .. event.object2.myName )
                end
        end
         
        Runtime:addEventListener( "postCollision", onPostCollision )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.object2>
    <event.other>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When detected with a table listener within an object, each "postCollision" event includes event.other, which contains the table ID of the other display object involved in the collision.


      </Description>
      <Syntax>

        event.other





      </Syntax>
      <Example>

        local function onPostCollision( event )
                if ( event.force &gt; 1.0 ) then
                        print( "Collision force: " .. event.force .. " Friction: " .. event.friction )
                end
        end
         
        Runtime:addEventListener( "postCollision", onPostCollision )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.other>
  </postCollision>
  <preCollision>
    <event.other>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        When detected with a table listener within an object, each Physics preCollision event includes event.other, which contains the ID of the other Corona display object involved in the collision.


      </Description>
      <Syntax>

        event.other





      </Syntax>
      <Example>

        local physics = require("physics")
        physics.start()
         
        local crate1 = display.newImage( "crate.png" )
        physics.addBody( crate1, { density=3.0, friction=0.5, bounce=0.3 } )
        crate1.myName = "first crate"
         
        local ground = display.newImage( "ground.png" )
        ground.y = display.contentHeight
        ground.myName = "ground"
         
        local function onLocalPreCollision( self, event )
                -- The preCollision  event type fires shortly before a collision occurs, so you can use this if you want
                -- to override some collisions in your game logic. For example, you might have a platform game
                -- where the character should jump "through" a platform on the way up, but land on the platform
                -- as they fall down again.
               
                -- Note that this event is very "noisy", since it fires whenever any objects are somewhat close!
         
                print( "preCollision: " .. self.myName .. " is about to collide with " .. event.other.myName )
         
        end
         
        -- Here we assign the above two functions to local listeners within crate1 only, using table listeners:
         
        crate1.preCollision = onLocalPreCollision
        crate1:addEventListener( "preCollision", crate1 )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Display Object
        Returns the ID of the other Corona display object involved in the collision.





      </Returns>
      <Remarks>

        Note: The â€œpreCollisionâ€ events are quite noisy, and may report many times per contact and may affect performance.  Therefore, you should only listen for these events if you need pre-collision warnings, and we also recommend that you use local listeners within the objects of interest, rather than listening globally to all "preCollision" events in the world.




      </Remarks>
    </event.other>
  </preCollision>
  <sprite>
    <event.phase>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string indicating the phase which the sprite animation is currently in. Can be one of the following values:

        "end" - the sprite stops playing
        "loop" - the sprite loops (from last to first, or reverses direction)
        "next" - the sprite's next frame is played



      </Description>
      <Syntax>

        event.phase





      </Syntax>
      <Example>

        local function spriteListener( event )
            print( "Sprite listener" .. event.name, event.sprite, event.phase,
                event.sprite.sequence
        end
         
        -- Add sprite listener
        instance:addEventListener( "sprite", spriteListener )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns the sprite phase ("end", "next", "loop").





      </Returns>
      <Remarks>





      </Remarks>
    </event.phase>
    <event.sprite>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The sprite that generated the event; its current properties may also be accessed via this property (for example, event.sprite.sequence would provide the current sequence for the sprite.


      </Description>
      <Syntax>

        event.sprite





      </Syntax>
      <Example>

        local function spriteListener( event )
            print( "Sprite event: ", event.sprite.sequence, event.phase )
        end
         
        -- Add sprite listener
        instance:addEventListener( "sprite", spriteListener )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        object

        Returns the sprite object that generated the event.





      </Returns>
      <Remarks>





      </Remarks>
    </event.sprite>
  </sprite>
  <system>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the string "system".
        System events are dispatched to notify the application of external events such as when the device needs to suspend or exit the application.


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

        local function onSystemEvent( event )
            print( "System event name and type: " .. event.name, event.type )
        end
         
        Runtime:addEventListener( "system", onSystemEvent )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.type>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string identifying the type of system event that occurred. It will be one of the following values:

        "applicationStart" occurs when the application is launched and all code in main.lua is executed.
        "applicationExit" occurs when the user or OS task manager quits the application.
        "applicationSuspend" occurs when the device needs to suspend the application such as during a phone call or if the device goes to sleep (from inactivity or user action). In the simulator, this corresponds to selecting "Suspend" from the Hardware menu. During suspension, no events (not even enterFrame events) are sent to the application while suspended, so if you have code that depends on time, you should account for the time lost to an application being suspended.
        "applicationResume" occurs when the application resumes after a suspend. On the device, this occurs if the application was suspended because of a phone call or sleep. In the simulator, this corresponds to selecting "Resume" from the Hardware menu.



      </Description>
      <Syntax>

        event.type





      </Syntax>
      <Example>

        local function onSystemEvent( event )
            print( "System event name and type: " .. event.name, event.type )
        end
         
        Runtime:addEventListener( "system", onSystemEvent )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.type>
  </system>
  <tap>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The name of the event, "tap".


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        local function onTap( event )
            print( "Tap name: " .. event.name )
            print( "Tap: event(" .. event.numTaps .. ") ("..event.x..","..event.y..")" )                          
        end
         
        Runtime:addEventListener( "tap", onTap)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        The string "tap".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.numTaps>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of taps on the screen.


      </Description>
      <Syntax>

        value = event.numTaps





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Number of taps on the screen. E.g, 1 = one tap, 2 = two taps.





      </Returns>
      <Remarks>





      </Remarks>
    </event.numTaps>
    <event.x>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the x-position in screen coordinates of the tap.


      </Description>
      <Syntax>

        value = event.x





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        The x-position in screen coordinates of the tap.





      </Returns>
      <Remarks>





      </Remarks>
    </event.x>
    <event.y>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the y-position in screen coordinates of the tap.


      </Description>
      <Syntax>

        value = event.y





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        The y-position in screen coordinates of the tap.





      </Returns>
      <Remarks>





      </Remarks>
    </event.y>
  </tap>
  <timer>
    <event.count>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the number of times that the timer has fired the listener. This is useful if you registered the timer to fire multiple times.


      </Description>
      <Syntax>

        event.count





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.count>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The string "timer".


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.source>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides a reference to the timer registered to send the event. This may be useful if you have multiple timers calling the same listener.


      </Description>
      <Syntax>

        event.source





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        userdata

        Reference to the timer that called the listener.





      </Returns>
      <Remarks>





      </Remarks>
    </event.source>
    <event.time>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the time in milliseconds since the start of the application.


      </Description>
      <Syntax>

        event.time





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        The elapsed time since the start of the application (in milliseconds).





      </Returns>
      <Remarks>





      </Remarks>
    </event.time>
  </timer>
  <touch>
    <event.id>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A unique identifier of the chosen touch that enables you to distinguish between multiple touches across different touch events. The id uniquely identifies a given finger touching the screen as that touch changes state, generating new touch events (moved, ended, and so forth).


      </Description>
      <Syntax>

        event.id





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        userdata

        A unique identifier of the touch event.





      </Returns>
      <Remarks>





      </Remarks>
    </event.id>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The name of the event, "touch".
        Available in the "touch" listener.


      </Description>
      <Syntax>

        value = event.name





      </Syntax>
      <Example>

        local function onTouch( event )
            print( "Touch name: " .. event.name )
            print( "Touch: event(" .. event.phase .. ") ("..event.x..","..event.y..")" .. tostring(event.id) )                         
        end
         
        Runtime:addEventListener( "touch", onTouch )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        The string "touch".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.phase>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string identifying where in the touch sequence the event occurred. Can be one of the following values:

        "began" indicates a finger touched the screen.
        "moved" indicates a finger moved on the screen.
        "ended" indicates a finger was lifted from the screen.
        "cancelled" indicates the system cancelled tracking of the touch.



      </Description>
      <Syntax>

        event.phase





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.phase>
    <event.target>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The display image object associated with the touch event. This value will be nil if this was called by a Runtime Touch event.


      </Description>
      <Syntax>

        event.target





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Display Object

        Returns the touched Display Object.





      </Returns>
      <Remarks>





      </Remarks>
    </event.target>
    <event.time>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A timestamp indicating when the event took place. It is in the same units as returned by system.getTimer(), the number of milliseconds since application launch.


      </Description>
      <Syntax>

        event.time





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.time>
    <event.x>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Provides the x-position in screen coordinates of the touch.


      </Description>
      <Syntax>

        event.x





      </Syntax>
      <Example>

        The following code creates a green circle that follows the user's finger as it moves across the screen.

        local circle = display.newCircle(50, 50, 100)
        circle:setFillColor(0,255,00)
        function moveCircle( event )
          circle.x = event.x
          circle.y = event.y
        end
        Runtime:addEventListener("touch", moveCircle)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.x>
    <event.xStart>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The x-position of the touch from the "began" phase of the touch sequence.


      </Description>
      <Syntax>

        event.x





      </Syntax>
      <Example>

        The following example draws a line from the point the touch began to the where it finally ended.
        function drawLine( event )
          if(event.phase == "ended") then
            line = display.newLine(event.xStart, event.yStart, event.x, event.y)
            line:setColor(255,0,0)
            line.width = 5
          end
        end
        Runtime:addEventListener("touch", drawLine)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.xStart>
    <event.y>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The y-position in screen coordinates of the touch.


      </Description>
      <Syntax>

        event.y





      </Syntax>
      <Example>

        The following example sets the x and y coordinates of a display object (a green circle) to the current x and y touch coordinates.

        local circle = display.newCircle(50, 50, 100)
        circle:setFillColor(0,255,00)
        function moveCircle( event )
          circle.x = event.x
          circle.y = event.y
        end
        Runtime:addEventListener("touch", moveCircle)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.y>
    <event.yStart>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The y-position of the touch from the "began" phase of the touch sequence.


      </Description>
      <Syntax>

        event.y





      </Syntax>
      <Example>

        The following example draws a red, 5-pixel line from the point the touch began to where it ended.
        function drawLine( event )
          if(event.phase == "ended") then
            line = display.newLine(event.xStart, event.yStart, event.x, event.y)
            line:setColor(255,0,0)
            line.width = 5
          end
        end
        Runtime:addEventListener("touch", drawLine)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.yStart>
  </touch>
  <urlRequest>
    <event.errorCode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        An error code of the error that occurred in the URL request of a native.webPopup() call.
        A platform-specific integer for the error which is not language dependent. This property only exists when an error occurs.


      </Description>
      <Syntax>

        event.errorCode





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        number

        Returns error number if problem loading page. Otherwise, returns nil.





      </Returns>
      <Remarks>





      </Remarks>
    </event.errorCode>
    <event.errorMessage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string with an description of an error that occurred in the URL request of a native.webPopup() call.. This property only exists when an error has occurred, otherwise it is undefined. It may be localized depending on the userâ€™s language setting.


      </Description>
      <Syntax>

        event.errorMessage





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        Returns error message if problem loading page. Otherwise, returns nil.





      </Returns>
      <Remarks>





      </Remarks>
    </event.errorMessage>
    <event.name>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The native.showWebPopup listener event returns the string, "urlRequest".


      </Description>
      <Syntax>

        event.name





      </Syntax>
      <Example>

        local function listener( event )
            print( "Webpopup: " .. event.name, event.errorCode )
            return true  -- load the page
        end
         
        native.showWebPopup( 10, 10, 300, 300,
                          "http://www.anscamobile.com",
                          {urlRequest=listener} )





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        string

        Returns the string, "urlRequest".





      </Returns>
      <Remarks>





      </Remarks>
    </event.name>
    <event.url>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The absolute URL of the request.


      </Description>
      <Syntax>

        event.url





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </event.url>
  </urlRequest>
  <Facebook>
    <facebook.login>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Prompts the user to login to Facebook.
        This API can be called even if the user is already logged in.


      </Description>
      <Syntax>

        facebook.login( appId, listener [, permissions ] )





      </Syntax>
      <Example>

        local facebook = require "facebook"
         
        -- listener for "fbconnect" events
        local function listener( event )
            if ( "session" == event.type ) then
                -- upon successful login, request list of friends of the signed in user
                if ( "login" == event.phase ) then
                    facebook.request( "me/friends" )
         
                    -- Fetch access token for use in Facebook's API
                    local access_token = event.token
                    print( access_token )
                end
            elseif ( "request" == event.type ) then
                -- event.response is a JSON object from the FB server
                local response = event.response
         
                -- if request succeeds, create a scrolling list of friend names
                if ( not event.isError ) then
                    response = json.decode( event.response )
         
                    local data = response.data
                    for i=1,#data do
                        local name = data[i].name
                        print( name )
                    end
                end
            elseif ( "dialog" == event.type ) then
                print( "dialog", event.response )
            end
        end
         
        -- NOTE: You must provide a valid application id provided from Facebook
        local appId = nil
        if ( appId ) then
                facebook.login( appId, listener, {"publish_stream"} )
        else
                local function onComplete( event )
                        system.openURL( "http://developers.facebook.com/setup" )
                end
         
                native.showAlert( "Error", "To develop for Facebook Connect, you need to get an application id from Facebook's website.", { "Learn More" }, onComplete )
        end





      </Example>
      <Parameters>

        appId

        string: The application id that you get when you register your Facebook application.
        listener

        function or table: A listener that responds to "fbconnect" events. If listener is a table, it should have a property "fbconnect" that is a function.
        permissions

        array: An optional array of strings that correspond to Facebook's publishing permissions. This enables your application to ask the user to grant your application certain extended permissions. If not supplied, no extended permissions are requested. Use "publish_stream" to allow posting to the user's wall.





      </Parameters>
      <Returns>

        The login comes back in the form of a fbconnect event that is sent to a listener. This listener was registered during the login call.
        The event will have the following properties:
        event.name

        string: the name of the event "fbconnect"
        event.token

        string: this is the access token needed for certain Facebook API calls. It is only present when the event.phase is "login". It is nil otherwise.
        event.type

        string: the type of event "session"
        event.phase

        string: one of these login status strings: "login", "loginFailed" or "loginCancelled"
        Note: If the user is already logged in, the event.phase returns "login"





      </Returns>
      <Remarks>

        API not available in Corona Simulator.
        iOS: availability of the event.token started in 2011.712




      </Remarks>
    </facebook.login>
    <facebook.logout>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Logs the application out of the user's Facebook session.


      </Description>
      <Syntax>

        facebook.logout( )





      </Syntax>
      <Example>

        local facebook = require "facebook"
         
        -- listener for "fbconnect" events
        local function listener( event )
            if ( "session" == event.type ) then
                -- upon successful login, immediately logout
                if ( "login" == event.phase ) then
                    facebook.logout( )
                end
            end
        end
         
        -- first argument is the app id that you get from Facebook
        facebook.login( "1234567890", listener )





      </Example>
      <Parameters>

        none





      </Parameters>
      <Returns>

        The logout comes back in the form of a fbconnect event that is sent to a listener. This listener was registered during the login call.
        The event will have the following properties:
        event.name

        string: the name of the event "fbconnect"
        event.type

        string: the type of event "session"
        event.phase

        string: returns "logout"





      </Returns>
      <Remarks>

        API not available in Corona Simulator.
        Note: There is currently a bug in the Android build where event.type == "request" instead of "session" in the Facebook listener. (Case #6391 and verified in build 2011.539)




      </Remarks>
    </facebook.logout>
    <facebook.request>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Get or post data to the logged in Facebook account.
        Can be used to post messages and photos to the account and friends accounts. Can also be used to get user data and recent posts.


      </Description>
      <Syntax>

        facebook.request( path [, httpMethod, params] )





      </Syntax>
      <Example>

        local facebook = require "facebook"
         
        -- listener for "fbconnect" events
        local function listener( event )
            if ( "session" == event.type ) then
                -- upon successful login, request list of friends
                if ( "login" == event.phase ) then
                    facebook.request( "me/friends" )
                end
            elseif ( "request" == event.type ) then
                -- event.response is a JSON object from the FB server
                local response = event.response
                print( response )
            end
        end
         
        -- first argument is the app id that you get from Facebook
        facebook.login( "1234567890", listener, {"publish_stream"} )
        -- Example of how to upload a photo
        -- (NOTE: available starting in daily build 2011.709)
        local attachment = {
                message = "Corona Icon file",
                source = {
                        baseDir=system.DocumentsDirectory,
                        filename="coronaIcon.png",
                        type="image"
                },
        }
         
        facebook.request( "me/photos", "POST", attachment )





      </Example>
      <Parameters>

        path

        string: The Facebook API graph path.
        Examples of path are: "me", "me/friends", and "me/feed".
        httpMethod

        string: Optional parameter to specify "GET" or "POST".  If not specified, defaults to "GET"
        params

        table: Optional Lua table of key/value pairs that's passed as arguments to the Facebook API call. See the Publishing section on this the post page for a list of supported arguments.
        The following would be used to post a message to the user's account:

        facebook.request( "me/feed", "POST", {message = "Hello Facebook"} )





      </Parameters>
      <Returns>

        The request comes back in the form of a fbconnect event that is sent to a listener. This listener was registered during the call to facebook.login( ).
        The event will have the following properties:
        event.name

        string: the name of the event "fbconnect"
        event.type

        string: the type of event "request"
        event.response

        string: the JSON response from the Facebook server
        event.isError

        boolean: if an error occurred, this is true, nil/false otherwise. If true is returned, event.response contains the cause of the error.





      </Returns>
      <Remarks>

        API not available in Corona Simulator.




      </Remarks>
    </facebook.request>
    <facebook.showDialog>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Displays a Facebook UI dialog for publishing posts to a user's stream using only a few lines of code.
        This API is an easy way to add Facebook functionally to an application without the need to create a dialog box or handle the response.
        Note: This API pops up a Facebook UI that the user interacts with. Use facebook.request( ) if you need the application to do the posting.


      </Description>
      <Syntax>

        facebook.showDialog( params )





      </Syntax>
      <Example>

        local facebook = require "facebook"
         
        -- listener for "fbconnect" events
        local function listener( event )
            if ( "session" == event.type ) then
                -- upon successful login, request list of friends
                if ( "login" == event.phase ) then
                    facebook.showDialog( {action = "stream.publish"} )
                end
            elseif ( "dialog" == event.type ) then
                print( event.response )
            end
        end
         
        -- first argument is the app id that you get from Facebook
        facebook.login( "1234567890", listener )





      </Example>
      <Parameters>

        parms

        table: Lua table of key/value pairs that's passed as arguments to the Facebook API call. Currently the only support action is "stream.publish".





      </Parameters>
      <Returns>

        The response from the dialog comes back in the form of a fbconnect event that is sent to a listener. This listener was registered during the call to facebook.login( ).
        The event will have the following properties:
        event.name

        string: the name of the event "fbconnect"
        event.type

        string: the type of event "dialog"
        event.response

        string: the JSON response from the Facebook server
        event.isError

        boolean: if an error occurred, this is true, false otherwise.
        event.didComplete

        boolean: if the operation completed, this is true, false otherwise.





      </Returns>
      <Remarks>

        API not available in Corona Simulator.




      </Remarks>
    </facebook.showDialog>
  </Facebook>
  <File_IO />
  <Explicitfilemanipulation>
    <file..close>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Closes the open file.
        Note that files are automatically closed when their handles are garbage collected, but that takes an unpredictable amount of time to happen.


      </Description>
      <Syntax>


        file:close()

      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory )
         
        -- io.open opens a file at path. returns nil if no file found
        local fh, errStr = io.open( path, "r" )
         
        if fh then
           -- read all contents of file into a string
           local contents = fh:read( "*a" )
           print( "Contents of " .. path .. "\n" .. contents )
        else
           print( "Reason open failed: " .. errStr )  -- display failure message in terminal
        end
         
        fh:close()





      </Example>
      <Parameters>

        file
        Handle of file (from io.open) to be closed.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </file..close>
    <file..flush>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Commits the file's output buffer. Saves any written data to the file.


      </Description>
      <Syntax>

        file:flush()





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory  )
        local fh, errStr = io.open( path, "w" )  -- open/create for write
         
        if not fh then
                print( "Open error: " .. errStr )
        end
         
        -- The flush call is not really needed in this example but would be good
        -- if there is a long time from when data is written and the file closed.
        --
        fh:write( "Line 1\n" )
        fh:flush()  -- save the data
         
        fh:write( "Line 2\n" )
        fh:flush()  -- save the data
         
        fh:write( "Line 3\n" )
         
        fh:close() -- save all the data and close the file





      </Example>
      <Parameters>

        file
        File handle of open file to be flushed.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </file..flush>
    <file..lines>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns an iterator function that, each time it is called, returns a new line from the file.
        This function is similar to io.lines(file) except the file must be open first (with io.open) and does not automatically close at the end of the file.


      </Description>
      <Syntax>

        file:lines()





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory  )
        local fh = io.open( path )
         
        for line in fh:lines() do
            print( line )  -- display the line in the terminal
        end
         
        fh:close()





      </Example>
      <Parameters>

        file
        File handle.





      </Parameters>
      <Returns>

        Iterator function that, each time it is called, returns a new line from the file.





      </Returns>
      <Remarks>





      </Remarks>
    </file..lines>
    <file..read>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Reads the file file, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line.


      </Description>
      <Syntax>

        file:read( [fmt1] [, fmt2] [, ...] )





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory )
         
        -- io.open opens a file at path. returns nil if no file found
        local fh, reason = io.open( path, "r" )
         
        if fh then
           -- read all contents of file into a string
           local contents = fh:read( "*a" )
           print( "Contents of " .. path .. "\n" .. contents )
        else
           print( "Reason open failed: " .. reason )  -- display failure message in terminal
         
           -- create file because it doesn't exist yet
           fh = io.open( path, "w" )
           
           if fh then
                print( "Created file" )
           else
                print( "Create file failed!" )
           end
           
           local numbers = {1,2,3,4,5,6,7,8,9}
           fh:write( "Feed me data!\n", numbers[1], numbers[2], "\n" )
           
           for _,v in ipairs( numbers ) do
               fh:write( v, " " )
           end
           
           fh:write( "\nNo more data\n" )
        end
         
        io.close( fh )





      </Example>
      <Parameters>

        file
        File handle.
        fmt1, fmt2, ...
        The available formats are:
        "*n": reads a number; this is the only format that returns a number instead of a string.
        "*a": reads the whole file, starting at the current position. On end of file, it returns the empty string.
        "*l": reads the next line (skipping the end of line), returning nil on end of file. This is the default format (if no format string is found).
        number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file.
        Note: Defaults to "*l" (read next line) if format parameter is missing.





      </Parameters>
      <Returns>

        String or number or nil if it cannot read data with the specified format.





      </Returns>
      <Remarks>





      </Remarks>
    </file..read>
    <file..seek>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets and gets the file position, measured from the beginning of the file, to the position given by offset plus a base.
        The function can be used to get the current file position ("cur") or "set" the file position to the beginning, end, or any position in-between.


      </Description>
      <Syntax>

        file:seek( [mode] [, offset] )





      </Syntax>
      <Example>

        local fh = io.tmpfile()
        fh:write( "My temporary file data" )
        fh:flush()  -- ensure data written to file
         
        print( "file position: ", fh:seek() )  -- show current position
        fh:seek( "set", 0 )  -- reset file position to beginning
        local content = fh:read( "*a" )  -- read all the file
        print( "File content: " .. content )
        print( "file position: ", fh:seek("end") ) -- show the end position of file





      </Example>
      <Parameters>

        mode
        "set": base is position 0 (beginning of the file);

        "cur": base is current position (default);

        "end": base is end of file;
        The default value for mode is "cur", and for offset is 0. Therefore, the call file:seek() returns the current file position, without changing it; the call file:seek("set") sets the position to the beginning of the file (and returns 0); and the call file:seek("end") sets the position to the end of the file, and returns its size.
        offset
        Optional number to specify the position for the "set" mode. The number is "0" based (which is the beginning of the file).





      </Parameters>
      <Returns>

        In case of success, the function returns the file position, measured in bytes from the beginning of the file. If this function fails, it returns nil, plus a string describing the error.





      </Returns>
      <Remarks>





      </Remarks>
    </file..seek>
    <file..setvbuf>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the buffering mode for an output file (or console).
        This function can be used to control buffering of file writes and console output. When buffering is disabled on console output (print and io.writes), the information (debug data) is displayed instantly on the Xcode console and console.app (for iPhone/iPad simulator).
        Note: disabling buffering can affect the performance of the app. The flushing of the buffer can be performed anytime by the io.flush function.


      </Description>
      <Syntax>

        file:setvbuf( mode [, size] )





      </Syntax>
      <Example>

        -- The following will disable buffering for "print" and "io.write" to the console
        io.output():setvbuf('no')  -- disable output buffering for Xcode Console





      </Example>
      <Parameters>

        mode
        There are three available modes:
        "no": no buffering; the result of any output operation appears immediately.

        "full": full buffering; output operation is performed only when the buffer is full (or when you explicitly flush the file (see io.flush)).

        "line": line buffering; output is buffered until a newline is output or there is any input from some special files (such as a terminal device).
        For the last two cases, size specifies the size of the buffer, in bytes. The default is an appropriate size.
        size
        Specifies the size of the buffer, in bytes.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>





      </Remarks>
    </file..setvbuf>
    <file..write>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write other values, use tostring or string.format before write.
        Note: For security reasons you are not allowed to write files in the system.ResourceDirectory (the directory where the application is stored). You must specify the system.DocumentsDirectory or system.TemporaryDirectory parameter in system.pathForFile function when opening the file for writing. See io.open.


      </Description>
      <Syntax>

        file:write( arg1 [, arg2] [, ...] )





      </Syntax>
      <Example>

        local function copyFile( srcName, srcPath, dstName, dstPath, overwrite )
         
            local results = true                -- assume no errors
         
            -- Copy the source file to the destination file
            --
            local rfilePath = system.pathForFile( srcName, srcPath )
            local wfilePath = system.pathForFile( dstName, dstPath )
         
            local rfh = io.open( rfilePath, "rb" )             
            local wfh = io.open( wfilePath, "wb" )
               
            if  not wfh then
                print( "writeFileName open error!" )
                results = false                 -- error
            else
                -- Read the file from the Resource directory and write it to the destination directory
                local data = rfh:read( "*a" )
                       
                if not data then
                    print( "read error!" )
                    results = false     -- error
                else
                    if not wfh:write( data ) then
                        print( "write error!" )
                        results = false -- error
                    end
                end
            end
               
                -- Clean up our file handles
                rfh:close()
                wfh:close()
         
                return results 
        end
         
        -- Copy file from Resource dir to /Documents dir
        copyFile( "Icon.png", system.ResourceDirectory, "NewIcon.png", system.DocumentsDirectory )





      </Example>
      <Parameters>

        file
        File handle.
        arg1, arg2, ...
        One or more string or number arguments (separate by commas).





      </Parameters>
      <Returns>

        Nil if error writing file.





      </Returns>
      <Remarks>





      </Remarks>
    </file..write>
  </Explicitfilemanipulation>
  <Implicitfilemanipulation>
    <io.close>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Closes the open file. Equivalent to file:close().
        Without a file handle, closes the default output file.


      </Description>
      <Syntax>

        io.close( [file] )





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory )
         
        -- io.open opens a file at path. returns nil if no file found
        local fh, errStr = io.open( path, "r" )
         
        if fh then
           -- read all contents of file into a string
           local contents = fh:read( "*a" )
           print( "Contents of " .. path .. "\n" .. contents )
        else
           print( "Reason open failed: " .. errStr )  -- display failure message in terminal
        end
         
        io.close( fh )





      </Example>
      <Parameters>

        file
        Handle of file (from io.open) to be closed.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </io.close>
    <io.flush>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Flushes the default output file. Equivalent to io.output():flush.
        If io.output has not been changed from it's default output (stdout), this will flush any io.write or print data to the Corona Terminal, Xcode Console, or consol.app.


      </Description>
      <Syntax>

        io.flush()





      </Syntax>
      <Example>

        io.write( "My console data\n" ) -- write the string to console
        io.write( "My console data 2\n" ) -- write the string to console
         
        io.flush()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </io.flush>
    <io.input>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the standard input file. When called with a file name, it opens the named file (in text mode), and sets its handle as the default input file. When called with a file handle, it simply sets this file handle as the default input file. When called without parameters, it returns the current default input file.
        By default the default input is stdin, which is the Corona Terminal.
        In case of errors this function raises the error, instead of returning an error code.


      </Description>
      <Syntax>

        io.input( [file] )





      </Syntax>
      <Example>

        local tmp = io.input()    -- save current file handle
        io.input( "newfile.txt" ) -- open new file in text mode
         
        print( io.read() )        -- read and display the file
         
        io.input():close()        -- close the file
        io.input( tmp )           -- restore the previous file





      </Example>
      <Parameters>

        file
        Optional file name or file handle.





      </Parameters>
      <Returns>

        File handle of the just opened file or the handle to the current input file handle.





      </Returns>
      <Remarks>





      </Remarks>
    </io.input>
    <io.lines>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Opens the given file name in read mode and returns an iterator function that, each time it is called, returns a new line from the file.
        The function will open the file and iterate over all lines of the file. When the iterator function detects the end of file, it returns nil (to finish the loop) and automatically closes the file.
        The call io.lines() (with no file name) is similar to io.input():lines(); that is, it iterates over the lines of the default input file, except it does not close the file when the loop ends.


      </Description>
      <Syntax>


        io.lines( filename )





      </Syntax>
      <Example>

        for line in io.lines( "data.txt" ) do
            print( line )  -- display the line in the terminal
        end





      </Example>
      <Parameters>

        filename
        File name to be read.





      </Parameters>
      <Returns>

        Iterator function that, each time it is called, returns a new line from the file.





      </Returns>
      <Remarks>





      </Remarks>
    </io.lines>
    <io.open>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This function opens a file for reading or writing, in the string (default) or binary mode. It returns a new file handle, or, in case of errors, nil plus an error message. This function can also be used to create a new file.
        Note: For security reasons you are not allowed to write files in the system.ResourceDirectory (the directory where the application is stored). You must specify the system.DocumentsDirectory or system.TemporaryDirectory parameter in system.pathForFile function when opening the file for writing.


      </Description>
      <Syntax>


        io.open( filename_path, [, mode] )





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory )
         
        -- io.open opens a file at path. returns nil if no file found
        local fh, errStr = io.open( path, "r" )
         
        if fh then
           -- read all contents of file into a string
           local contents = fh:read( "*a" )
           print( "Contents of " .. path .. "\n" .. contents )
        else
           print( "Reason open failed: " .. errStr )  -- display failure message in terminal
         
           -- create file because it doesn't exist yet
           fh = io.open( path, "w" )
           
           if fh then
                print( "Created file" )
           else
                print( "Create file failed!" )
           end
           
           local numbers = {1,2,3,4,5,6,7,8,9}
           fh:write( "Feed me data!\n", numbers[1], numbers[2], "\n" )
           
           for _,v in ipairs( numbers ) do
               fh:write( v, " " )
           end
           
           fh:write( "\nNo more data\n" )
        end
         
        io.close( fh )





      </Example>
      <Parameters>

        filename_path
        File name (with path) to be opened. You must use system.pathForFile to create a file name and path to the Resource, Documents or Temporary directories. (See the example above.)
        mode
        The mode string can be any of the following:
        "r": read mode (the default); The file pointer is placed at the beginning of the file.
        "w": write-only mode; Overwrites the file if the file exists. If the file does not exist, creates a new file for writing.
        "a": append mode (write only); The file pointer is at the end of the file if the file exists. That is, the file is in the append mode. If the file does not exist, it creates a new file for writing.
        "r+": update mode (read/write), all previous data is preserved; The file pointer will be at the beginning of the file. If the file exists, it will only be overwritten if you explicitly write to it.
        "w+": update mode (read/write), all previous data is erased; Overwrites the existing file if the file exists. If the file does not exist, creates a new file for reading and writing.
        "a+": append update mode (read/write); previous data is preserved, writing is only allowed at the end of file. The file pointer is at the end of the file if the file exists. The file opens in the append mode. If the file does not exist, it creates a new file for reading and writing.
        The mode string can also have a 'b' at the end, which is needed in some systems to open the file in binary mode. This string is exactly what is used in the standard C function fopen.





      </Parameters>
      <Returns>

        Returns file handle if file found and opened, otherwise returns nil.

        Also returns string with reason for failure. Returns nil in place of string if file opened.





      </Returns>
      <Remarks>





      </Remarks>
    </io.open>
    <io.output>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the standard output file. When called with a file name, it opens the named file (in text mode), and sets its handle as the default output file. When called with a file handle, it simply sets this file handle as the default output file. When called without parameters, it returns the current default output file.
        By default the default output is stdout, which is the Corona Terminal.

        Similar to io.input, but operates over the default output file.


      </Description>
      <Syntax>


        io.output( [file] )





      </Syntax>
      <Example>

        local tmp = io.output()    -- save current file handle
        local path = system.pathForFile( "newFile.txt", system.DocumentsDirectory  )
        io.output( path )  -- open new file in text mode
         
        io.write( "My real data" ) -- write the file
         
        io.output():close()        -- close the file
        io.output( tmp )           -- restore the previous file





      </Example>
      <Parameters>

        file
        Optional file name or file handle.





      </Parameters>
      <Returns>

        File handle of the just opened file or the handle to the current input file handle.





      </Returns>
      <Remarks>





      </Remarks>
    </io.output>
    <io.read>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Reads the file set by io.input, according to the given formats, which specify what to read. For each format, the function returns a string (or a number) with the characters read, or nil if it cannot read data with the specified format. When called without formats, it uses a default format that reads the entire next line.
        In the normal mode this function reads from the standard input (stdin), which defaults to the Corona Terminal if io.input has not be called with a file name. This is equivalent to io.input():read.
        If you are reading data from a file, file:read should be used instead of io.read.


      </Description>
      <Syntax>


        io.read( [fmt1] [, fmt2] [, ...] )





      </Syntax>
      <Example>

        -- This samples shows how to do I/O on the Corona Terminal using io.read and io.write
         
        -- Prompt the user on the terminal
        io.write( "Enter you age: " )
         
        -- User enters answer on the terminal
        local answer = io.read()
         
        -- Display the answer on the terminal
        io.write( "Your age is ", answer, "\n" )





      </Example>
      <Parameters>

        fmt1, fmt2, ...
        The available formats are:
        "*n": reads a number; this is the only format that returns a number instead of a string.
        "*a": reads the whole file, starting at the current position. On end of file, it returns the empty string.
        "*l": reads the next line (skipping the end of line), returning nil on end of file. This is the default format.
        number: reads a string with up to this number of characters, returning nil on end of file. If number is zero, it reads nothing and returns an empty string, or nil on end of file.





      </Parameters>
      <Returns>

        String or number or nil if it cannot read data with the specified format.





      </Returns>
      <Remarks>





      </Remarks>
    </io.read>
    <io.tmpfile>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Opens a temporary file for reading and writing and returns a handle to it. When the app ends normally, this file will be deleted.
        Note: Calling this function creates an empty file. Use the file:seek function to reset the position in the file for reading back the data. The data will be lost if you close and call io.tmpfile to open it again.


      </Description>
      <Syntax>


        io.tmpfile()





      </Syntax>
      <Example>

        local fh = io.tmpfile()  -- create an empty temporary file
        fh:write( "My temporary file data" )
        fh:flush()  -- ensure data written to file
        print( "file position: ", fh:seek() )
         
        fh:seek( "set", 0 )  -- reset file position
        local content = fh:read( "*a" )  -- read all the file
        print( "File content: " .. content )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        A file handle to the open file.





      </Returns>
      <Remarks>

        tmpfile() seems to always return nil on Android. Android seems to discourage the use of this function for both sandboxing and partition space issues.




      </Remarks>
    </io.tmpfile>
    <io.type>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Checks whether obj is a valid file handle. Returns the string "file" if obj is an open file handle, "closed file" if obj is a closed file handle, or nil if obj is not a file handle.


      </Description>
      <Syntax>


        io.type( obj )





      </Syntax>
      <Example>

        local fh                -- variable for the file handle
        print( io.type( fh ) )  -- prints nil
         
        local path = system.pathForFile( "Icon.png", system.ResourceDirectory )
        fh = io.open( path )
        print( io.type( fh ) ) -- prints "file"
         
        io.close( fh )
        print( io.type( fh ) ) -- prints "closed file"





      </Example>
      <Parameters>

        obj
        Object to be tested (file handle).





      </Parameters>
      <Returns>

        String -- Returns "file" if obj is an open file handle, "closed file" if obj is a closed file handle, or nil if obj is not a file handle.





      </Returns>
      <Remarks>





      </Remarks>
    </io.type>
    <io.write>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Writes the value of each of its arguments to the file. The arguments must be strings or numbers. To write other values, use tostring or string.format before write.
        In the normal mode this function writes to the standard output (stdout), which defaults to the Corona Terminal if io.output has not be called with a file name. This is equivalent to io.output():write.
        If you are writing data to a file, file:write should be used instead of io.write.
        Note: For security reasons you are not allowed to write files in the system.ResourceDirectory (the directory where the application is stored). You must specify the system.DocumentsDirectory or system.TemporaryDirectory parameter in system.pathForFile function when opening the file for writing. See io.open.


      </Description>
      <Syntax>


        io.write( arg1 [, arg2] [, ...] )





      </Syntax>
      <Example>


        -- This samples shows how to do I/O on the Corona Terminal using io.read and io.write
         
        -- Prompt the user on the terminal
        io.write( "Enter you age: " )
         
        -- User enters answer on the terminal
        local answer = io.read()
         
        -- Display the answer on the terminal
        io.write( "Your age is ", answer, "\n" )





      </Example>
      <Parameters>

        arg1, arg2, ...
        One or more string or number arguments (separate by commas).





      </Parameters>
      <Returns>

        Nil if error writing file.





      </Returns>
      <Remarks>





      </Remarks>
    </io.write>
  </Implicitfilemanipulation>
  <Game_Network>
    <gameNetwork.init>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Initializes an app with the parameters (e.g., product key, secret, display name, etc.) required by the game network provider.
        For more information about Papaya visit the Corona Dashboard. (Papaya is only available for Android.)
        Note: Adding "require gameNetwork" to your code will enable Corona Launchpad regardless of the setting in config.lua.


      </Description>
      <Syntax>

        gameNetwork.init( providerName [, parms ...] )
         
      </Syntax>
      <Example>

        local gameNetwork = require "gameNetwork"
         
        --For OpenFeint:
        gameNetwork.init( "openfeint", "product-key", "secret", "display name", "appId" )
        gameNetwork.show( "leaderboards" )
         
        --For Papaya:
        gameNetwork.init( "papaya", "papayaSocialKey" )
        gameNetwork.show( "leaderboards" )
         
        -- For GameCenter:
        -- It's recommended you call gameNetwork.init() on every
        -- "applicationStart" system event.
         
        local function initCallback( event )
            if event.data then
                native.showAlert( "Success!", "", { "OK" } )
            end
        end
         
        local function onSystemEvent( event )
            if event.type == "applicationStart" then
                gameNetwork.init( "gamecenter", {listener=initCallback} )
                return true
            end
        end
        Runtime:addEventListener( "system", onSystemEvent )





      </Example>
      <Parameters>

        providerName

        String of the game network provider. ("openfeint", "papaya", or "gamecenter")
        parms

        Additional parameters required by the "openfeint" provider.

        product-key: String of your application's OpenFeint product key (provided by OpenFeint).
        secret: String of your application's product secret  (provided by OpenFeint).
        display name: String of the name to display in OpenFeint leaderboards and other views.
        appId: String of the spplication id (provided by OpenFeint).

        Additional parameter required by the "papaya" provider

        papayaSocialKey: String of your application's Papaya Social SDK Key (provided by Papaya).

        If using GameCenter, the second argument allows you to specify a callback function. (Instead of secret keys, your bundle identifier is used automatically to identify your app.) On successful login, event.data will be 'true'. On unsuccessful init, event.data will be false. When problems such as network errors occur, event.errorCode (integer) and event.errorMessage (string) will be defined.
        Also be aware that iOS backgrounding will cause your app to automatically log out your user from Game Center. When the app is resumed, Game Center will automatically try to re-login your user. The callback function you specified here will be invoked again telling you the result of that re-login attempt. Thus, this callback function exists for the life of your application. With Game Center, it is advisable to avoid calling other Game Center functions when the user is not logged in.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Papaya added in build 2011.591. (Android only)

        Papaya support removed as of build 2012.819. (Android only)
        GameCenter added in build 2012.725 (iOS only).
        Note: gameNetwork only supports one provider at a time (you cannot call this API multiple times for different providers).




      </Remarks>
    </gameNetwork.init>
    <gameNetwork.request>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Send or request information to/from the game network provider.


      </Description>
      <Syntax>

        gameNetwork.request( command [, parms ...] )





      </Syntax>
      <Example>

        local gameNetwork = require "gameNetwork"
         
        --For OpenFeint:
        gameNetwork.init( "openfeint", "product-key", "secret", "display name", "appId" )
         
        gameNetwork.request( "setHighScore", { leaderboardID="abc123", score=99, displayText="99 sec" } )
        gameNetwork.request( "unlockAchievement", "achievementId" )
        gameNetwork.request( "uploadBlob", key, data )
        gameNetwork.request( "downloadBlob", key, listener ) -- listener for "completion" event with "blob" key set.
        gameNetwork.show( "highscore", "abc123" )
        local gameNetwork = require "gameNetwork"
         
        --For Papaya (Android only):
        gameNetwork.init( "papaya", "papayaSocialKey" )
         
        gameNetwork.request( "setHighScore", { leaderboardID = "Level1", score = 321 } )
        gameNetwork.request( "unlockAchievement", " 184 " )
        local gameNetwork = require "gameNetwork"
         
        --For Game Center (iOS only):
        gameNetwork.init( "gamecenter", {listener=initCallback} )
         
        gameNetwork.request( "setHighScore",
        {
            localPlayerScore = { category="com.appledts.EasyTapList", value=25 },
            listener=requestCallback
        })
        gameNetwork.request( "resetAchievements", { listener=requestCallback } )





      </Example>
      <Parameters>

        command
        OpenFeint
        Strings supported by the OpenFeint provider:

        setHighScore
        unlockAchievement
        uploadBlob: (Not supported on Android)
        downloadBlob (Not supported on Android)

        parms
        Parmeters used in the above OpenFeint commands:
        setHighScore: { leaderboardID="abc123", score=99 [, displayText="99 sec"] }

        Note: Starting with Build 2012.815, for Game Center compatibility, 'category' may be used instead of 'leaderboardID' and 'value' may be used instead of 'score'.

        unlockAchievement: "achievementId"

        uploadBlob: "uploadBlob", key, data

        downloadBlob: key, [listener] ) -- listener for "completion" event with "blob" key set.
        The optional Listener for downloadBlob that is called when the "blob" string has been downloaded:

        event.name -- The name of the event, "completion".
        event.data or event.blob -- A string that contains the requested blob data. If the length of this string is 0, then the download failed. Note: In Build 2012.725, event.data was introduced as a universal generic field holding the return data. event.data and event.blob are references to the same data. Also note that starting in Build 2012.725, the event.name no longer returns "completion", but instead returns "gameNetwork" along with additional common fields for all gameNetwork event types. c

        Papaya (Android)
        Strings supported by the Papaya provider:

        setHighScore
        unlockAchievement

        parms
        Parmeters used in the above Papaya commands:
        setHighScore: { leaderboardID="abc123", score=99 }

        Note: Starting with Build 2012.815, for Game Center compatibility, 'category' may be used instead of 'leaderboardID' and 'value' may be used instead of 'score'.

        unlockAchievement: "achievementId"
        Game Center (iOS)
        Strings supported by the Game Center provider:

        setHighScore
        loadScores
        loadLocalPlayer
        loadPlayers
        loadFriends
        loadAchievements
        unlockAchievement
        resetAchievements
        loadAchievementDescriptions
        loadFriendRequestMaxNumberOfRecipients
        loadLeaderboardCategories
        loadPlayerPhoto
        loadAchievementImage
        loadPlaceholderCompletedAchievementImage
        loadIncompleteAchievementImage

        parms
        Parmeters used in the above Game Center commands:
        setHighScore:
        Sets a high score for the currently logged in user for the specified leaderboard (category). If the high score is not higher than the one currently on the server, the server will keep the highest value.
        This function corresponds to Apple's reportScoreWithCompletionHandler. The nomenclature deviates in this case to provide consistency with our existing gameNetwork APIs.
        Example "setHighScore" request:

        gameNetwork.request( "setHighScore",
        {
                localPlayerScore = { category="com.appledts.EasyTapList", value=25 },
                listener=requestCallback
        })
        'localPlayerScore' is a required table that corresponds to Apple's GKScore class.
        In the localPlayerScore table:
        'category' must be a string that matches the name of the board you want to register the score with as entered on iTunes Connect. (The name you pick need not follow the fully qualified reverse domain style shown here.) '
        'value' must be a number representing your score. Note that Apple allows for 64-bit integers, but all numbers in Lua are of type double. This means your max and min values are restricted to the range of double which is about 2^51 instead of 2^64.
        loadScores:
        event.data in callback listener is an array of items (tables) that have

        the following properties:

        playerID (string)
        category (string)
        value (number)
        context (number, iOS 5+ only)
        date (string)
        formattedValue (string)
        rank (integer)
        shouldSetDefaultLeaderboard (boolean, iOS 5+ only)

        Each item (table) in the array corresponds to  Apple's GKScore class.
        example:

        event.data[5].formattedValue	-- #event.data == 2nd value specified in range table
        event.localPlayerScore also has all of the above properties (not in an array). This table also corresponds to Apple's GKScore class.
        example:

        event.localPlayerScore.rank
        Warning: iOS 4 has a bug where event.localPlayerScore.category returns nil. This is fixed in iOS 5.
        Example "loadScores" request:

        gameNetwork.request( "loadScores",
        {
                leaderboard =
                {
                        category="com.appledts.EasyTapList",
                        playerScope="Global",   -- Global, FriendsOnly
                        timeScope="AllTime",    -- AllTime, Week, Today
                        range={1,5}
                },
                listener=requestCallback
        })
        'leaderboard' is a required table that corresponds to Apple's GKLeaderboard class.
        In the leaderboard table:
        'category' (required) must be a string that matches the name of the board you want to fetch the scores with as entered on iTunes Connect. (The name you pick need not follow the fully qualified reverse domain style shown here.) '
        'playerScope' (optional) is a string of either "Global" or "FriendsOnly". The latter setting will restrict the fetched scores to only friends.
        'timeScope' (optional) is a string of either "AllTime", "Week", "Today" which limits the fetched scores to the specified time range.
        'range' (optional) is an array of two values. The first value is that start index. The second value is the number of players to retrieve. Apple says this number must be less than 100. Apple's default range is {1,25}.
        loadLocalPlayer

        Requests the GKPlayer object for the currently logged-in user.
        event.data in callback listener includes the following properties:

        playerID (string)
        alias (string)
        isFriend (boolean)
        isAuthenticated (boolean)
        isUnderage (boolean)
        friends (array)

        This table corresponds to  Apple's GKLocalPlayer class. Each element in the friends array is a string representing a playerID.
        example:

        event.data.playerID
        Example "loadLocalPlayer" request:

        gameNetwork.request( "loadLocalPlayer", { listener=requestCallback } )
        Note: To guarantee the friends array is populated, Apple says you must call loadFriends before this. We have found that this necessary on iOS 4, but on iOS 5, we get the friends array regardless.
        loadPlayers
        Requests a list of players with the specified player IDs, and returns an array of items (tables) for each requested player in the callback listener.
        event.data in callback listener is an array of items that

        have the following properties:

        playerID (string)
        alias (string)
        isFriend (boolean)

        Each item (table) in the array corresponds to  Apple's GKPlayer class
        example:

        event.data[3].isFriend
        Example "loadPlayers" request:

        gameNetwork.request( "loadPlayers",
        {
                playerIDs =
                {
                        "G:123456789",
                        "G:1234567890",
                        "G:0123456789"
                },
                listener=requestCallback
        })
        loadFriends
        Requests the friends of the currently logged in user, and returns and array of tables for all friends in the callback listener.
        event.data in callback listener is an array of strings representing playerIDs.
        example:

        event.data[2].playerID
        Example "loadFriends" request:

        gameNetwork.request( "loadFriends", { listener=requestCallback } )
        loadAchievements
        Loads a list of the user's completed achievements for the app and returns an array of items (tables) representing each achievement in the callback listener.
        event.data in callback listener is an array of items that have the

        following properties (each representing an achievement):

        identifier (string)
        percentComplete (number)
        isCompleted (boolean)
        isHidden (boolean)
        lastReportedDate (string)
        showsCompletionBanner (boolean, iOS 5+ only, will be nil otherwise)

        Each item (table) in the array corresponds to  Apple's GKAchievement class.
        example:

        event.data[4].identifier
        Example "loadAchievements" request:

        gameNetwork.request( "loadAchievements", { listener=requestCallback } )
        unlockAchievement
        Unlocks the specified achievement (identifier) at the specified percentage. The showsCompletionBanner only takes affect if the achievement is 100% complete, and if the device is running iOS5 or higher.
        This function corresponds to Apple's reportAchievementWithCompletionHandler. The nomenclature deviates in this case to provide consistency with our existing gameNetwork APIs.
        Example "unlockAchievement" request.

        gameNetwork.request( "unlockAchievement",
        {
                achievement =
                {
                        identifier="com.appletest.one_tap",
                        percentComplete=100,
                        showsCompletionBanner=true,
                },
                listener=requestCallback
        })
        'achievement' is a required table that corresponds to Apple's GKAchievement class.
        In the "achievement" table:
        'identifier' (required) must be a string that matches the name of the achievement you want to unlock/report as entered on iTunes Connect. (The name you pick need not follow the fully qualified reverse domain style shown here.) '
        'percentComplete' (optional) must be a number representing the completion percentage of the achievement. 100  will fully unlock the achievement. If this field is omitted, it is assumed this value is 100.
        'showsCompletionBanner' (optional, iOS 5+ only) is a boolean which if set to true, will cause Apple to automatically show a completion banner for you in your app when the percentComplete reaches 100. This field is ignored on pre-iOS 5 OS's.
        The listener callback will fill event.data with a table that corresponds to the Apple GKAchievement class that you just unlocked. You may use this information to help identify which/any achievements that were successfully reported to the Game Center servers and which ones might have failed due to network timeouts.
        resetAchievements
        Resets all achievements for the currently logged-in user. Be careful, as there is no undoing this request. Once called, the user will have all achievements for this app reset to 0%.
        Example "resetAchievements" request:

        gameNetwork.request( "resetAchievements", { listener=requestCallback } )
        loadAchievementDescriptions
        Requests a list of all descriptions associated with the achievements for the app and returns an array of items (tables) representing each achievement description object in the callback listener.
        Each item (table) in the array corresponds to  Apple's GKAchievementDescription class.
        event.data in callback listener is an array of items which are the

        descriptions of your achievements.

        identifier (string)
        title (string)
        achievedDescription (string)
        unachievedDescription (string)
        maximumPoints (integer)
        isHidden (boolean)

        Example "loadAchievementDescriptions" request:

        gameNetwork.request( "loadAchievementDescriptions", { listener=requestCallback } )
        loadFriendRequestMaxNumberOfRecipients
        Apple imposes a maximum number of people you may invite in a single friendRequest. This function will allow you to retrieve that number so you may dynamically adapt your code to accommodate this value if it changes. As of this writing, this number is 3. The value will be returned through the callback listener (via event.data).
        Example "loadFriendRequestMaxNumberOfRecipients" request:

        gameNetwork.request( "loadFriendRequestMaxNumberOfRecipients", { listener=requestCallback } )
        loadLeaderboardCategories
        Requests a list of leaderboard categories for the app and returns an array of tables with each table containing description information of a leaderboard in the callback listener.
        event.data in callback listener is an array of items (tables) where each table contains the keys 'category' and 'title', both of which are strings.
        Example "loadLeaderboardCategories" request:

        gameNetwork.request( "loadLeaderboardCategories", { listener=requestCallback } )
         
        -- example of what an event.data table returned via callback listener looks like
        event.data =
        {
                [1] = {
                        category = "com.appledts.EasyTapList",
                        title = "Easy"
                },
                [2] = {
                        category = "com.appledts.HardTapList",
                        title = "Hard"
                },
                [3] = {
                        category = "com.appledts.AwesomeTapList",
                        title = "Awesome"
                },
        }
        loadPlayerPhoto (available starting with Build 2012.730, iOS5+ only)
        Retrieves the image of the requested player and creates a display object for it.
        Example "loadPlayerPhoto" request.

        gameNetwork.request( "loadPlayerPhoto",
        {
                playerID = "G:0123456789",
                size="Small", -- "Small" or "Normal"
                listener=requestCallback
        })
        'playerID' (required) is the Game Center player ID (string) of the player you want to fetch the image for.
        'size' (optional) represents the size of the image you want to get back. Supported values are "Small" and "Normal". "Small" is the default.
        The listener callback will fill event.data with a table that corresponds to the Apple GKPlayer class as you've seen with other APIs documented above. But unlike the other APIs one additional property is added, 'photo', which is the display object of the retrieved image.
        event.data in callback listener includes the following properties:

        playerID (string)
        alias (string)
        isFriend (boolean)
        isAuthenticated (boolean)
        isUnderage (boolean)
        friends (array)
        photo (display object)

        If called on pre-iOS5, the callback will be invoked and return errorCode=1 and errorMessage="This API is not available on this version of iOS."
        loadAchievementImage (available starting with Build 2012.730)
        Retrieves the image of the requested achievement and creates a display object for it.
        Example "loadAchievementImage" request.

        gameNetwork.request( "loadAchievementImage",
        {
                achievementDescription=
                {
                        identifier="com.appledts.twenty_taps"
                },
                listener=requestCallback
        })
        'achievementDescription' is a required table that corresponds to Apple's GKAchievementDescription class.
        In the "achievementDescription" table:
        'identifier' (required) must be a string that matches the name of the achievement you want to retrieve the image for. (The name you pick need not follow the fully qualified reverse domain style shown here.) '
        The listener callback will fill event.data with a table that corresponds to the Apple GKAchievementDescription  class as you've seen with other APIs documented above. But unlike the other APIs one additional property is added, 'image', which is the display object of the retrieved image.
        event.data in callback listener includes the following properties:

        identifier (string)
        title (string)
        achievedDescription (string)
        unachievedDescription (string)
        maximumPoints (integer)
        isHidden (boolean)
        image (display object)

        Remember to upload images to iTunes Connect that are compatible with Corona (e.g. don't used indexed color pngs, etc.)
        loadPlaceholderCompletedAchievementImage (available starting with Build 2012.730)
        Retrieves the Apple placeholder image of a completed achievement and creates a display object for it.
        Example "loadPlaceholderCompletedAchievementImage" request.

        gameNetwork.request( "loadPlaceholderCompletedAchievementImage",
        {
                listener=requestCallback
        })
        The listener callback will fill event.data with the display object of the image.
        loadIncompleteAchievementImage (available starting with Build 2012.730)
        Retrieves the Apple placeholder image of an incomplete achievement and creates a display object for it.
        Example "loadIncompleteAchievementImage" request.

        gameNetwork.request( "loadIncompleteAchievementImage",
        {
                listener=requestCallback
        })
        The listener callback will fill event.data with the display object of the image.
        For further property reference for the different objects (GKLeaderboard, GKAchievement, GKAchievementDescription, GKScore, GKPlayer, and GKLocalPlayer), please see the Official Game Kit Framework Reference.





      </Parameters>
      <Returns>

        Nothing.

        (See listener callback descriptions for data returned through callbacks.)





      </Returns>
      <Remarks>

        Note: This API replaces these deprecated OpenFeint APIs:

        openfeint.setHighScore, openfeint.unlockAchievement, openfeint.uploadBlob, openfeint.downloadBlob
        Papaya available starting with build 2011.591. (Android only)

        Papaya support removed as of build 2012.819. (Android only)

        Game Center available starting with build 2012.725 (iOS only)
        The following Game Center APIs are available starting with build 2012.730:

        loadPlayerPhoto

        loadAchievementImage

        loadPlaceholderCompletedAchievementImage

        loadIncompleteAchievementImage




      </Remarks>
    </gameNetwork.request>
    <gameNetwork.show>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Shows (displays) information from game network provider on the screen.
        For OpenFeint provider, launches the OpenFeint dashboard in one of the following configurations: leaderboards, challenges, achievements, friends, playing or high score.
        For Papaya provider, launches the Papaya dashboard in one of the following configurations: leaderboards, challenges, achievements, friends, avatar, chat, circles, or invites.


      </Description>
      <Syntax>

        gameNetwork.show( name [, data]  )





      </Syntax>
      <Example>

        local gameNetwork = require "gameNetwork"
         
        --For OpenFeint:
        gameNetwork.init( "openfeint", "product-key", "secret", "display name", "appId" )
        gameNetwork.show( "leaderboards" )
        gameNetwork.show( "highscore", "abc123" )
        local gameNetwork = require "gameNetwork"
         
        --For Papaya (Android-only):
        gameNetwork.init( "papaya", "papayaSocialKey" )
         
        gameNetwork.show( "leaderboards", " Level1" )
        gameNetwork.show( "leaderboards" )      -- Displays default leaderboard
        gameNetwork.show( "achievements" )
        gameNetwork.show( "avatar" )
        gameNetwork.show( "challenges" )
        gameNetwork.show( "chat" )
        gameNetwork.show( "circles" )
        gameNetwork.show( "friends" )
        gameNetwork.show( "invites" )
        local gameNetwork = require "gameNetwork"
         
        --For GameCenter (iOS-only):
        gameNetwork.init( "gamecenter", {listener=initCallback} )
         
        gameNetwork.show( "leaderboards", { leaderboard = {timeScope="Week"}, listener=dismissCallback } )
         
        gameNetwork.show( "achievements", { listener=dismissCallback } )
         
        gameNetwork.show( "friendRequest", { message="By my friend please", playerIDs={ "G:194669300", "G:1435127232" }, emailAddresses={ "me@me.com" },  listener=dismissCallback} )





      </Example>
      <Parameters>

        name

        Strings supported by the OpenFeint provider:

        "leaderboards"
        "challenges" (Not supported in Android).
        "achievements"
        "friends" (Not supported in Android).
        "playing" (Not supported in Android).
        "highscore" NOTE: in this case an additional data string is required (see below).  (Not supported in Android).

        For OpenFeint, calling gameNetwork.show without this parameter displays the OpenFeint Dashboard.
        Note: The items listed above that are not available on Android can still be viewed by going to the OpenFeint Dashboard.
        data

        String (if Game Center: table): When the OpenFeint dashboard view is "highscore", the string should contain the "leaderboardID" property whose value is the corresponding OpenFeint leaderboard id. Please see example above for data table format for Game Center network.
        Strings supported by the Papaya provider:

        "leaderboards"
        "leaderboards", "level"
        "challenges"
        "achievements"
        "friends"
        "avatar"
        "chat"
        "circles"
        "invites"

        Strings supported by the Game Center provider:

        "leaderboards"
        "achievements"
        "friendRequest"

        All APIs for Game Center support a table as an optional second parameter.

        "listener" is an optional key for all the APIs which you may assign a callback function.
        For "leaderboards", "leaderboard" is an optional key in the table parameter which takes a table. The table has key/value pairs that mimic the GKLeaderboard (and GKLeaderboardViewController) objects. The key "timeScope" may take one of the following strings:

        "Today"

        "Week"

        "AllTime"
        For "friendRequest", optional keys in the table parameter are:

        "message" which takes a string which allows you to prepopulate the message field with your own custom text.

        "playerIDs" takes an array of strings of Game Center playerIDs to players  you want to send a friend request to (which can be retrieved from gameNetwork.request() APIs).

        "emailAddresses" takes an array of strings which are email addresses of players you want to send friend requests to.

        Note: The total number of playerIDs and emailAddresses must not exceed the Game Center maximum limit or the OS will throw an exception. gameNetwork.request("loadFriendRequestMaxNumberOfRecipients" returns this number. As of this writing, the limit is 3.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: This replaces the depreciated openfeint.launchDashboard API.
        Do the following to close the OpenFeint Dashboard:

        On Android the Menu button shows a "Exit Feint" button that will exit back to the Corona App. You can also use the Back button to exit (this will go through all the navigated OpenFeint screens and finally exit OpenFeint).
        On iOS, there is an "x" in the upper right coroner of the OpenFeint screen that closes the Dashboard.
        Papaya available starting with build 2011.591.

        Papaya support removed as of build 2012.819.




      </Remarks>
    </gameNetwork.show>
  </Game_Network>
  <Graphics>
    <graphics.newGradient>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a gradient object that adds horizontal/vertical linear gradients to rectangle and text objects.
        The gradient starts with color1 and goes to color2. Both color1 and color2 are table arrays.


      </Description>
      <Syntax>

        local g = graphics.newGradient( color1, color2 [ , direction] )





      </Syntax>
      <Example>

        local g = graphics.newGradient(
          { 255, 255, 255 },
          { 200, 200, 200 },
          "down" )
         
        -- sets gradient 'g' on rect
        local rect = display.newRect( 0, 0, 100, 200 )
        rect:setFillColor( g )
         
        -- sets gradient 'g' on text
        local text = display.newText("Hello World!", 0, 0, native.systemFont, 16)
        text:setTextColor( g )





      </Example>
      <Parameters>

        color1

        Table array with the starting gradient color.
        The table format for both color1 and color2 can be one of the following:

        { gray }

        { gray, alpha }

        { red, green, blue }

        { red, green, blue, alpha }
        Gray, alpha, red, green, and blue are values in the range of 0 to 255.
        color2

        Table array with the ending gradient color.
        direction

        String containing the gradient direction. Defaults to "down" if not supplied.
        "up" gradient starts at bottom and goes to the top

        "down" gradient starts at the top and goes to the bottom (default)

        "left" gradient starts at the right and goes to the left

        "right" gradient starts at the left and goes to the right





      </Parameters>
      <Returns>

        Gradient Object

        Returns a gradient object that is used with object:setFillColor and object:setTextColor.





      </Returns>
      <Remarks>

        Gradients do not work with display.newCircle, display.newRoundedRect, or display.newGroup.




      </Remarks>
    </graphics.newGradient>
    <graphics.newMask>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a bit mask from an image file. The image is converted internally to grayscale; black values are then masked, while white values are not.
        The white pixels of the bit mask allow the covered image to be visible. Black pixels hide (mask) the covered image. The area outside of the mask is filled with black pixels which mask off the area outside the bit mask image.
        Note: Bit Mask Requirements

        1. The mask image width and height must be multiples of 4.

        2. The mask image must have a black border around the mask that is 3 or more pixels.
        Starting with build 2011.502, you can nest bit masks objects using display groups. You can put one or more masked objects into a display group and add a mask to the display group. You can nest masked display groups up to the limits of the device.
        For a walk-through on how to use bitmap masks, see the following tutorial:

        http://developer.anscamobile.com/reference/index/graphicsnewmask


      </Description>
      <Syntax>

        local mask = graphics.newMask( filename [, baseDir] )





      </Syntax>
      <Example>


        This sample code uses images from the Graphics/Flashlight sample in the Corona SDK. It applies a mask to the image and then scales the mask to twice its original size.
        -- Create and position image to be masked
        local image = display.newImageRect( "image.png", 768, 1024 )
        image:translate( display.contentCenterX, display.contentCenterY )
         
        -- Create mask and apply to image
        local mask = graphics.newMask( "circlemask.png" )
        image:setMask( mask )
         
        -- Transform mask
        image.maskScaleX, image.maskScaleY = 2,2

        Here is an example of how to add a bit mask to a display group. It uses the assets from the X-Ray sample code.

        local g = display.newGroup()
         
        local bar = display.newImage( g, "paper_bkg.png" ) -- create and add to group
         
        local mask = graphics.newMask("circlemask.png")
         
        g:setMask(mask)
         
        -- Center the mask over the Display Group
        g:setReferencePoint( display.CenterReferencePoint )
        g.maskX = g.x
        g.maskY = g.y





      </Example>
      <Parameters>

        filename

        String: The name of the image file to create the mask from.
        baseDir

        String: Specifies the directory path that contains the mask image.





      </Parameters>
      <Returns>

        Userdata

        A mask object that can be applied to any display object using object:setMask()





      </Returns>
      <Remarks>

        Prior to build 2011.510, masking an image does not affect the touch (or tap) area so touch events will happen for areas of the image that is masked off. If you need touch events to happen only on the masked portion of the object, you will need to create a "hidden" object that tracks the position and size of the masked object and set this as the touch target. The hidden object can be a newRect or newCircle with the alpha property set to 0.0 (so it doesn't show).
        Starting with build 2011.510, only the masked portion of the object is affected by touch/tap.  Note, however, that the touch sensitive area still corresponds to the mask image shape and is therefore always rectangular, regardless of the actual image!  This masking can be disabled with the object.isHitTestMasked property; see the Flashlight sample project.




      </Remarks>
    </graphics.newMask>
  </Graphics>
  <In-App_Purchases>
    <store.finishTransaction>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Notifies the App Store that a transaction is complete.
        After you finish handling a transaction, you must call store.finishTransaction() on the transaction object. If you don't do this, the App Store will think your transaction was interrupted and will attempt to resume it on the next application launch.


      </Description>
      <Syntax>

        store.finishTransaction( transaction )





      </Syntax>
      <Example>

        store.finishTransaction( transaction )





      </Example>
      <Parameters>

        transaction

        object: The transaction object belonging to the transaction you want to mark as finished.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </store.finishTransaction>
    <store.init>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Activates In-App Purchases.
        Starts up the In-App Purchase engine and allows you to receive callbacks with the listener function you specify.


      </Description>
      <Syntax>

        store.init( listener )





      </Syntax>
      <Example>

        store = require("store")
         
        function transactionCallback( event )
                local transaction = event.transaction
                if transaction.state == "purchased" then
                        print("Transaction succuessful!")
                        print("productIdentifier", transaction.productIdentifier)
                        print("receipt", transaction.receipt)
                        print("transactionIdentifier", transaction.identifier)
                        print("date", transaction.date)
         
                elseif  transaction.state == "restored" then
                        print("Transaction restored (from previous session)")
                        print("productIdentifier", transaction.productIdentifier)
                        print("receipt", transaction.receipt)
                        print("transactionIdentifier", transaction.identifier)
                        print("date", transaction.date)
                        print("originalReceipt", transaction.originalReceipt)
                        print("originalTransactionIdentifier", transaction.originalIdentifier)
                        print("originalDate", transaction.originalDate)
         
                elseif transaction.state == "cancelled" then
                        print("User cancelled transaction")
         
                elseif transaction.state == "failed" then
                        print("Transaction failed, type:", transaction.errorType, transaction.errorString)
         
                else
                        print("unknown event")
                end
         
                -- Once we are done with a transaction, call this to tell the store
                -- we are done with the transaction.
                -- If you are providing downloadable content, wait to call this until
                -- after the download completes.
                store.finishTransaction( transaction )
        end
         
        store.init( transactionCallback )





      </Example>
      <Parameters>

        listener

        function: This is the listener that will handle transaction callback events.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </store.init>
    <store.loadProducts>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Retrieves information about items available for sale.

        This includes the price of each item, a localized name, and a localized description.


      </Description>
      <Syntax>

        store.loadProducts( arrayOfProductIdentifiers, listener )





      </Syntax>
      <Example>

        local listOfProducts =
        {
                "com.anscamobile.NewExampleInAppPurchase.ConsumableTier1",
                "com.anscamobile.NewExampleInAppPurchase.NonConsumableTier1",
                "com.anscamobile.NewExampleInAppPurchase.SubscriptionTier1",
        --      "bad.product.id",
        }
         
        function productCallback( event )
                print("showing valid products", #event.products)
                for i=1, #event.products do
                        print(event.products[i].title)    -- This is a string.
                        print(event.products[i].description)    -- This is a string.
                        print(event.products[i].price)    -- This is a number.
                        print(event.products[i].localizedPrice)    -- This is a string.
                        print(event.products[i].productIdentifier)    -- This is a string.
                end
         
                print("showing invalidProducts", #event.invalidProducts)
                for i=1, #event.invalidProducts do
                        print(event.invalidProducts[i])
                end
        end
         
        store.loadProducts( listOfProducts, productCallback )





      </Example>
      <Parameters>

        listOfProducts

        array: A Lua array with each element containing a string which is the product identifier of the in-app item you want to know about.
        productList

        function: A callback function that is invoked when the store finishes retrieving the product information.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760
        Sample code for both iOS and Android is available in the Corona SDK at Samples/Networking/InAppPurchase




      </Remarks>
    </store.loadProducts>
    <store.purchase>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Initiates a purchase transaction on a provided list of products.
        This function will send out purchase requests to the store. The listener you specified in store.init() will be invoked when the store finishes processing the transaction.


      </Description>
      <Syntax>

        store.purchase( arrayOfProducts )





      </Syntax>
      <Example>

        store = require("store")
         
        function storeTransaction( event )
                local transaction = event.transaction
                if transaction.state == "purchased" then
                        -- If store.purchase() was successful, you should end up in here for each product you buy.
                        print("Transaction succuessful!")
                        print("productIdentifier", transaction.productIdentifier)
                        print("receipt", transaction.receipt)
                        print("transactionIdentifier", transaction.identifier)
                        print("date", transaction.date)
         
                elseif  transaction.state == "restored" then
                        print("Transaction restored (from previous session)")
         
                elseif transaction.state == "cancelled" then
                        print("User cancelled transaction")
         
                elseif transaction.state == "failed" then
                        print("Transaction failed, type:", transaction.errorType, transaction.errorString)
         
                else
                        print("unknown event")
                end
         
                -- Once we are done with a transaction, call this to tell the store
                -- we are done with the transaction.
                -- If you are providing downloadable content, wait to call this until
                -- after the download completes.
                store.finishTransaction( transaction )
        end
         
        store.init( storeTransaction )
         
        store.purchase( {"com.anscamobile.NewExampleInAppPurchase.NonConsumableTier1"} )





      </Example>
      <Parameters>

        arrayOfProducts

        A Lua array specifying the products you want to buy. Each element may contain a string which is the product identifier or a Lua table with the same fields as the product elements passed back to you from the event.products array in the loadProductsCallback listener.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Currently, there is no explicit API to specify quantities for consumable items. However, as a backdoor, you may place the product in the array multiple times and Corona will set the quantity behind the scenes.
        With the Apple App Store, each product will trigger a separate callback event.
        Note: Google's Android Market was added starting with build 2012.760




      </Remarks>
    </store.purchase>
    <store.restore>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Users who wipe the information on a device or buy a new device, may wish to restore previously purchased items without paying for them again. The store.restore() API initiates this process. Transactions that can be restored will be invoked on your transactionCallback listener which you registered with store.init(). The transaction state will be "restored" in this case and your app may then make use of the originalReceipt, originalIdentifier, and originalDate fields of the transaction object.


      </Description>
      <Syntax>

        store.restore()





      </Syntax>
      <Example>

        store = require("store")
         
        function transactionCallback( event )
                local transaction = event.transaction
                if transaction.state == "purchased" then
                        print("Transaction succuessful!")
         
                elseif  transaction.state == "restored" then
                        -- store.restore() will trigger this case
                        print("Transaction restored (from previous session)")
                        print("productIdentifier", transaction.productIdentifier)
                        print("receipt", transaction.receipt)
                        print("transactionIdentifier", transaction.identifier)
                        print("date", transaction.date)
                        print("originalReceipt", transaction.originalReceipt)
                        print("originalTransactionIdentifier", transaction.originalIdentifier)
                        print("originalDate", transaction.originalDate)
         
                elseif transaction.state == "cancelled" then
                        print("User cancelled transaction")
         
                elseif transaction.state == "failed" then
                        print("Transaction failed, type:", transaction.errorType, transaction.errorString)
         
                else
                        print("unknown event")
                end
         
                -- Once we are done with a transaction, call this to tell the store
                -- we are done with the transaction.
                -- If you are providing downloadable content, wait to call this until
                -- after the download completes.
                store.finishTransaction( transaction )
        end
         
        store.init( transactionCallback )
        store.restore()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Google's Android Market was added starting with build 2012.760




      </Remarks>
    </store.restore>
  </In-App_Purchases>
  <JSON>
    <json.decode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Decodes the JSON encoded data structure, and returns a Lua object (table) with the appropriate data.


      </Description>
      <Syntax>

        value = json.decode( s )





      </Syntax>
      <Example>

        local json = require "json"
         
         -- Lua script:
         local t = {
            ["name1"] = "value1",
            ["name2"] = {1, false, true, 23.54, "a \021 string"},
            name3 = json.null()
         }
         
         local value = json.encode (t)
         print (value)  --&gt; {"name1":"value1","name3":null,"name2":[1,false,true,23.54,"a \u0015 string"]}
         
         local t = json.decode(value)
         print(t.name2[4])  --&gt; 23.54





      </Example>
      <Parameters>

        s

        JSON string.





      </Parameters>
      <Returns>

        table

        Returns content of the JSON encoded string.





      </Returns>
      <Remarks>

        Starting with build 741, Corona is now shipping with the dkjson library. This library is Lua 5.2 compliant so you need to load the library as follows:

         value = require( "json" )

        Loading the library without the "value =" will generate a runtime error.




      </Remarks>
    </json.decode>
    <json.encode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the Lua object JSON encoded into a string.
        JSON (Javascript Object Notation)


      </Description>
      <Syntax>

        value = json.encode( t )





      </Syntax>
      <Example>

        local json = require "json"
         
         -- Lua script:
         local t = {
            ["name1"] = "value1",
            ["name2"] = {1, false, true, 23.54, "a \021 string"},
            name3 = json.null()
         }
         
         local jsonBlob = json.encode (t)
         print (jsonBlob)  --&gt; {"name1":"value1","name3":null,"name2":[1,false,true,23.54,"a \u0015 string"]}
         
         local t = json.decode(jsonBlob)
         print(t.name2[4])  --&gt; 23.54





      </Example>
      <Parameters>

        t

        Lua table of data.





      </Parameters>
      <Returns>

        string

        JSON encoded data.





      </Returns>
      <Remarks>

        Notes:

        1) Encodable Lua types: string, number, boolean, table, nil

        2) Use Json.Null() to insert a null value into a Json object

        3) All control chars are encoded to \uXXXX format eg "\021" encodes to "\u0015"

        4) All Json \uXXXX chars are decoded to chars (0-255 byte range only)

        5) Json single line // and /* */ block comments are discarded during decoding

        6) Numerically indexed Lua arrays are encoded to Json Lists eg [1,2,3]

        7) Lua dictionary tables are converted to Json objects eg {"one":1,"two":2}

        8) Json nulls are decoded to Lua nil and treated by Lua in the normal way
        Starting with build 741, Corona is now shipping with the dkjson library. This library is Lua 5.2 compliant so you need to load the library as follows:

         value = require( "json" )

        Loading the library without the "value =" will generate a runtime error.




      </Remarks>
    </json.encode>
    <json.null>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a unique value that will be encoded as a null in a JSON encoding.
        Json nulls are decoded to Lua nil and treated by Lua in the normal way.


      </Description>
      <Syntax>

         value = json.null()





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Returns a null value.





      </Returns>
      <Remarks>





      </Remarks>
    </json.null>
  </JSON>
  <Math>
    <math.abs>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the absolute value (magnitude) of a number.


      </Description>
      <Syntax>

        math.abs (x)





      </Syntax>
      <Example>

        local a = math.abs(153)        -- Sets a to 153
        local b = math.abs(-15)        -- Sets b to 15
        local c = math.abs(12.234)     -- Sets c to 12.234
        local d = math.abs(-9.23)      -- Sets d to 9.23





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A positive number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.abs>
    <math.acos>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the arc cosine of a value in radians.


      </Description>
      <Syntax>

        math.acos (x)





      </Syntax>
      <Example>

        local x = math.acos(1)    -- result will be 0
        local y = math.acos(-1)    -- result will be 3.14159...
        local z = math.acos(1.1)   -- result will be nan





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number in the range 0 to pi.  If the parameter x is outside the range [-1..1], the result will be nan.





      </Returns>
      <Remarks>





      </Remarks>
    </math.acos>
    <math.asin>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the arc sine of a value (in radians).


      </Description>
      <Syntax>

        math.asin (x)





      </Syntax>
      <Example>

        print (math.asin (1))     -- result will be 1.57079...
        print (math.asin (-1))    -- result will be -1.57079...
        print (math.asin (1.1))   -- result will be nan





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number in the range -pi/2 to pi/2. If the parameter x is outside the range [-1..1], the result will be nan.





      </Returns>
      <Remarks>





      </Remarks>
    </math.asin>
    <math.atan>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the arc tangent of a value in radians.


      </Description>
      <Syntax>

        math.atan (x)





      </Syntax>
      <Example>

        print("atan(0) = " .. math.atan(0))              --- result is 0
        print("atan(inf) = " .. math.atan(math.huge))    --- result is +pi/2
        print("atan(-inf) = " .. math.atan(-math.huge))  --- result is -pi/2





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number in the range -pi/2 to pi/2.





      </Returns>
      <Remarks>





      </Remarks>
    </math.atan>
    <math.atan2>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the principal value of the arctangent of the quotient of two specified numbers, expressed in radians.
        Useful when converting rectangular coordinates to polar coordinates. math.atan2 uses the sign of both arguments to place the result into the correct quadrant, and also produces correct values when one of its arguments is 0 or very close to 0.


      </Description>
      <Syntax>

        math.atan2 (y, x)





      </Syntax>
      <Example>

        print(math.atan2(1, 0))     --&gt;  pi/2
        print(math.atan2(-1, 0))    --&gt;  -pi/2
        print(math.atan2(0, 1))     --&gt;  0
        print(math.atan2(0, -1))    --&gt;  pi





      </Example>
      <Parameters>

        y

        A number representing an y-coordinate.
        x

        A number representing an x-coordinate.





      </Parameters>
      <Returns>

        A number in the interval [-pi,+pi] radians.





      </Returns>
      <Remarks>





      </Remarks>
    </math.atan2>
    <math.ceil>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the smallest integer larger than or equal to x.


      </Description>
      <Syntax>

        math.ceil (x)





      </Syntax>
      <Example>

        print (math.ceil(0.5))     ---&gt; 1
        print (math.ceil(-0.5))    ---&gt; -0





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.ceil>
    <math.cos>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the cosine of a value (assumed to be in radians).


      </Description>
      <Syntax>

        math.cos (x)





      </Syntax>
      <Example>

        -- animate a circle along a path
        local Ox, Oy = display.viewableContentWidth/2, display.viewableContentHeight/2
        local myCircle = display.newCircle( Ox, Oy, 10 )
        myCircle:setFillColor(128,128,200)
        local function onFrame(event)
            myCircle.x = (myCircle.x + 5) % display.viewableContentWidth
            myCircle.y = Oy - math.cos(myCircle.x/20)*100.0;
        end
        Runtime:addEventListener( "enterFrame", onFrame )





      </Example>
      <Parameters>

        x

        A number (assumed to be in radians).





      </Parameters>
      <Returns>

        A number in the range [-1, 1].





      </Returns>
      <Remarks>





      </Remarks>
    </math.cos>
    <math.cosh>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the hyperbolic cosine of a value.


      </Description>
      <Syntax>

        math.cosh (x)





      </Syntax>
      <Example>

        -- move a circle along a path
        local myCircle = display.newCircle( 0, display.viewableContentHeight/2, 10 )
        myCircle:setFillColor(250,250,100)
        local function onFrame(event)
            myCircle.y = math.cosh(15*(myCircle.x/display.viewableContentWidth-0.5));
            myCircle.x = (myCircle.x + 5) % display.viewableContentWidth
        end
        Runtime:addEventListener( "enterFrame", onFrame )





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.cosh>
    <math.deg>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Convert a value from radians to degrees.


      </Description>
      <Syntax>

        math.deg (x)





      </Syntax>
      <Example>

        print (math.deg(math.pi))        ---&gt; 180
        print (math.deg(math.pi / 2))    ---&gt; 90
        print (math.rad(180))            ---&gt; 3.1415926535898





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.deg>
    <math.exp>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns e (the base of natural logarithms) raised to a given power.


      </Description>
      <Syntax>

        math.exp (x)





      </Syntax>
      <Example>

        print (math.exp(0))   ---&gt; 1
        print (math.exp(1))  ---&gt; 2.718281828459





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.exp>
    <math.floor>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the greatest integer no greater than the given value.


      </Description>
      <Syntax>

        math.floor (x)





      </Syntax>
      <Example>

        print (math.floor(0.5))    ---&gt; 0
        print (math.floor(-0.5))    ---&gt; -1





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.floor>
    <math.fmod>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the remainder of the division of the arguments that rounds the quotient towards zero.
        The remainder of a division operation is the result of subtracting the integral quotient multiplied by the denominator from the numerator:
        remainder = numerator - quotient * denominator


      </Description>
      <Syntax>

        math.fmod (x, y)





      </Syntax>
      <Example>

        print (math.fmod(5.3, 2))     ---&gt; 1.3
        print (math.fmod(1, 0))    ---&gt; nan





      </Example>
      <Parameters>

        x

        The division numerator.
        y

        The division denominator.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.fmod>
    <math.frexp>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Split a value into a normalized fraction and an exponent.


      </Description>
      <Syntax>

        math.frexp (x)





      </Syntax>
      <Example>

        print (math.frexp(2))    ---&gt; 0.5     2
        print (math.frexp(3))    ---&gt; 0.75    2
        print (math.frexp(128))  ---&gt; 0.5     8





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        Two numbers:
        a binary significand, a value between 0.5 (included) and 1.0 (excluded)
        an integral exponent of 2

        such that:
        x = significand * 2exponent

        If x is zero, both parts (significand and exponent) are zero.




      </Returns>
      <Remarks>





      </Remarks>
    </math.frexp>
    <math.inf>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a value larger than or equal to any other numerical value.


      </Description>
      <Syntax>

        math.inf





      </Syntax>
      <Example>

        print (1/0)                   ---&gt; inf
        print (math.huge)             ---&gt; inf
        print (math.huge / 2)         ---&gt; inf
        print ( -math.huge)           ---&gt; -inf
        print (math.huge/math.huge)   ---&gt; nan
        print (math.huge * 0)         ---&gt; nan





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        A number representing +infinity.





      </Returns>
      <Remarks>





      </Remarks>
    </math.inf>
    <math.ldexp>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Generates a number from a significant number (m) and an exponent (e).


      </Description>
      <Syntax>

        math.ldexp (m, e)





      </Syntax>
      <Example>

        print (math.ldexp( 0.5, 8 ) )     ---&gt; 128





      </Example>
      <Parameters>

        m

        A number.
        e

        An integer.





      </Parameters>
      <Returns>

        A number, the value m * 2 e.




      </Returns>
      <Remarks>





      </Remarks>
    </math.ldexp>
    <math.log>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the natural logarithm.


      </Description>
      <Syntax>

        math.log (x)





      </Syntax>
      <Example>

        print (math.log (2.718281828459))     ----&gt; very close to 1
        print (math.log (1))     ----&gt; 0
        print (math.log (0))     ----&gt; -inf
        print (math.log (-1))    ----&gt; nan





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.log>
    <math.log10>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the base-10 logarithm.


      </Description>
      <Syntax>

        math.log10 (x)





      </Syntax>
      <Example>

        print (math.log10 (10))    ----&gt; 1
        print (math.log10 (1))     ----&gt; 0
        print (math.log10 (0))     ----&gt; -inf
        print (math.log10 (-1))    ----&gt; nan





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.log10>
    <math.max>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Return the maximum value among its arguments.


      </Description>
      <Syntax>

        math.max (x [, ...])





      </Syntax>
      <Example>

        print (math.max(1.2, -7, 3))        ---&gt;3
        print (math.max(0, -100000000))     ---&gt;0
        print (math.max(0, 1/0, math.huge)) ---&gt;inf





      </Example>
      <Parameters>

        x [, ...]

        A number or list of numbers.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.max>
    <math.min>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Return the minimum value among its arguments.


      </Description>
      <Syntax>

        math.min (x [, ...])





      </Syntax>
      <Example>

        print (math.min(1.2, -7, 3))        ---&gt; -7
        print (math.min(0, 1e-9))           ---&gt; 0
        print (math.min(0, 1/0, math.huge)) ---&gt; 0





      </Example>
      <Parameters>

        x [, ...]

        A number or list of numbers.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.min>
    <math.modf>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Return the integral and fractional parts of a number.

        Note:  For the modulus (remainder), use the modulo operator % instead.


      </Description>
      <Syntax>

        math.modf (x)





      </Syntax>
      <Example>

        print (math.modf(5))     ----&gt;  5       0
        print (math.modf(5.3))   ----&gt;  5       0.3
        print (math.modf(-5.3))  ----&gt; -5      -0.3





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        Two numbers, the integer part and the fractional parts of x.

        Each part has the same sign as x.





      </Returns>
      <Remarks>





      </Remarks>
    </math.modf>
    <math.pi>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the constant pi.


      </Description>
      <Syntax>

        math.pi





      </Syntax>
      <Example>

        print (math.pi)   ---&gt;  3.1415926535898





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.pi>
    <math.pow>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the result of raising a number to the power of another number.


      </Description>
      <Syntax>

        math.pow (x, y)





      </Syntax>
      <Example>

        print (math.pow(100,0))  ----&gt;  1
        print (math.pow(7,2))    ----&gt;  49
        print (math.pow(2,8))    ----&gt;  256





      </Example>
      <Parameters>

        x

        A number, the base.
        y

        A number, the exponent.





      </Parameters>
      <Returns>

        A number, xy.

        math.pow (x, y) is equivalent to using the exponentiation operator: x^y





      </Returns>
      <Remarks>





      </Remarks>
    </math.pow>
    <math.rad>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Converts to radians an angle given in degrees.


      </Description>
      <Syntax>

        math.rad (x)





      </Syntax>
      <Example>

        print (math.rad(180))  ----&gt;  3.1415926535898
        print (math.rad(1))    ----&gt;  0.017453292519943





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.rad>
    <math.random>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a pseudo-random number from a sequence with uniform distribution.


      </Description>
      <Syntax>

         math.random ([x [, y])





      </Syntax>
      <Example>

        print (math.random ())        ---&gt; a number between 0 and 1
        print (math.random ())        ---&gt; a second number between 0 and 1
        print (math.random (10))      ---&gt; an integer between 1 and 10 (inclusive)
        print (math.random (70, 80))  ---&gt; an integer between 70 and 80 (inclusive)





      </Example>
      <Parameters>


        math.random() with no arguments generates a real number between 0 and 1.
        math.random(x) generates integer numbers between 1 and x.

        math.random(x, y) generates integer numbers between x and y.







      </Parameters>
      <Returns>

        A number.
        Note:  Consecutive invocations of math.random() return consecutive values in a given pseudorandom sequence. Use math.randomseed() to specify a seed and reset a sequence.





      </Returns>
      <Remarks>





      </Remarks>
    </math.random>
    <math.randomseed>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets a seed for the pseudo-random generator: Equal seeds produce equal sequences of numbers.


      </Description>
      <Syntax>

        math.randomseed (x)





      </Syntax>
      <Example>

        math.randomseed(1234)
        print (math.random(), math.random(), math.random())  ----&gt; 0.31763056866714     0.416967588671  0.97426279353642
        math.randomseed(1234)
        print (math.random(), math.random(), math.random())  ----&gt; 0.31763056866714     0.416967588671  0.97426279353642
         
        math.randomseed( os.time() )  ----&gt; a different sequence each time if there is a long enough time between invocations
        Note: The exact values corresponding to a given seed may be platform- and version-dependent.





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </math.randomseed>
    <math.round>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Rounds number to the nearest integer following the same rules as the JavaScript version, i.e. if the fractional portion of number is .5 or greater, the argument is rounded to the next higher integer. If the fractional portion of number is less than .5, the argument is rounded to the next lower integer.


      </Description>
      <Syntax>

        local value = math.round( num )





      </Syntax>
      <Example>

        print( math.round( 0.1 )  )     -- Output: 0.1  0
        print( math.round( 0.5 )  )     -- Output: 0.5  1
        print( math.round( 8.9 )  )     -- Output: 8.9  9
        print( math.round( -0.1 ) )     -- Output: -0.1 0
        print( math.round( -0.5 ) )     -- Output: -0.5 0
        print( math.round( -8.9 ) )     -- Output: -8.9 -9





      </Example>
      <Parameters>

        num

        Number to be rounded.





      </Parameters>
      <Returns>

        number

        Number rounded up or down.





      </Returns>
      <Remarks>





      </Remarks>
    </math.round>
    <math.sin>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the sine of an angle (assumed to be in radians).


      </Description>
      <Syntax>

        math.sin (x)





      </Syntax>
      <Example>

        -- move a circle along a path
        local myCircle = display.newCircle( 0, display.viewableContentHeight/2, 10 )
        local t, p = 0, 0.7
        myCircle:setFillColor(250,250,100)
        local function onFrame(event)
            myCircle.x = display.viewableContentWidth/2 + 100 * math.cos(10*t - p)
            myCircle.y = display.viewableContentHeight/2 - 100 * math.sin(10*t)
            t = t + 5
        end
        Runtime:addEventListener( "enterFrame", onFrame )





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number in the range [-1, 1].





      </Returns>
      <Remarks>





      </Remarks>
    </math.sin>
    <math.sinh>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the hyperbolic sine of a value.


      </Description>
      <Syntax>

         math.sinh (x)





      </Syntax>
      <Example>

        print (math.sinh(1))      ----&gt;  1.1752011936438
         
        -- move a circle along a path
        local myCircle = display.newCircle( 0, display.viewableContentHeight/2, 10 )
        myCircle:setFillColor(250,250,100)
        local function onFrame(event)
            myCircle.y = display.viewableContentHeight/2
                         - math.sinh(15*(myCircle.x/display.viewableContentWidth-0.5));
            myCircle.x = (myCircle.x + 5) % display.viewableContentWidth
        end
        Runtime:addEventListener( "enterFrame", onFrame )





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.sinh>
    <math.sqrt>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the square root of a value.


      </Description>
      <Syntax>

        math.sqrt (x)





      </Syntax>
      <Example>

        print (math.sqrt (100))    ---&gt; 10
        print (math.sqrt (-1))     ---&gt; nan





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number, x2.

        math.sqrt(x) is equivalent to using the exponentiation operator: x^0.5




      </Returns>
      <Remarks>





      </Remarks>
    </math.sqrt>
    <math.tan>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the tangent of a value (assumed to be in radians).


      </Description>
      <Syntax>

        math.tan (x)





      </Syntax>
      <Example>

        print (math.tan (-math.pi/2))   ---&gt; a very large negative number
        print (math.tan (math.pi/4))    ---&gt; 1
        print (math.tan (math.pi/2))    ---&gt; a very large number





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.tan>
    <math.tanh>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the hyperbolic tangent of a value.


      </Description>
      <Syntax>

        math.tanh (x)





      </Syntax>
      <Example>

        print (math.tanh (math.log (2)))   ---&gt; 0.6





      </Example>
      <Parameters>

        x

        A number.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </math.tanh>
  </Math>
  <Modules_and_Packages>

    <package.loaded>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A table used by require to control which modules are already loaded. When you require a module modname and package.loaded[modname] is not false, require simply returns the value stored there.


      </Description>
      <Syntax>

        package.loaded





      </Syntax>
      <Example>

        local ui = require("ui")
        print( package.loaded.ui )      
        print( package.loaded.abc )    





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Table value if the package is loaded, or returns nil if the package is not loaded.





      </Returns>
      <Remarks>





      </Remarks>
    </package.loaded>
    <package.loaders>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A table used by require to control how to load modules.
        Each entry in this table is a searcher function. When looking for a module, require calls each of these searchers in ascending order, with the module name (the argument given to require) as its sole parameter. The function may return another function (the module loader) or a string explaining why it did not find that module (or nil if it has nothing to say).
        When running in the simulator, the searcher looks for Lua files that can serve as Lua libraries. These Lua files must be in the same directory as your main.lua file. As long as they are in the same directory as your main.lua file, they will be packaged for you during device builds.


      </Description>
      <Syntax>

        package.loaders





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </package.loaders>
    <package.seeall>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets a metatable for the specified module with its __index field referring to the global environment, so that this module inherits values from the global environment. To be used as an option to function module.


      </Description>
      <Syntax>

        package.seeall (module)





      </Syntax>
      <Example>

        -- In "helloModule.lua"
        module(..., package.seeall)
         
        -- Declare the functions you want in your module
        function hello()
                print ("Hello, module")
        end
         
        -- In main.lua
        require 'helloModule'
        helloModule.hello()





      </Example>
      <Parameters>

        module

        String: The name of the module whose metatable should be modified.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </package.seeall>

  </Modules_and_Packages>
  <Multimedia>
    <media.pauseSound>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Pauses playback of the extended sound currently opened by the previous call to media.playSound().  Use media.playSound() to resume playback of a paused sound.


      </Description>
      <Syntax>

        media.pauseSound()





      </Syntax>
      <Example>

        media.pauseSound()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </media.pauseSound>
    <media.newRecording>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Create object for audio recording.


      </Description>
      <Syntax>

        recording = media.newRecording( [path] )





      </Syntax>
      <Example>

        local filePath = system.pathForFile( dataFileName, system.DocumentsDirectory )
        r = media.newRecording( filePath)
        r:startRecording( )





      </Example>
      <Parameters>

        path

        (Optional) path of the file in which to record audio data. The file format is inferred from the extension (see note below regarding supported formats).

        If no file is specified, the output goes "nowhere".  Use this form when using the tuner feature to activate audio input.
        Note:  different platforms support different formats. The Apple implementation supports raw, aif, aac, and mp3. The Android implementation only supports 3gp.





      </Parameters>
      <Returns>

        r

        The audio recording object.





      </Returns>
      <Remarks>

        To enable audio recording on Android devices, you must set the permission level in the build.settings file.

        1
        2
        3
        4
        5
        6
        7
        settings =
        {
           androidPermissions =
           {
               "android.permission.RECORD_AUDIO"
           },
        }




      </Remarks>
    </media.newRecording>
    <media.newEventSound>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Loads the event sound (1-3 seconds) from a sound file and returns an event sound id that can be passed to media.playEventSound.
        For the iPhone, event sound files should be:

        Short (only a few seconds)
        For the highest quality event sounds, use 16-bit, little endian, linear PCM audio data packaged in the Core Audio Format (.caf). On Mac OS X use the afconvert command:
        /usr/bin/afconvert -f caff -d LEI16 {INPUT}{OUTPUT}




      </Description>
      <Syntax>

        id = media.newEventSound(filename [, baseDir] )





      </Syntax>
      <Example>

        local soundID = media.newEventSound( "beep.mp3" )
        local playBeep = function()
                media.playEventSound( soundID )
        end
        timer.performWithDelay( 1000, playBeep, 0 )





      </Example>
      <Parameters>

        filename

        Name of the sound file.
        baseDir

        If specified, this argument is the directory where the sound file is located. If missing, the default is system.ResourceDirectory.





      </Parameters>
      <Returns>

        An event sound id that can be passed to media.playEventSound





      </Returns>
      <Remarks>

        This API is used to preload the sound file that is played by media.playEventsound. On Android devices, the sound file should be preloaded prior to playing to avoid any delay in starting.
        The media.playEventSound is intended for short alert sounds and therefore has way to control program the volume.
        Note: It is recommended that the newer Corona Audio APIs, using openAL, be used for playing back audio. http://developer.anscamobile.com/reference/audio




      </Remarks>
    </media.newEventSound>
    <media.getSoundVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the current volume setting for playback of extended sounds (media.playSound).


      </Description>
      <Syntax>

        value = media.getSoundVolume()





      </Syntax>
      <Example>

         media.setSoundVolume( 0.5 )
         print( "volume = " .. media.getSoundVolume() )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        The current volume.  Values range from 0 to 1.0.





      </Returns>
      <Remarks>





      </Remarks>
    </media.getSoundVolume>
    <media.playEventSound>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Plays an event sound (1-3 seconds). The first argument may be either an event sound id or a filename for the event sound. Recommended for short sounds, especially to avoid animation â€œhiccups.â€


      </Description>
      <Syntax>

        media.playEventSound( sound [, baseDir] [, completionListener] )





      </Syntax>
      <Example>

        local soundID = media.newEventSound( "beep.caf" )
        local playBeep = function()
                media.playEventSound( soundID )
        end
        timer.performWithDelay( 7500, playBeep, 0 )





      </Example>
      <Parameters>

        sound

        The first argument is either an event sound id (from media.newEventSound) or a filename for the event sound.
        baseDir

        If specified, this argument is the directory where the sound file is located. If missing, the default is system.ResourceDirectory.
        completionListener

        If specified, this argument is a completion listener that will be called each time the event sound is played.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        On iOS devices (and Xcode simulator), the only supported sound formats are CAF and AIF. These formats must be uncompressed or they will not play.
        On Android devices, the only supported sound formats are MP3 and OGG.
        The Corona Simulator supports: CAF, AIF, and MP3 formats.
        For Android devices, the sound should be preloaded with the media.newEventSound API.
        Note that there is no volume control API for EventSound. It is intended for alert sounds and the volume is controlled by the device's hardware controls.
        Note: It is recommended that the newer Corona Audio APIs, using openAL, be used for playing back audio. http://developer.anscamobile.com/reference/audio




      </Remarks>
    </media.playEventSound>
    <media.playSound>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Plays an extended sound (as opposed to an "event sound", 1-3 seconds duration), or resumes play of a paused extended sound. You can only have one such sound file open at a time.
        Calls Listener (optional) when the sound finishes.


      </Description>
      <Syntax>

        media.playSound( soundfile [, baseDir] [, onComplete] )

      </Syntax>
      <Example>

        media.playSound( "song.mp3" )
        local stopAfter10Seconds = function()
                media.stopSound()
        end
        timer.performWithDelay( 10000, stopAfter10Seconds )
        Note that it can take a moment for a long MP3 to initially load, which may lead to a brief pause in animation. One workaround is to "preload" the MP3 earlier in the program by loading and immediately stopping it:
        media.playSound( 'sound.mp3' )
        media.stopSound()





      </Example>
      <Parameters>

        soundfile

        Name of the sound file. The file must be in a format that is supported by the platform.
        onComplete

        Optional completion listener that will be invoked when the sound finishes playing.
        loop

        If true, the sound will be played repeatedly.
        baseDir

        By default sound files are expected to be in the application resources directory.  If the sound file is in the application documents directory, use system.DocumentsDirectory.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        The volume can be controlled by media.getSoundVolume and media.setsoundVolume.
        The playing can be controlled by media.pauseSound and media.stopSound.
        Only one sound can be playing using this sound API. Calling this API with a different sound file will stop the existing sound and play the new sound.
        Note: It is recommended that the newer Corona Audio APIs, using openAL, be used for playing back audio. http://developer.anscamobile.com/reference/audio




      </Remarks>
    </media.playSound>
    <media.playVideo>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Plays the video at the specified path (both local and remote) in a device-specific popup Video media player.
        During video playback, the media player interface takes over. If showControls is true, then the user can adjust playback, e.g. start, stop, seek, etc. Pass a listener to get notified when the video has ended. Note this function is asynchronous: any code that follows will be executed. After that, the application code will continue to run on iOS devices, but on Android devices the application will be suspended until the video playback is complete.
        Supported video formats are platform- and version-dependent.  The iPhone video player supports playback of movie files with the .mov, .mp4, .m4v, and .3gp filename extensions and using the following compression standards:

        H.264 Baseline Profile Level 3.0 video, up to 640 x 480 at 30 fps. Note: B frames are not supported in the Baseline profile.
        MPEG-4 Part 2 video (Simple Profile)



      </Description>
      <Syntax>

        media.playVideo( path [, baseSource ], showControls, listener )





      </Syntax>
      <Example>

        local onComplete = function(event)
           print( "video session ended" )
        end
        media.playVideo( "Movie.m4v", true, onComplete )





      </Example>
      <Parameters>

        path

        The local filename or a remote URL for the video.
        baseSource

        Optional parameter that controls how the local filename path is interpreted.  It can either be one of the system-defined directory constants, or media.RemoteSource (use this to access video on a remote server).
        showControls

        If true, then the user can adjust playback, e.g. start, stop, seek, etc.
        listener

        Listener to notify when the video has ended.  The listener can be either a function listener or a table listener. If listener is a table, it must have a completion method. The event dispatched to the listener will be a completion event.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </media.playVideo>
    <media.setSoundVolume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Adjusts the playback volume of an extended sound (media.playSound).  This setting can be adjusted at any time before or during the extended sound playback.
        Note that setting the global volume is a different feature, and is not currently supported.
        Also note that event sounds (media.playEventSound) do not have volume control. This is a limitation of the event sound API for iPhone.


      </Description>
      <Syntax>

        media.setSoundVolume( vol )





      </Syntax>
      <Example>

         media.setSoundVolume( 0.5 )
         print( "volume = " .. media.getSoundVolume() )





      </Example>
      <Parameters>

        vol

        This parameter controls the volume.  Values must be in the range from 0 to 1.0  (0 = no sound, 1.0 = loudest).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </media.setSoundVolume>
    <media.show>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Opens a platform-specific interface to the device's camera or photo library. This function is asynchronous, i.e. it returns immediately so the calling code will continue to execute until the end of its scope; after that, the application will be suspended until the session is complete.   By default, the image object is added to the top of the current stage. A listener is required to handle the returned display object (image).


      </Description>
      <Syntax>

        media.show( mediaSource, listener )





      </Syntax>
      <Example>

        local onComplete = function(event)
           local photo = event.target
           print( "photo w,h = " .. photo.width .. "," .. photo.height )
        end
        if media.hasSource( media.Camera ) then
           media.show( media.Camera, onComplete )
        else
           native.showAlert( "Corona", "This device does not have a camera.", { "OK" } )
        end





      </Example>
      <Parameters>

        mediaSource

        Can be one of the following:

        media.PhotoLibrary
        media.Camera
        media.SavedPhotosAlbum

        listener can be either a function listener or a table listener. If a table, it must have a completion method. The event dispatched to the listener will be a completion event with the following additional property:  event.target is a display image object based on the imageSource parameter. The property will be nil if the user canceled the camera or photo selection.





      </Parameters>
      <Returns>

        Nothing. "event.target" in the Listener function will contain the Display Image object.





      </Returns>
      <Remarks>

        On the Corona Simulator and Xcode Simulator, there is no camera so the API will open a finder window and allow the user to select an image file to substitute as the camera.



        Note: This API (Camera and PhotoLibrary) is not support on Android devices in the current release build (591). Camera and PhotoLibrary support was added to Android starting with build 622.




      </Remarks>
    </media.show>
    <media.stopSound>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Stops playback of the extended sound currently opened by the previous call to media.playSound().


      </Description>
      <Syntax>

        media.stopSound()





      </Syntax>
      <Example>

        media.stopSound()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </media.stopSound>
    <object..getSampleRate>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Gets the current audio recording sample rate. (Used for recording audio.)


      </Description>
      <Syntax>

         rate = object:getSampleRate()





      </Syntax>
      <Example>

         r:setSampleRate( rate )                            -- request a new sampling rate
        local actualRate = r:getSampleRate( )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        rate

        The current sampling rate, a platform-dependent number such as 8000, 11025, 16000, 22050 or 44100.





      </Returns>
      <Remarks>





      </Remarks>
    </object..getSampleRate>
    <object..getTunerFrequency>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns the last calculated frequency in Hz.   Works only if the tuner was on (startTuner()).


      </Description>
      <Syntax>

        f = object:getTunerFrequency()





      </Syntax>
      <Example>

        local r = media.newRecording()
        r:startTuner()
        r:startRecording()
        local f = r:getTunerFrequency()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        f

        The currently estimated pitch of the audio input, expressed as a frequency in Hz.  The value returned is 0 if no pitch could be detected.





      </Returns>
      <Remarks>





      </Remarks>
    </object..getTunerFrequency>
    <object..getTunerVolume>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns the mean squared normalized sample value of the current audio buffer.  Works only if the tuner was on (startTuner()).


      </Description>
      <Syntax>

        v = object:getTunerVolume()





      </Syntax>
      <Example>

        local r = media.newRecording()
        r:startTuner()
        r:startRecording()
        local v = r:getTunerVolume()
        local vdb = 10*math.log( v )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        v

        The mean squared value of the samples in the current audio buffer using sample values scaled to be in the range [-1..1].





      </Returns>
      <Remarks>





      </Remarks>
    </object..getTunerVolume>
    <object..isRecording>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns true if audio recording is currently in progress, false otherwise.


      </Description>
      <Syntax>

        value = object:isRecording()





      </Syntax>
      <Example>

        local function recButtonPress ( event )
                  if r:isRecording () then
                        r:stopRecording()
                        media.playSound( dataFileName, system.DocumentsDirectory, onCompleteSound )
                    else
                        r:startRecording()
                    end
        end





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        true if audio recording is currently in progress, false otherwise.





      </Returns>
      <Remarks>





      </Remarks>
    </object..isRecording>
    <object..setSampleRate>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Request an audio recording sample rate.
        The recording sample rate defaults to 44100. Note that not all platforms may support all rates. Valid rates are 8000, 11025, 16000, 22050, 44100.
        To use the tuning feature with a sample rate other than the default, you must call setSampleRate() before calling startTuner().


      </Description>
      <Syntax>

        object:setSampleRate( r )





      </Syntax>
      <Example>

        r:setSampleRate( rate )                            -- request a new sampling rate
        local actualRate = r:getSampleRate( )





      </Example>
      <Parameters>

        r

        Requested sampling rate.  Valid rates are 8000, 11025, 16000, 22050, 44100.  Different platforms support different rates; use getSampleRate() to find out the actual sampling rate.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..setSampleRate>
    <object..startRecording>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Start audio recording.
        Note: Starting an audio recording will stop any audio playback. You cannot record and play audio at the same time.


      </Description>
      <Syntax>

        object:startRecording( )





      </Syntax>
      <Example>

        local filePath = system.pathForFile( dataFileName, system.DocumentsDirectory )
        r = media.newRecording( filePath)
        r:startRecording( )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        To enable audio recording on Android devices, you must set the permission level in the build.settings file.

        1
        2
        3
        4
        5
        6
        7
        settings =
        {
           androidPermissions =
           {
               "android.permission.RECORD_AUDIO"
           },
        }




      </Remarks>
    </object..startRecording>
    <object..stopRecording>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Stop audio recording.


      </Description>
      <Syntax>

        object:stopRecording( )





      </Syntax>
      <Example>

        r:stopRecording()
        media.playSound( dataFileName, system.DocumentsDirectory, onCompleteSound )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..stopRecording>
    <object..stopTuner>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Stop the tuner module.


      </Description>
      <Syntax>

        object:stopTuner()





      </Syntax>
      <Example>






      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </object..stopTuner>
  </Multimedia>
  <Native_UI>
    <native.cancelAlert>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Dismisses an alert box programmatically. For example, you may wish to have a popup alert that automatically disappears after ten seconds even if the user doesnâ€™t click it. In that case, you could call this function at the end of a ten-second timer.


      </Description>
      <Syntax>

        native.cancelAlert( alert )





      </Syntax>
      <Example>

        -- Handler that gets notified when the alert closes
        local function onComplete( event )
                if "clicked" == event.action then
                        local i = event.index
                        if 1 == i then
                                -- Do nothing; dialog will simply dismiss
                        elseif 2 == i then
                                -- Open URL if "Learn More" (the 2nd button) was clicked
                                system.openURL( "http://developer.anscamobile.com" )
                        end
                end
        end
         
        -- Show alert with two buttons
        local alert = native.showAlert( "Corona", "Dream. Build. Ship.",
                                                { "OK", "Learn More" }, onComplete )
         
        -- Dismisses "alert" after 10 seconds if user has not responded
        local function cancelMyAlert()
                native.cancelAlert( alert )
        end
         
        timer.performWithDelay( 10000, cancelMyAlert )





      </Example>
      <Parameters>

        alert

        id of the alert to cancel (from native.showAlert)





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </native.cancelAlert>
    <native.getSync>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Get the iCloud automatic backup settings for files in the system.DocumentsDirectory on Mac and iOS systems.
        The iCloud backup is true by default and must be set false with the native.setSync API to disable automatic backup of files to iCloud.


      </Description>
      <Syntax>

        value, errorStr = native.getSync( filename, parms )





      </Syntax>
      <Example>

        -- Assuming a file named "SavedData.dat" in the Documents directory
        --
        local results, errStr = native.getSync( "SavedData.dat", { key = "iCloudBackup" } )
         
        -- Get file backup from file in a subdirectory within the Documents directory
        local results, errStr = native.getSync( "data/SavedData.dat", { key = "iCloudBackup" } )





      </Example>
      <Parameters>

        filename

        string: Name of file (including path) of file
        parms

        table: { key = "iCloudBackup" }





      </Parameters>
      <Returns>

        value

        boolean: Returns the iCloudBackup setting (true or false) for the specified file. You must check errStr to see if this API returned an error. Returns nil on Android and Windows systems since they don't support this API.
        errStr

        string: Error string (otherwise nil).





      </Returns>
      <Remarks>

        Not available for builds before 2012.808.




      </Remarks>
    </native.getSync>
    <native.newFont>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a font object that you can use to specify fonts in native text fields and text boxes.  You can also pass it as a parameter to the display text objects in the display.newText() function.


      </Description>
      <Syntax>

        f = native.newFont( name [, size] )





      </Syntax>
      <Example>

        textBox = native.newTextBox( 30, 140, 260, 100 )
        textBox.font = native.newFont( "Helvetica-Bold", 16 )
        textBox:setTextColor( 200, 200, 200, 255 )





      </Example>
      <Parameters>

        name

        A string that identifies the font. Use native.getFontNames() to get an array of available font names, or use one of the following constants:

        native.systemFont
        native.systemFontBold

        size

        (Optional) The point size of the font to use. By default, it will be the standard system font size of the device.
        Note that the available fonts are platform-dependent.  Also, the fonts available in the simulator may be different from the fonts actually available on the device. In general, iPhone device fonts can be accessed from the simulator within MacOS, but additional Mac fonts will also be available that may not work on the iPhone. If you encounter a problem of fonts appearing in the simulator but not on your device, this is the most likely cause. When in doubt, check the available device font names using native.getFontNames().





      </Parameters>
      <Returns>

        f

        The id of the created font





      </Returns>
      <Remarks>





      </Remarks>
    </native.newFont>
    <native.newVideo>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a video object that can be moved and rotated. You can also add a physics body to video objects. This API supports local videos (in one of the System directories) or from a remote location (server).
        The native.newVideo API is only available for iOS devices and is part of the Daily Builds starting with build 730. It is not available in the Release Build (704).


      </Description>
      <Syntax>

        object = native.newVideo( left, top, width, height )





      </Syntax>
      <Example>

        local video = native.newVideo( 0, 0, 320, 480 )
         
        local function videoListener( event )
            print( "Event phase: " .. event.phase )
         
            if event.errorCode then
                native.showAlert( "Error!", event.errorMessage, { "OK" } )
            end
        end
         
        -- load a video and jump to 0:30
        video:load( "myVideo.m4v", system.DocumentsDirectory )
        video:seek( 30 )
         
        video:addEventListener( "video", videoListener )
        -- play video
        video:play()
         
         
        . . .
        -- stop the video and remove
        video:pause()
        video:removeSelf()
        video = nil





      </Example>
      <Parameters>

        left, top

        numbers. The left and top starting coordinates of the video object.
        width, height

        numbers. The width and height of the video object.
        Methods
        Note: The "video" listed below corresponds to the video object returned from calling  native.newVideo().
        video:load( path [, baseSource] )

        Loads specified video. path is the local filename or a remote URL for the video. baseSource is an optional parameter that controls how the local filename path is interpreted. It can either be one of the system-defined directory constants, or media.RemoteSource (use this to access video on a remote server).
        video:play()

        Plays currently loaded video.
        video:pause()

        Pauses currently loaded video.
        video:seek( timeInSeconds )

        Jumps to specified timeInSeconds in currently loaded video. Ensure this is not greater than value returned by the totalTime property (see Properties section below).
        Listener
        You can add an optional callback listener using

        object:addEventListener( "video", listener )
        The listener callback includes the phase (event.phase) as "ready" and "ended", an error code (event.errorCode), an error message (event.errorMessage). Error codes and messages are only present if there was an error with the request.
        Properties
        totalTime

        number. Read-only property that gives you the length of currently loaded video in seconds.
        currentTime

        number. Read-only property that gives you the current time position of the video in seconds.
        isMuted

        boolean (true/false). A read/write property that returns or controls the video's audio.
        x, y

        numbers. Changing these properties will move the video object to specified location.
        rotation

        number. Changing this property will rotate the video object (0-360).





      </Parameters>
      <Returns>

        Video object. This API supports multiple video objects.





      </Returns>
      <Remarks>

        The Video listener is only available starting with build 736.




      </Remarks>
    </native.newVideo>
    <native.newWebView>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Loads a remote web page in a webView container. Native webViews differ from web popups in that you can move them (via x/y properties), rotate them (via rotation property), and assign physics bodies to them (in the same manner you would any other display objects.
        This API supports loading from either a local file containing HTML content (in one of the System directories) or from a remote website.
        NOTE: You must close a webView by calling the removeSelf() method because returning false in the listener function has no effect (with web popups, returning false in the listener closes the web popup).
        The native.newWebView API is only available for iOS devices (at this time) and is part of the Daily Builds starting with build 730. It is not available in the Release Build (704).


      </Description>
      <Syntax>

        object = native.newWebView( left, top, width, height )





      </Syntax>
      <Example>

        local webView = native.newWebView( 0, 0, 320, 480 )
        webView:request( "http://www.anscamobile.com/" )
        -- or
        webView:request( "localfile.html", system.ResourceDirectory )
        This example prints the url and/or errorCode in the callback listener:
        local function webListener( event )
            if event.url then
                print( "You are visiting: " .. event.url )
            end
         
            if event.type then
                print( "The event.type is " .. event.type  -- print the type of request
            end
         
            if event.errorCode then
                native.showAlert( "Error!", event.errorMessage, { "OK" } )
            end
        end
         
        local webView = native.newWebView( 0, 0, 320, 480, webListener )
        webView:request( "http://www.anscamobile.com/" )
         
        webView:addEventListener( "urlRequest", webListener )
        . . .
        -- remove the webView as with any other display object
        webView:removeSelf()
        webView = nil





      </Example>
      <Parameters>

        left, top

        numbers. The left/top starting position of the web view.
        width, height

        numbers. The width/height of the webView object (in pixels).
        Methods
        Note: The "webView" listed below corresponds to the webView object returned from calling  native.newWebView().
        webView:request( url [, baseDir] )

        Loads specified url (string) into webView. For local content, you MUST specify a base directory as a search path (see: System-defined Directories).
        webView:stop()

        Stops loading current page in webView (if loading).
        webView:reload()

        Reloads currently loaded page in webView.
        The following methods require build 2012.736 or higher:
        webView:back()

        Takes the webView back one step in the webView's history.
        webView:forward()

        Takes the webView forward one step in the webView's history.
        Properties
        x, y

        numbers. Represents the x/y position of the webView after it has been created. You may move the webView by changing these properties.
        rotation

        number. You may rotate the webView object by changing this value (0-360).
        hasBackground

        boolean (true/false). This is a get/set property that corresponds to whether or not the background of the webView is visible or transparent.
        The following properties require build 2012.736 or higher:
        canGoBack

        boolean (true/false). Read-only property that will be true if webView can go back a webpage, and false if not.
        canGoForward

        boolean (true/false). Read-only property that will be true if webView can go forward a webpage, and false if not.
        Listener
        You can add an optional callback listener using

        object:addEventListener( "urlRequest", listener )
        This callback occurs when the URL is requested (shouldLoad method) and before the loading of the requested URL has started. The listener will be called for all URL loads, including the initial "request". It will also be called if other URLs are requested from the website (e.g., twitter, facebook, ads, etc.).
        The listener callback includes the URL being requested (event.url), an error code (event.errorCode), an error message (event.errorMessage), and event type (event.type). Error codes and messages are only present if there was an error with the request.
        event.type is the type of URL request being made: "link", "history", "form", "formResubmit", "reload", and "other". This may also be nil if the platform doesn't support this property. (Currently, it's only available on iOS.)
        The main difference between the webView listener and web popup listeners is that returning true/false has no effect (with web popups, returning false in the listener would cause the web popup to close).





      </Parameters>
      <Returns>

        Native webView object. This API supports multiple webView objects.





      </Returns>
      <Remarks>

        Some methods and properties require build 2012.736 or higher.




      </Remarks>
    </native.newWebView>
    <native.setActivityIndicator>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Displays or hides a platform-specific activity indicator. Touch events are ignored while the indicator is shown.
        Note that the indicator will not show until the Lua code block containing the setActivityIndicator(true) call has completed execution. Also, if you try to show and hide the indicator within the same code block then the indicator will not show properly. Instead, call the code to hide the activity indicator in a separate function call or callback.
        The code in the example uses the timer object to hide the indicator after 2 seconds have elapsed.


      </Description>
      <Syntax>

        native.setActivityIndicator( state )





      </Syntax>
      <Example>

        native.setActivityIndicator( true )
        timer.performWithDelay( 2000,  
             function()
                 native.setActivityIndicator( false )
             end)





      </Example>
      <Parameters>

        state

        Use true to show the indicator and false to hide it.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Note: Native Activity Indicator object, like other native objects don't work in groups and are always displayed on top of regular Display Objects (vector, images, and text).




      </Remarks>
    </native.setActivityIndicator>
    <native.setKeyboardFocus>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets keyboard focus on a textField and (where appropriate) shows or hides the keyboard.  Pass nil to remove focus and dismiss the keyboard.


      </Description>
      <Syntax>

        native.setKeyboardFocus( textField )





      </Syntax>
      <Example>

        Note: this example uses native text fields which are only visible when built for device.

        -- Handlers for login dialog UI
         
        local function onUsername( event )
                if ( "began" == event.phase ) then
                        -- Note: this is the "keyboard appearing" event
                        -- In some cases you may want to adjust the interface while the keyboard is open.
                       
                elseif ( "submitted" == event.phase ) then
                        -- Automatically tab to password field if user clicks "Return" on iPhone keyboard (convenient!)
                        native.setKeyboardFocus( passwordField )
                end
        end
         
        local function onPassword( event )
                -- Hide keyboard when the user clicks "Return" in this field
                if ( "submitted" == event.phase ) then
                        native.setKeyboardFocus( nil )
                end
        end
         
        usernameField = native.newTextField( 50, 150, 220, 36, onUsername )
        usernameField.font = native.newFont( native.systemFontBold, 24 )
        usernameField.text = ""
        usernameField:setTextColor( 51, 51, 122, 255 )
         
        passwordField = native.newTextField( 50, 210, 220, 36, onPassword )
        passwordField.font = native.newFont( native.systemFontBold, 24 )
        passwordField.text = ""
        passwordField.isSecure = true
        passwordField:setTextColor( 51, 51, 122, 255 )





      </Example>
      <Parameters>

        textField

        id of the field on which to set the keyboard focus, or nil to hide the keyboard.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Not supported in Corona Simulators.




      </Remarks>
    </native.setKeyboardFocus>
    <native.setSync>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the iCloud automatic backup flag for files in the system.DocumentsDirectory on Mac and iOS systems.
        The iCloud backup is true by default and must be set false with this API to disable automatic backup of files to iCloud.


      </Description>
      <Syntax>

        value, errorStr = native.setSync( filename, parms )





      </Syntax>
      <Example>

        -- Assuming a file named "SavedData.dat" in the Documents directory
        --
        -- Disable file backup
        local results, errStr = native.setSync( "SavedData.dat", { iCloudBackup = false } )
         
        -- Disable file backup in a subdirectory within the Documents directory
        local results, errStr = native.setSync( "data/SavedData.dat", { iCloudBackup = false } )





      </Example>
      <Parameters>

        filename

        string: Name of file (including path) of file.
        parms

        table:  { iCloudBackup = flag }, The flag is true to enable backup to iCloud (default case) or false to disable backup.





      </Parameters>
      <Returns>

        value

        boolean: true if setSync was successful, false if setSync failed. Returns nil on Android and Windows systems since they don't support this API.
        errStr

        string: Error message if "value" returned false.





      </Returns>
      <Remarks>

        This is for Mac and iOS only.
        Not available for builds before 2012.808.




      </Remarks>
    </native.setSync>
    <native.showAlert>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Displays a popup alert box with one or more buttons, using a native alert control. Program activity, including animation, will continue in the background, but all other user interactivity will be blocked until the user selects a button or cancels the dialog.


      </Description>
      <Syntax>

        native.showAlert( title, message [, { buttonLabels } [, listener] ] )





      </Syntax>
      <Example>

        -- Handler that gets notified when the alert closes
        local function onComplete( event )
                if "clicked" == event.action then
                        local i = event.index
                        if 1 == i then
                                -- Do nothing; dialog will simply dismiss
                        elseif 2 == i then
                                -- Open URL if "Learn More" (the 2nd button) was clicked
                                system.openURL( "http://developer.anscamobile.com" )
                        end
                end
        end
         
        -- Show alert with two buttons
        local alert = native.showAlert( "Corona", "Dream. Build. Ship.",
                                                { "OK", "Learn More" }, onComplete )





      </Example>
      <Parameters>

        title

        The title string displayed in the alert
        message

        Message string displayed in the alert text.
        buttonLabels

        Table of strings, each of which will create a button with the corresponding label.  Include at least one buttonLabel or the dialog will not have any buttons. The first button will have a unique color to suggest that the user should choose it by default.
        The maximum number of buttons in an alert box is five. The most common format is one or two buttons, for example â€œOKâ€ and â€œCancelâ€.
        listener

        The listener to be notified when a user presses any button in the alert box.  It can assign an action to each button according to its numerical index: the first button is index 1, the second is index 2, and so on. The listener can be either a function listener or a table listener. If listener is a table, it must have a completion method.
        The event dispatched to the listener will be a completion event with the following additional properties:

        event.action represents how the alert was dismissed:  "cancelled" indicates that native.cancelAlert() was called to close the alert, while "clicked" indicates that the user clicked on a button to close the alert.
        event.index is the index of the button pressed. It corresponds to the index in the buttonLabels parameter.






      </Parameters>
      <Returns>

        alert

        id of the alert.  (Can be used to cancel the alert.)





      </Returns>
      <Remarks>

        Note: Native Show Alert object, like other native objects don't work in groups and are always displayed on top of regular Display Objects (vector, images, and text).




      </Remarks>
    </native.showAlert>
    <native.showPopup>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Show a message composer from inside the app for e-mail and SMS.
        This API will bring up the native Messenger or Email app on the device (as a pop-up or new window) to complete the task. Control returns to your app after the information is sent.
        For a walk-through on how to use this feature, please see the Composing E-mail and SMS tutorial from the blog.


      </Description>
      <Syntax>

        native.showPopup( name, options )





      </Syntax>
      <Example>

        Show an e-mail popup with one file attachment.

        local options =
        {
           to = "john.doe@somewhere.com",
           subject = "My High Score",
           body = "I scored over 9000!!! Can you do better?",
           attachment = { baseDir=system.DocumentsDirectory, filename="Screenshot.png", type="image" },
        }
        native.showPopup("mail", options)
        Show an HTML e-mail popup with multiple correspondents and attachments.

        local options =
        {
           to = { "john.doe@somewhere.com", "jane.doe@somewhere.com" },
           cc = { "john.smith@somewhere.com", "jane.smith@somewhere.com" },
           subject = "My High Score",
           isBodyHtml = true,
           body = "I scored over 9000!!! Can you do better?",
           attachment =
           {
              { baseDir=system.DocumentsDirectory, filename="Screenshot.png", type="image" },
              { baseDir=system.ResourceDirectory, filename="MyLogo.png", type="image" },
           },
        }
        native.showPopup("mail", options)
        Show a simple SMS popup. User must select contacts in popup window.

        local options =
        {
           body = "I scored over 9000!!! Can you do better?"
        }
        native.showPopup("sms", options)
        Show an SMS popup with multiple recipients. You must use phone numbers.

        local options =
        {
           to = { "1234567890", "9876543210" },
           body = "I scored over 9000!!! Can you do better?"
        }
        native.showPopup("sms", options)





      </Example>
      <Parameters>

        name

        The string name of the popup to be shown, either "mail" or "sms"
        options

        Optional table of parameters. Each property of the table is also optional.
        For the "mail" popup, the following properties are supported:

        options.to is a single string or an array of strings. Each string is an e-mail address of a recipient.
        options.cc is a single string or an array of strings. Each string is an e-mail address of a cc'd recipient.
        options.bcc is a single string or an array of strings. Each string is an e-mail address of a bcc'd recipient.
        options.attachment is a table of the form { baseDir=, filename= [, type=] }. For the 'type' property, use an appropriate MIME type such as "image". To send multiple attachments, you must create an array of these tables.
        options.body is a string for the main body of the e-mail.
        options.isBodyHtml is a boolean indicating whether the e-mail is HTML. By default, plain text is assumed.
        options.subject is a string.

        For the "sms" popup, the following properties are supported:

        options.to is a single string or an array of strings. Each string is a phone number of the recipient.
        options.body is a string for the main body of the e-mail.






      </Parameters>
      <Returns>

        result

        A boolean indicating whether the popup was displayed. If false, then the popup was not available or the service was not available for the device.





      </Returns>
      <Remarks>





      </Remarks>
    </native.showPopup>
    <native.systemFont>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Native system font for display.newText, native.newTextField and native.newTextBox.


      </Description>
      <Syntax>

        object.font = native.systemFont





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        userdata

        Font property.





      </Returns>
      <Remarks>





      </Remarks>
    </native.systemFont>
  </Native_UI>
  <InputTextFields>
    <native.newTextField>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a single-line textfield for text input.
        Note: Native textfields are only available in device builds and on the Corona Mac Simulator.
        Because native textfields are not part of the OpenGL canvas, they do not obey the Corona display object hierarchy. For example, while they can be manipulated using display object methods, they always appear above normal display objects.
        Also, they do not inherit display group properties like isVisible, x, y and alpha. If you need to set display properties on native objects, apply them to the objects directly.
        To remove a native textfield from the display, use object:removeSelf().
        For multiline text, see native.newTextBox.
        The native.setKeyboardFocus API is used to set and clear the keyboard used for text input.


      </Description>
      <Syntax>

         native.newTextField( left, top, width, height [, listener] )





      </Syntax>
      <Example>

        numericField = native.newTextField( 50, 150, 220, 36, handlerFunction )
        numericField.inputType = "number"
        This example uses Lua Closures to allow using one listener for multiple Text Fields

        local defaultField, numberField -- forward reference (needed for Lua closure)
         
        -- TextField Listener
        local function fieldHandler( getObj )
               
        -- Use Lua closure in order to access the TextField object
         
                return function( event )
         
                        print( "TextField Object is: " .. tostring( getObj() ) )
                       
                        if ( "began" == event.phase ) then
                                -- This is the "keyboard has appeared" event
                       
                        elseif ( "ended" == event.phase ) then
                                -- This event is called when the user stops editing a field:
                                -- for example, when they touch a different field or keyboard focus goes away
                       
                                print( "Text entered = " .. tostring( getObj().text ) )         -- display the text entered
                               
                        elseif ( "submitted" == event.phase ) then
                                -- This event occurs when the user presses the "return" key
                                -- (if available) on the onscreen keyboard
                               
                                -- Hide keyboard
                                native.setKeyboardFocus( nil )
                        end
                       
                end     -- "return function()"
         
        end
         
        -- Create our Text Field
        defaultField = native.newTextField( 10, 30, 180, 30,
                fieldHandler( function() return defaultField end ) )    -- passes the text field object
               
        numberField = native.newTextField( 10, 70, 180, 30,
                fieldHandler( function() return numberField end ) )





      </Example>
      <Parameters>

        left

        X-coordinate of the top left corner of the text field.
        top

        Y-coordinate of the top left corner of the text field.
        width

        Width of the text field.
        height

        Height of the text field.
        listener

        (Optional) listener function to respond to keyboard events. If you choose to handle this event with a table listener, the event name is "userInput". These events come with a phase attribute, as follows:

        event.phase = "began" -- this is the â€œkeyboard has appearedâ€ event. Depending on your interface design, you may want to adjust the screen contents when the keyboard is onscreen.
        event.phase = "ended" -- this event is called when the user stops editing a field: for example, when they touch a different field.
        event.phase = "submitted" -- this event occurs when the user presses the â€œ"return"â€ key (if available) on the onscreen keyboard.
        event.phase = "editing" -- this event occurs when the user modifies text in the textbox. During this phase, several other keys are present in the event table:

        event.startPosition -- number representing the position the cursor was at when the edit took place.
        event.text -- string that represents the text of the textbox (to include the new edit).
        event.newCharacters -- string that represents any new characters that were typed in during the event.
        event.oldText -- string that represents the characters before the new characters were typed in during the event.








      </Parameters>
      <Returns>

        The created native text field object.





      </Returns>
      <Remarks>

        Other properties that affect text fields:
        object.align

        object.font

        object.isSecure

        object.size

        object.text

        native.setKeyboardFocus  (used to set/clear the keyboard)
        Note: This API is supported in the Corona Mac Simulator  but not in the Corona Windows Simulator.
        Note: Native Text Field objects, like other native objects don't work in groups and are always displayed on top of regular Display Objects (vector, images, and text).
        Sample Programs Using This API

        /Interface/NativeDisplayObjects

        /Interface/NativeKeyboard2




      </Remarks>
    </native.newTextField>
    <object.align>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Alignment of text displayed in the input text field.  May be set to one of the following strings: "left", "center", or "right".
        Note: Native input text fields are only available in device builds and Mac Simulator.


      </Description>
      <Syntax>

        object.align





      </Syntax>
      <Example>

        nameField = native.newTextField( 50, 150, 220, 36, handlerFunction )
        nameField.align = "center"





      </Example>
      <Parameters>

        value

        Alignment string: "left", "center', or "right".





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.align>
    <object.font>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Font of the text input field.  May be set to a font object as returned by native.newFont().
        Note:  Native text input fields are only available on device builds and Mac Simulator.


      </Description>
      <Syntax>

        object.font





      </Syntax>
      <Example>

        local myField = native.newTextField( 10, 30, 180, 30, fieldHandler )
        local myField.font = native.newFont( native.systemFontBold, 18 )





      </Example>
      <Parameters>

        Font object.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.font>
    <object.inputType>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The keyboard type of the native text input field.
        Possible values are:

        "default" - the default keyboard, supporting general text, numbers and punctuation
        "number" - a numeric keypad
        "phone" - a keypad for entering phone numbers
        "url" - a keyboard for entering website URLs
        "email" - a keyboard for entering email addresses

        Note:  to create a password-entry field, set the isSecure boolean property.


      </Description>
      <Syntax>

        object.inputType





      </Syntax>
      <Example>

        numericField = native.newTextField( 50, 150, 220, 36, handlerFunction )
        numericField.inputType = "number"





      </Example>
      <Parameters>

        type

        Type of keyboard input expressed as a string.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Windows Simulator.




      </Remarks>
    </object.inputType>
    <object.isSecure>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Controls whether text in the field is hidden, e.g. passwords. Default is false.


      </Description>
      <Syntax>

        object.isSecure





      </Syntax>
      <Example>

        local passwordField = native.newTextField( 100, 50, 40, 30, inputListener )
        passwordField.inputType = "number"
        passwordField.isSecure = true





      </Example>
      <Parameters>

        value

        true if a secure input is required (hides the input with "***"), otherwise false.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Windows Simulator.




      </Remarks>
    </object.isSecure>
    <object.size>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Get/SEt the font size of the text in the text input field.
        Note: native text input fields are only available on device builds.


      </Description>
      <Syntax>

        object.size





      </Syntax>
      <Example>

        local field1 = native.newTextField( 50, 100, 100, 35 )
        field1.align = "center"
        field1.size = 32
        field1.text = "Hello, world!"
        field1:setTextColor( 255, 128, 0 )





      </Example>
      <Parameters>

        Size of text (number), if a setter.





      </Parameters>
      <Returns>

        Size of text (number), if a getter.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.size>
    <object.text>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The get/set the contents of the native text input field, a string.
        Note: this feature is only available on device builds.


      </Description>
      <Syntax>

        object.text





      </Syntax>
      <Example>

        local field1 = native.newTextField( 50, 100, 100, 35 )
        field1.align = "center"
        field1.size = 32
        field1.text = "Hello, world!"
        field1:setTextColor( 255, 128, 0 )





      </Example>
      <Parameters>

        The text string (if setter).





      </Parameters>
      <Returns>

        The text string (if getter).





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.text>
    <object..setTextColor>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the color of the text in a text input field.
        Note: Native text input fields are only available in device builds.


      </Description>
      <Syntax>

        object:setTextColor( r, g, b [, a] )





      </Syntax>
      <Example>

        local field1 = native.newTextField( 50, 100, 100, 35 )
        field1.align = "center"
        field1.size = 32
        field1.text = "Hello, world!"
        field1:setTextColor( 255, 128, 0 )





      </Example>
      <Parameters>

        r, g, b, [, a]

        RGB or RGBA components of the color.   All components must be between 0 and 255. Alpha is optional and is 255 (opaque) by default.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object..setTextColor>
  </InputTextFields>
  <Maps>
    <myMap.isLocationVisible>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only Boolean value indicating whether the user's current location is visible within the area currently displayed on the map.
        This is based on an approximation, so it may be that the value is true when the user's position is slightly offscreen.


      </Description>
      <Syntax>

        local isVisible = myMap.isLocationVisible





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        A read-only Boolean value indicating whether the user's current location is visible within the area currently displayed on the map.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap.isLocationVisible>
    <myMap.isScrollEnabled>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A Boolean indicating whether the map should display the user's current location. When this value is true, the map will update continuously as the user moves. The initial default is false.


      </Description>
      <Syntax>

        myMap.isScrollEnabled





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap.isScrollEnabled>
    <myMap.isZoomEnabled>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A Boolean that determines whether users may use pinch/zoom gestures to zoom the map. Default is true.


      </Description>
      <Syntax>

        myMap.isZoomEnabled





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap.isZoomEnabled>
    <myMap.mapType>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A string that specifies the type of map display. Possible values are "standard", "satellite" and "hybrid". The default is "standard".


      </Description>
      <Syntax>

        map.mapType





      </Syntax>
      <Example>

        local myMap = native.newMapView( 0, 0 , display.stageWidth, display.stageHeight )
        myMap.mapType = "satellite"





      </Example>
      <Parameters>

        maptype

        String: Specifies the type of map to display. Valid values are "standard", "satellite" and "hybrid". The default is "standard".





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap.mapType>
    <myMap..addMarker>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Adds a pin to the map at the specified location. The optional title and subtitle will appear on a small popup when the pin is touched.


      </Description>
      <Syntax>

        myMap:addMarker( latitude, longitude, [{ title="Displayed Title", subtitle="subtitle text" } ])





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        latitude

        Number: The marker's latitude in degrees.

        longitude

        Number: The marker's longitude in degrees.

        title

        String: The title to display on the pop-up that appears when the user taps the marker.

        subtitle

        String: The subtitle to display on the pop-up that appears when the user taps the marker.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..addMarker>
    <myMap..getAddressLocation>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns the numerical latitude and longitude values of the given location string, obtained using a Google maps HTTP method. These values can then be used to place a marker on the map, recenter the map to the desired location, or perform any of the other functions that use a (latitude, longitude) pair.
        This function will accept virtually any address or intersection format as input (along with the names of some famous landmarks), since it submits the string directly to Google's address parser, which is fairly flexible.


      </Description>
      <Syntax>

        latitude, longitude = myMap:getAddressLocation( location )





      </Syntax>
      <Example>

        local latitude, longitude = myMap:getAddressLocation( "gough and post, sf" )
        --[[ Other location variations:
        local latitude, longitude = myMap:getAddressLocation( "120 university, palo alto, ca" )
        local latitude, longitude = myMap:getAddressLocation( "eiffel tower" )
        --]]





      </Example>
      <Parameters>

        location

        String: The address, intersection, landmark, or other location string accepted by Google's location parser.





      </Parameters>
      <Returns>

        The numerical latitude and longitude values of the given location string.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..getAddressLocation>
    <myMap..getUserLocation>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns a table containing values for the user's current location. The fields of the table are the same as those currently used in Corona GPS location events.n


      </Description>
      <Syntax>

        myLocation = myMap:getUserLocation()





      </Syntax>
      <Example>

           local myMap = native.newMapView( 0, 0, 320, 480 )
           local locationTable  = myMap.getUserLocation()
           local locationtxt = display.newText("My location is: ", 0, 0, native.systemFont, 16)
           locationtxt.text = locationtxt.text .. locationTable.latitude .. ", " ..locationTable.longitude





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        A Lua table that contains the following properties:
        1
        2
        3
        4
        5
        6
        7
        8
        myLocation.longitude
        myLocation.latitude
        myLocation.altitude
        myLocation.accuracy
        myLocation.time
        myLocation.speed
        myLocation.direction
        myLocation.isUpdating -- a Boolean that flags whether the location is currently updating





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..getUserLocation>
    <myMap..nearestAddress>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns the nearest address based on the given latitude and longitude values. The address is returned as a "mapAddress" event.


      </Description>
      <Syntax>

        myMap:nearestAddress( 37.331692, -122.030456 )





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function mapAddressHandler( event )
            -- handle mapAddress event here
            if event.isError then
                print( "mapView Error: " .. event.errorMessage )
            else
                print( "The specified location is in: " .. event.city .. ", " .. event.country )
            end
        end
         
        myMap:nearestAddress( 38.898748, -77.037684 )
         
        Runtime:addEventListener( "mapAddress", mapAddressHandler )





      </Example>
      <Parameters>

        latitude

        Number: The latitude of the desired location.
        longitude

        Number: The longitude of the desired location.





      </Parameters>
      <Returns>

        Nothing. All data returned in "mapAddress" event.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..nearestAddress>
    <myMap..removeAllMarkers>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Clears all markers (pins) from the map.


      </Description>
      <Syntax>

        myMap:removeAllMarkers()





      </Syntax>
      <Example>

           myMap:removeAllMarkers()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..removeAllMarkers>
    <myMap..setCenter>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Moves the displayed map region to a new location, using the new center point but keeping the zoom level the same. The final parameter is an optional Boolean (default false) that determines whether the transition is animated or happens instantly.


      </Description>
      <Syntax>

        myMap:setCenter( latitude, longitude, isAnimated )





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        latitude

        Number: The latitude of the map's center point.
        longitude

        Number: The longitude of the map's center point.
        isAnimated

        Boolean: Specifies whether the transition is animated (true) or happens instantly (false, the default).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..setCenter>
    <myMap..setRegion>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Moves the displayed map region to a new location, with the new center point and horizontal/vertical span distances given in degrees of latitude and longitude (which implicitly set the zoom level). iOS will sanity-check the span settings, and will interpolate a consistent zoom level even if the latitudeSpan and longitudeSpan are specified with radically different values. The final parameter is an optional Boolean (default false) that determines whether the transition is animated or happens instantly.
        Note that degrees of latitude and longitude cover large distances on the Earth, so fairly small changes to extended decimal values will translate into big position changes in the map, especially at close zoom levels. Also note that most of the planet's map locations are fairly empty, so it will generally be easier to work with known latitude/longitude values when experimenting with maps. Try looking up your own address on a public geocoding site like http://geocoder.us (US addresses only) if you need a quick test location.


      </Description>
      <Syntax>

        myMap:setRegion( latitude, longitude, latitudeSpan, longitudeSpan, isAnimated )





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        latitude

        Number: The latitude in degrees of the region's center point.
        longitude

        Number: The longitude in degrees of the region's center point.
        latitudeSpan

        Number: The region's latitudinal span in degrees. This implicitly sets the map's zoom level.
        longitudeSpan

        Number: The region's longitudinal span in degrees. This implicitly sets the map's zoom level.
        isAnimated

        Boolean: Specifies whether to animate the map from the current region to the new one.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        This API is not available in Corona Simulator.




      </Remarks>
    </myMap..setRegion>
    <native.newMapView>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Renders a MapView within the specified boundaries (or fullscreen, if no boundaries are specified) and returns a display object wrapper.


      </Description>
      <Syntax>

        myMap = native.newMapView( left, top, width, height )





      </Syntax>
      <Example>

        -- Create a native MapView (requires XCode Simulator build or device build)
        -- You can create multiple maps, if you like...
        --
        myMap = native.newMapView( 20, 20, 300, 220 )
        myMap.mapType = "standard" -- other mapType options are "satellite" or "hybrid"
         
        -- The MapView is just another Corona display object, and can be moved or rotated, etc.
        myMap.x = display.contentWidth / 2
        myMap.y = 120
         
        -- Initialize map to a real location, since default location (0,0) is not very interesting
        myMap:setCenter( 37.331692, -122.030456 )
         
        local function callMap()
                -- Fetch the user's current location
                -- Note: in XCode Simulator, the current location defaults to Apple headquarters in Cupertino, CA
                local currentLocation = myMap:getUserLocation()
                local currentLatitude = currentLocation.latitude
                local currentLongitude = currentLocation.longitude
               
                -- Move map so that current location is at the center
                myMap:setCenter( currentLatitude, currentLongitude, true )
               
                -- Look up nearest address to this location (this is returned as a "mapAddress" event, handled above)
                myMap:nearestAddress( currentLatitude, currentLongitude )
        end
         
        -- A function to handle the "mapAddress" event (also known as "reverse geocoding")
        --
        local mapAddressHandler = function( event )
                local locationText =
                        "Latitude: " .. currentLatitude ..
                        ", Longitude: " .. currentLongitude ..
                        ", Address: " .. event.streetDetail .. " " .. event.street ..
                        ", " .. event.city ..
                        ", " .. event.region ..
                        ", " .. event.country ..
                        ", " .. event.postalCode
                       
                local alert = native.showAlert( "You Are Here", locationText, { "OK" } )
        end
         
        -- A listener for the address lookup result
        -- (This could also be a table listener on the map itself, in case you have more than one simultaneous map.)
        Runtime:addEventListener( "mapAddress", mapAddressHandler )
         
        timer.performWithDelay( 1000, callMap )         -- get current location after 1 second





      </Example>
      <Parameters>

        left

        number: specify that the map object's left corner.
        top

        number: specify that the map object's top corner.
        width

        number: width of the map object.
        height

        number: height of the map object.





      </Parameters>
      <Returns>

        Map object.





      </Returns>
      <Remarks>

        Note: Does not work in simulators or on Android devices.
        Map objects like other native objects don't work in groups and are always displayed on top of regular Display Objects (vector, images, and text).




      </Remarks>
    </native.newMapView>
  </Maps>
  <TextBoxes>
    <native.newTextBox>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a scrollable, multiline text box for display content. Text boxes can be used for text input (and multi-line text input) by setting the .isEditable property to true.
        Use "\n" to start text on a new line. Text will automatically wrap to the next line if it't too long.
        Note: Native text boxes are only available in device builds and on the Corona Mac Simulator.
        Because native text boxes are not part of the OpenGL canvas, they do not obey the Corona display object hierarchy. For example, while they can be manipulated using display object methods, they always appear above normal display objects.
        Also, they do not inherit display group properties like isVisible, x, y and alpha. If you need to set display properties on native objects, apply them to the objects directly.
        To remove a native text box from the display, use object:removeSelf().
        For single line text, see native.newTextField.
        The native.setKeyboardFocus API is used to set and clear the keyboard used for text input.


      </Description>
      <Syntax>

        native.newTextBox( left, top, width, height [, listener] )





      </Syntax>
      <Example>

        native.newTextBox( 15, 70, 280, 70 )

      </Example>
      <Parameters>

        left

        X-coordinate of the top left corner of the text field.
        top

        Y-coordinate of the top left corner of the text field.
        width

        Width of the text field.
        height

        Height of the text field.
        listener

        (Optional) listener function to respond to keyboard events. The 'isEditable' property of the text box in order for keyboard events to be sent to the text box. If you choose to handle this event with a table listener, the event name is "userInput". These events come with a phase attribute, as follows:

        event.phase = "began" -- this is the â€œkeyboard has appearedâ€ event. Depending on your interface design, you may want to adjust the screen contents when the keyboard is onscreen.
        event.phase = "ended" -- this event is called when the text box loses focus: touching a different field or the on-screen keyboard is dismissed
        event.phase = "submitted" -- used only on the Corona Mac Simulator when Text Box loses focus. It is sent before sending "ended" event. This event is NOT used on iOS or Android devices. The "ended" event should be used instead of "submitted."
        event.phase = "editing" -- this event occurs when the user modifies text in the textbox. During this phase, several other keys are present in the event table:

        event.startPosition -- number representing the position the cursor was at when the edit took place.
        event.text -- string that represents the text of the textbox (to include the new edit).
        event.newCharacters -- string that represents any new characters that were typed in during the event.
        event.oldText -- string that represents the characters before the new characters were typed in during the event.








      </Parameters>
      <Returns>

        The created native text box object.





      </Returns>
      <Remarks>

        Other properties that affect the text box:

        object.align

        object.font

        object.hasBackground

        object.size

        object.text

        object.isEditable

        object:setTextColor
        Note: This API is supported in the Corona Mac Simulator  but not in the Corona Windows Simulator.
        Note: Native Text Box objects, like other native objects don't work in groups and are always displayed on top of regular Display Objects (vector, images, and text).
        The argument 'listener' is only available starting in daily build 609.




      </Remarks>
    </native.newTextBox>
    <object.align>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Alignment of text displayed in the text input box. May be set to one of the following strings: "left", "center", or "right".
        Note: Native text input boxes are only available in device builds and on the Mac Simulator.


      </Description>
      <Syntax>

        object.align





      </Syntax>
      <Example>

        inputBox = native.newTextBox( 50, 150, 220, 36 )
        inputBox.align = "left"





      </Example>
      <Parameters>

        value

        Alignment string: "left", "center', or "right".





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.align>
    <object.font>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Font of the text input box. May be set to a font object as returned by native.newFont().
        Note: Native text input boxes are only available on device builds and Mac Simulator.


      </Description>
      <Syntax>

        object.font





      </Syntax>
      <Example>

        local myTextInputBox = native.newTextBox( 10, 30, 180, 30, fieldHandler )
        local myTextInputBox.font = native.newFont( native.systemFontBold, 18 )





      </Example>
      <Parameters>

        Font object.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.font>
    <object.hasBackground>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Controls whether the text input box has an opaque background or not. If not specified, the background will be opaque.


      </Description>
      <Syntax>

        object.hasBackground





      </Syntax>
      <Example>

        -- Multiline textfield, with transparent background
        textBox = native.newTextBox( 30, 140, 260, 100 )
        textBox.font = native.newFont( "Helvetica-Bold", 16 )
        textBox:setTextColor( 200, 200, 200, 255 )
        textBox.hasBackground = false
        textBox.text = "Hello, world!"
        myDialog:insert( textBox )
        textBox.alpha = 0





      </Example>
      <Parameters>

        True or false. Set to true if there is a background under the Text Box object.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.hasBackground>
    <object.size>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Get/Set the Font size of the text in the native text input box.
        Note: native text input boxes are only available on device builds.


      </Description>
      <Syntax>


        object.size





      </Syntax>
      <Example>

        local textBox = native.newTextBox( 30, 140, 260, 150 )
        textBox.font = native.newFont( "Helvetica-Bold", 12 )
        textBox:setTextColor( 200, 250, 250, 255 )
        textBox.hasBackground = false
        textBox.text = "If you've struggled with mobile development or are stumped where to begin, then you'll love Corona. Our APIs are simple and easy to use."
        textBox.alpha = 1.0
        -- "zoom" the text
        transition.to( textBox, { size=18, time=800 } )





      </Example>
      <Parameters>

        Size of text (number), if a setter.





      </Parameters>
      <Returns>

        Size of text (number), if a getter.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.size>
    <object.text>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The get/set the contents of the native text input box, a string.
        Note: this feature is only available on device builds and Mac Simulator.


      </Description>
      <Syntax>
        object.text





      </Syntax>
      <Example>

        local textBox = native.newTextBox( 30, 140, 260, 150 )
        textBox.font = native.newFont( "Helvetica-Bold", 18 )
        textBox:setTextColor( 200, 250, 250, 255 )
        textBox.alpha = 1.0
        textBox.hasBackground = false
        textBox.text = "If you've struggled with mobile development or are stumped where to begin, then you'll love Corona. Our APIs are simple and easy to use."





      </Example>
      <Parameters>

        The text string (if setter).





      </Parameters>
      <Returns>

        A text string (if getter).





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object.text>
    <object..setTextColor>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets the color of the text in a native text input box.
        Note: Native text input boxes are only available in device builds.


      </Description>
      <Syntax>

        object:setTextColor (r, g, b [, a] )





      </Syntax>
      <Example>

        local textBox = native.newTextBox( 30, 140, 260, 150 )
        textBox.font = native.newFont( "Helvetica-Bold", 18 )
        textBox:setTextColor( 200, 250, 250, 255 )
        textBox.alpha = 1.0
        textBox.hasBackground = false
        textBox.text = "If you've struggled with mobile development or are stumped where to begin, then you'll love Corona. Our APIs are simple and easy to use."





      </Example>
      <Parameters>

        r

        number: Red channel, between 0 and 255.
        g

        number: Green channel, between 0 and 255.
        b

        number: Blue channel, between 0 and 255.
        a

        number:  Alpha is optional and is 255 (opaque) by default.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        None.




      </Remarks>
    </object..setTextColor>
  </TextBoxes>
  <WebPopups>
    <native.cancelWebPopup>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Dismisses the currently displaying web pop-up.


      </Description>
      <Syntax>

        native.cancelWebPopup()





      </Syntax>
      <Example>






      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Returns true if web pop-up was displaying prior to the call; false otherwise.





      </Returns>
      <Remarks>

        Not supported in Corona Simulators.




      </Remarks>
    </native.cancelWebPopup>
    <native.showWebPopup>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a web popup that loads a local or remote web page.
        Note: Web popups are only available on device builds.


      </Description>
      <Syntax>

        native.showWebPopup( x, y, width, height, url [, options] )





      </Syntax>
      <Example>

        native.showWebPopup( 10, 10, 300, 300,
                          "http://www.anscamobile.com",
                          {urlRequest=listener} )

        This example reads the html code from a local file in the /Documents directory.

        local function listener( event )
                local shouldLoad = true
         
                local url = event.url
                if 1 == string.find( url, "corona:close" ) then
                        -- Close the web popup
                        shouldLoad = false
                end
         
                if event.errorCode then
                        -- Error loading page
                        print( "Error: " .. tostring( event.errorMessage )
                        shouldLoad = false
                end
         
                return shouldLoad
        end
         
        local options = { hasBackground=false, baseUrl=system.DocumentsDirectory, urlRequest=listener }
        native.showWebPopup( "localpage1.html", options )





      </Example>
      <Parameters>

        url

        URL of the local or remote web page. By default, the URL is assumed to be an absolute URL to a remote server.  If x, y, width, height are not specified, the popup occupies the entire screen.

        Note: To control scaling, make sure your popup's HTML head element contains the following: meta name="viewport" content="width=320; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/&gt;.
        To prevent text within a web popup from being resized add the following style to your HTML document:

        style type="text/css"&gt;
             html {        -webkit-text-size-adjust: none;  }
        style&gt;


        x, y, width, height

        If specified, these parameters control the position and dimensions of the popup.
        options

        Optional table containing additional parameters for the popup:


        options.baseUrl determines whether the url parameter to native.showWebPopup() is interpreted as a relative or absolute url.

        By default (nil) the url is absolute.
        To refer to a local file instead, set the base url to one of the base directory constants, e.g. system.ResourceDirectory. Then the url parameter is relative to that base directory.
        For remote files, you can also specify a remote base, and the url parameter will be relative to the remote base.


        options.hasBackground
        is a Boolean that controls whether the popup has a an opaque background or not. If not specified, the background will be opaque.
        options.autoCancel
        is a Boolean which sets up the popup to be automatically closed when the Android back key has been pressed when there is no more web history to navigate to. This is true by default.
        options.urlRequest
        designates a listener function that will intercept all urlRequest events from the web popup. This also provides a standard method for passing information back from a web page using pseudo-URLs.  For example, the Interface/WebOverlay sample project displays a local HTML page that contains the following HTML:

        form action="corona:close"&gt;
                input type="submit"/&gt;
        form&gt;      

        When the user clicks Submit in the web pop-up, the designated listener function is sent a urlRequest event object with its url property set to "corona:close", allowing the application to react appropriately.
        Note: The listener function must return true or the web popup will close. Without a return statement, false is assumed.






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Not supported in Corona Simulators.
        Only one WebPopup object can be displayed at a time.
        Webpopup objects cannot be moved or resized. They must be canceled and recreated if they need to be moved or resized.
        Note: Native Web Popup objects, like other native objects don't work in groups and are always displayed on top of regular Display Objects (vector, images, and text).
        Here is a link to working sample code showing how to use CSS in a local HTML file.

        https://github.com/ansca/My-Portfolio/




      </Remarks>
    </native.showWebPopup>
  </WebPopups>
  <Network />
  <AsynchronousHTTP>
    <network.download>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This API is similar to the asynchronous network.request() except that it downloads the response to a local file that you specify, rather than cacheing it in memory. This is recommended for large HTTP/HTTPS responses (for example, long XML documents), and can also be used for downloading remote images.
        You can also use display.loadRemoteImage() to download and display a remote image in a single API call.


      </Description>
      <Syntax>

        network.download( url, method, listener [, params], destFilename [, baseDir] )





      </Syntax>
      <Example>


        The following example downloads a remote image to a local file, and then displays it on the screen:
        local function networkListener( event )
                if ( event.isError ) then
                        print ( "Network error - download failed" )
                else
                        myImage = display.newImage( "helloCopy.png", system.TemporaryDirectory, 60, 40 )
                        myImage.alpha = 0
                        transition.to( myImage, { alpha = 1.0 } )
                end
               
                print ( "RESPONSE: " .. event.response )
        end
         
        network.download( "http://developer.anscamobile.com/demo/hello.png", "GET", networkListener, "helloCopy.png", system.TemporaryDirectory )





      </Example>
      <Parameters>

        url

        String: The HTTP request URL.
        method

        String: The HTTP method; valid values are "GET" (the default) or "POST".
        listener

        Function: The listener function invoked when the HTTP operation has completed.  It is passed an event object that contains the following properties:

        event.response

        A string containing the destination filename. This is useful if you're writing a general event handler for a variety of file downloads.
        event.isError

        A boolean value: true in the case of a network error, false otherwise. As of build 2012.744, "event.isError" only returns true if we failed to connect to the server or upon response timeout
        event.status

        A number value: The HTTP status code. (Only available starting with build 2012.744)

        params

        Table: An optional table that specifies custom HTTP headers or body to include in the request. To specify custom headers, attach a headers table that specifies header values with string keys. To specify a custom body message, attach a body property to this table whose string value is the HTTP body.
        params.headers -- A table specifying header values with string keys.
        params.body -- A string containing the HTTP body.
        destFilename

        String: The name of the file to which the HTTP response will be saved.
        baseDir

        The directory where the file will be saved to. Defaults to system.DocumentsDirectory if not provided. Cannot be set to system.ResourceDirectory since that directory is read-only.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Sample Programs Using This API

        /Networking/AsynchImageDownload




      </Remarks>
    </network.download>
    <network.request>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Makes an asynchronous HTTP or HTTPS request to a URL.


      </Description>
      <Syntax>

        network.request( url, method, listener [, params] )





      </Syntax>
      <Example>

        The following sample code contacts Google's encrypted search over SSL, and prints the response (in this case, the HTML source of the home page) to the Corona terminal:

        local function networkListener( event )
                if ( event.isError ) then
                        print( "Network error!")
                else
                        print ( "RESPONSE: " .. event.response )
                end
        end
         
        -- Access Google over SSL:
        network.request( "https://encrypted.google.com", "GET", networkListener )

        The following code demonstrates a sending data via HTTP post.

        local function networkListener( event )
                if ( event.isError ) then
                        print( "Network error!")
                else
                        print ( "RESPONSE: " .. event.response )
                end
        end
         
        postData = "color=red&amp;size=small"
         
        local params = {}
        params.body = postData
         
        network.request( "http://127.0.0.1/formhandler.php", "POST", networkListener, params)

        The following code demonstrates how to attach custom HTTP headers and custom body message to a request. Note: Custom HTTP headers are functional in build 277 and later. Subscribers can download the latest daily build from the daily builds page.
        headers = {}
         
        headers["Content-Type"] = "application/json"
        headers["Accept-Language"] = "en-US"
         
        body = "This is an example request body."
         
        local params = {}
        params.headers = headers
        params.body = body
         
        network.request( "https://192.168.0.1/getData.php", "POST", networkListener,  params)





      </Example>
      <Parameters>

        url

        String: The HTTP request URL.
        method

        String: The HTTP method; valid values are "GET" (the default) or "POST".
        listener

        Function: The listener function invoked when the HTTP operation has completed. It is passed an event object that contains the following properties:

        event.response

        A string containing the response from the server.
        event.isError

        A boolean value: true in the case of a network error, false otherwise. As of build 2012.744, "event.isError" only returns true if we failed to connect to the server or upon response timeout
        event.status

        A number value: The HTTP status code. (Only available starting with build 2012.744)

        Note: The time-out for a network request is 30 seconds.
        params

        Table: An optional table that specifies custom HTTP headers or body to include in the request. To specify custom headers, attach a headers table that specifies header values with string keys. To specify a custom body message, attach a body property to this table whose string value is the HTTP body.

        params.headers

        A table specifying header values with string keys.
        params.body
        A string containing the HTTP body.






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Android:

        Async HTTP POST not working. [case 4459] - Fixed in daily build 505
        Windows Simulator:

        Async HTTP requests fail if the response header contains a "Connection: close". [case 4774] - Fixed in daily build 505
        Sample Programs Using This API

        /Networking/AsynchHTTP




      </Remarks>
    </network.request>
  </AsynchronousHTTP>
  <DetectNetworkStatus>
    <network.canDetectNetworkStatusChanges>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns true if network status APIs are supported on the current platform.


      </Description>
      <Syntax>

        local result = network.canDetectNetworkStatusChanges





      </Syntax>
      <Example>

        if network.canDetectNetworkStatusChanges then
                network.setStatusListener( "www.apple.com", MyNetworkReachabilityListener )
        else
                print("network reachability not supported on this platform")
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Boolean: True if network status is supported on the current platform. False otherwise.





      </Returns>
      <Remarks>

        Sample Programs Using This API

        /Networking/Reachability




      </Remarks>
    </network.canDetectNetworkStatusChanges>
    <network.setStatusListener>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Starts monitoring a host for its network reachability status.
        The API is designed around the idea that you are monitoring individual hosts and not the hardware directly. Potentially, some hosts might continue to be reachable while others are not due to internet conditions, firewall configurations, authentication rules, and whether you need full DNS routing (e.g. not reachable through Bonjour/Zeroconf).


      </Description>
      <Syntax>

        network.setStatusListener( hostURL, listener )





      </Syntax>
      <Example>

        function MyNetworkReachabilityListener(event)
                print( "address", event.address )
                print( "isReachable", event.isReachable )
                print("isConnectionRequired", event.isConnectionRequired)
                print("isConnectionOnDemand", event.isConnectionOnDemand)
                print("IsInteractionRequired", event.isInteractionRequired)
                print("IsReachableViaCellular", event.isReachableViaCellular)
                print("IsReachableViaWiFi", event.isReachableViaWiFi)  
         
        --[[ If you want to remove the listener, call network.setStatusListener("www.apple.com", nil)  
                g_Counter = g_Counter + 1
                if g_Counter &gt; 3 then
                        print("removing event listener")
                        network.setStatusListener( "www.apple.com", nil)
                end
        --]]
         
        end
         
        if network.canDetectNetworkStatusChanges then
                network.setStatusListener( "www.apple.com", MyNetworkReachabilityListener )
        else
                print("network reachability not supported on this platform")
        end





      </Example>
      <Parameters>

        hostURL

        string: The host you want to monitor. This may be something like "www.apple.com".
        listener

        function: The callback function you want invoked when a network status change event happens.
        If you pass nil here, it will unregister the listener that is set for the specified host.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Currently only named hosts are supported. IP addresses will not work.
        This API allows monitoring multiple hostURLs with separate or common event listeners. Call this API for each HostURL to be monitored.
        Note: There is currently a bug (in Apple's OS?) that returns a false connection status when you specify a URL address with subfolders (e.g., "wwww.apple/xyz") when on the Cellular network. The URL returns the correct connection status when on Wifi.
        Sample Programs Using This API

        /Networking/Reachability




      </Remarks>
    </network.setStatusListener>
  </DetectNetworkStatus>
  <OpenFeint>
    <openfeint.downloadBlob>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Downloads data saved previously saved with openfeint.uploadBlob().
        Note: This API has been deprecated by the gameNetwork API.


      </Description>
      <Syntax>

        openfeint.downloadBlob ( blobKey, listenerFunction)





      </Syntax>
      <Example>

        openfeint.uploadBlob( "myBlobKey", "some blob data" )
         
        local downloadListener = function(event)
            print(event.name .. " =&gt; '" .. event.blob .. "' downloaded")
            return true
        end
         
        openfeint.downloadBlob( "myBlobKey", downloadListener )





      </Example>
      <Parameters>

        blobKey

        String: Identifies the blob data previously saved with uploadBlob().
        listenerFunction

        Function: Event listener function to invoke when blob data has finished downloading. The event passed to the listener has the following fields:

        event.name -- The name of the event.
        event.blob -- A string that contains the requested blob data. If the length of this string is 0, then then the download failed.






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Simulator.
        This API is not available on Android.




      </Remarks>
    </openfeint.downloadBlob>
    <openfeint.init>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Initializes an app with the specified product key, secret, display name, and app id. This should only be called once, and as soon as possible during application start-up.
        Starting with daily build #318, iOS OpenFeint will post achievement updates and leaderboard updates to GameCenter provided OFGameCenter.plist is present in the project folder. See http://support.openfeint.com/dev/game-center-compatibility/ for details.
        Note: This API has been deprecated by the gameNetwork API.


      </Description>
      <Syntax>

        openfeint.init ( productKey, productSecret, displayName, appId )





      </Syntax>
      <Example>

        openfeint.init ( "ABCDEFGHI1234567890", "ABCDEFGHI1234567890", "My App Name", "ABCDEFG" )





      </Example>
      <Parameters>

        productKey

        String: Your application's OpenFeint product key (provided by OpenFeint).
        productSecret

        String: Your application's product secret (provided by OpenFeint).
        displayName

        String: The name to display in OpenFeint leaderboards and other views.
        appId

        String: The application id (provided by OpenFeint).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Simulator.




      </Remarks>
    </openfeint.init>
    <openfeint.launchDashboard>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Launches the OpenFeint dashboard in one of the following configurations: leaderboards, challenges, achievements, friends, playing, or high score.
        Note: This API has been deprecated by the gameNetwork API.


      </Description>
      <Syntax>

        openfeint.launchDashboard( dashBoardView, options )





      </Syntax>
      <Example>

        -- Displays OpenFeint leaderboards dashboard.
        openfeint.launchDashboard("leaderboards")
        openfeint.launchDashboard( "highscore", { leaderboardID="000000" } )





      </Example>
      <Parameters>

        dashBoardView

        String: The OpenFeint dashboard view to display. Must be one of the following values:

        "leaderboards"
        "challenges" (Not available on Android.)
        "achievements"
        "friends" (Not available on Android.)
        "playing" (Not available on Android.)
        "highscore" NOTE: in this case an additional options table (see below). (Not available on Android.)

        Note: The items listed above that are not available on Android can still be viewed by going to the leaderboards.
        options

        Table: When the dashboard view is "highscore", the table should contain the "leaderboardID" property whose value is the corresponding OpenFeint leaderboard id.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Simulator.
        Do the following to close the Dashboard:

        On Android the Menu button shows a "Exit Feint" button that will exit back to the Corona App. You can also use the Back button to exit (this will go through all the navigated OpenFeint screens and finally exit OpenFeint).
        On iOS, there is an "x" in the upper right coroner of the OpenFeint screen that closes the Dashboard..




      </Remarks>
    </openfeint.launchDashboard>
    <openfeint.setHighScore>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the user's high score. You can optionally specify a text string to display in place of the actual numeric high score on OpenFeint dashboards.
        Note: This API has been deprecated by the gameNetwork API.


      </Description>
      <Syntax>

        openfeint.setHighScore( { leaderboardID=ID, score=highScore [, displayText=displayString] } )





      </Syntax>
      <Example>

        openfeint.setHighScore( { leaderboardID="abc123", score=82342, displayText="82,342 pts" } )





      </Example>
      <Parameters>

        ID

        String: The ID of the leaderboard to which the high score will be posted.

        highScore

        Number: The new high score to post.

        displayString

        String: An optional string to display on the leaderboard in place of the numeric high score value provided by the highScore parameter.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Simulator.




      </Remarks>
    </openfeint.setHighScore>
    <openfeint.unlockAchievement>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Unlocks the specified achievement.
        Note: This API has been deprecated by the gameNetwork API.


      </Description>
      <Syntax>

        openfeint.unlockAchievement ( achievementID )





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        achievementID

        String: The ID of the achievement to unlock.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Simulator.




      </Remarks>
    </openfeint.unlockAchievement>
    <openfeint.uploadBlob>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Saves an arbitrary blob of game data in the cloud, using OpenFeint's "Network Save Card" feature.
        Use openfeint.downloadBlob() to retrieve data that has been previously saved with this method.
        Note: This API has been deprecated by the gameNetwork API.


      </Description>
      <Syntax>

        openfeint.uploadBlob( blobKey, blobData )





      </Syntax>
      <Example>

        openfeint.uploadBlob( "gameState", "some data to save about the game" )





      </Example>
      <Parameters>

        blobKey

        String: A key to identify the saved blob data.

        blobData

        String: The blob data to save. Can be any string up to the length allowed by OpenFeint.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        API is not available in Corona Simulator.
        This API is not available on Android.




      </Remarks>
    </openfeint.uploadBlob>
  </OpenFeint>
  <Operating_System_Facilities>
    <os.clock>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns an approximation of the amount in seconds of CPU time used by the program.
        This is a standard Lua function that returns the CPU in seconds. A run time of 5 seconds returns as 0.05. It counts from 0.00 to 0.99 before rolling over to 1.00. This function does not reset to 0.00 when run on an iOS 4 device. It's recommended to use system.getTimer API instead.


      </Description>
      <Syntax>

        os.clock()





      </Syntax>
      <Example>

        print( os.clock() )  -- display CPU time





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Number -- Returns an approximation of the amount in seconds of CPU time used by the program. A run time of 50 seconds is returned as 0.50





      </Returns>
      <Remarks>





      </Remarks>
    </os.clock>
    <os.date>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a string or a table containing date and time, formatted according to the given string format.


      </Description>
      <Syntax>

        os.date( [format [, time] ] )





      </Syntax>
      <Example>

        local date = os.date( "*t" )    -- returns table of date &amp; time values
        print( date.year, date.month )  -- print year and month
        print( date.hour, date.min )    -- print hour and minutes
         
        print( os.date( "%c" ) )        -- print out time/date string: e.g., "Thu Oct 23 14:55:02 2010"





      </Example>
      <Parameters>

        format
        If format starts with '!', then the date is formatted in Coordinated Universal Time. After this optional character, if format is the string "*t", then date returns a table with the following fields: year (four digits), month (1--12), day (1--31), hour (0--23), min (0--59), sec (0--61), wday (weekday, Sunday is 1), yday (day of the year), and isdst (daylight saving flag, a boolean).
        If format is not "*t", then date returns the date as a string, formatted according to the same rules as the C function strftime.
        Use "!*t" to return the time in Universal Coordinated Time (UTC) format.
        time
        If the time argument is present, this is the time to be formatted (see the os.time function for a description of this value). Otherwise, date formats the current time.
        When called without arguments, date returns a reasonable date and time representation that depends on the host system and on the current locale (that is, os.date() is equivalent to os.date("%c") ).





      </Parameters>
      <Returns>

        Returns a string or a table containing date and time.





      </Returns>
      <Remarks>





      </Remarks>
    </os.date>
    <os.difftime>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the number of seconds from time t1 to time t2. In POSIX, Windows, and some other systems, this value is exactly t2-t1.


      </Description>
      <Syntax>


        os.difftime( t1, t2 )





      </Syntax>
      <Example>

        local t1 = os.time()
         
        -- Print the elasped time
        local function dspTime()
                print( "Time elasped = " .. os.difftime( os.time(), t1) )
        end
         
        timer.performWithDelay( 2000, dspTime )  -- wait 2 second before calling function





      </Example>
      <Parameters>

        t1
        First time parameter.
        t2
        Second time parameter.





      </Parameters>
      <Returns>

        Number -- returns the number of seconds from time t1 to time t2.





      </Returns>
      <Remarks>





      </Remarks>
    </os.difftime>
    <os.execute>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Passes a string to the operating system for execution and returns a system-dependent status code. This function is equivalent to the C function system().


      </Description>
      <Syntax>

        os.execute( cmd )





      </Syntax>
      <Example>

        os.execute( "ls" )





      </Example>
      <Parameters>

        cmd

        String specifying a command to be executed by an operating system shell. The function of this command depends on what is allowed by the running OS.





      </Parameters>
      <Returns>

        Number: status code with the system-dependent results of the command.
        If cmd is not specified, the return value is nonzero if a shell is available, and zero otherwise.





      </Returns>
      <Remarks>

        This function is only available in the Corona simulator.  It does not work on the device.




      </Remarks>
    </os.execute>
    <os.exit>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Calls the C function exit(), with an optional code, to terminate the host program. The default value for code is the success code.


      </Description>
      <Syntax>

        os.exit( [exit] )





      </Syntax>
      <Example>

        os.exit()   -- exit app





      </Example>
      <Parameters>

        exit
        Optional parameter that returns the Exit code to the OS.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </os.exit>
    <os.remove>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Deletes a file or directory.


      </Description>
      <Syntax>

        os.remove( file )





      </Syntax>
      <Example>

        local destDir = system.DocumentsDirectory  -- where the file is stored
        local results, reason = os.remove( system.pathForFile( "apple.txt", destDir  ) )
         
        if results then
           print( "file removed" )
        else
           print( "file does not exist", reason )
        end
        --&gt; file does not exist    apple.txt: No such file or directory





      </Example>
      <Parameters>

        file
        String specifying the name of the file or directory to remove.





      </Parameters>
      <Returns>

        result [, reason]

        result: Boolean, true if was file successfully removed.

        reason: nil if remove was successful, or a string describing the reason for failure.





      </Returns>
      <Remarks>

        Note: You can only remove files in the DocumentsDirectory and TemporaryDirectory. Files in the ResourceDirectory are read-only.




      </Remarks>
    </os.remove>
    <os.rename>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Renames a file or directory.


      </Description>
      <Syntax>

        os.rename( oldname, newname )





      </Syntax>
      <Example>

        local destDir = system.DocumentsDirectory  -- where the file is stored
        local results, reason = os.rename( system.pathForFile( "orange.txt", destDir  ),
                system.pathForFile( "apple.txt", destDir  ) )
         
        if results then
           print( "file renamed" )
        else
           print( "file not renamed", reason )
        end
        --&gt; file not renamed    orange.txt: No such file or directory





      </Example>
      <Parameters>

        oldname
        Old file name.
        newname
        New file name.





      </Parameters>
      <Returns>

        Returns boolean -- true if file was renamed and false if file not found.

        Also returns a string with reason for failure, nil if rename was successful.





      </Returns>
      <Remarks>

        Note: You can only rename files in the DocumentsDirectory and TemporaryDirectory. Files in the ResourceDirectory are read-only.




      </Remarks>
    </os.rename>
    <os.time>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the current time when called without arguments, or a time representing the date and time specified by the given table.


      </Description>
      <Syntax>

        os.time( [table] )





      </Syntax>
      <Example>

        local t = os.date( '*t' )  -- get table of current date and time
        print( os.time( t ) )      -- print date &amp; time as number of seconds
        --&gt; 1287516614
         
        t.min = t.min + 1  )       -- add one to the minute field
        print( os.time( t ) )      -- print number of seconds (increases by 60 seconds)
        --&gt;  1287516674





      </Example>
      <Parameters>

        table
        (Optional) table specifying a time to convert to seconds.
        If table is present, it must have fields year, month, and day, and may have additional fields hour, min, sec, and isdst (for a description of these fields, see the os.date function).





      </Parameters>
      <Returns>

        The current time in seconds, or the number of seconds corresponding to the table parameter.





      </Returns>
      <Remarks>





      </Remarks>
    </os.time>
  </Operating_System_Facilities>
  <Physics>
    <physics.addBody>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Allows you to turn any Corona display object into a simulated physical object with one line of code, including the assignment of physical properties.
        If no shape information is specified, then the body boundaries will snap to the rectangular boundaries of the display object used to create the physics body.
        If a radius is specified, then the body boundaries will be circular, centered at the middle of the display object used to create the physics body.
        If a shape is specified, then the body boundaries will follow the polygon provided by the shape. Note that the maximum number of sides per shape is eight, and all angles must be convex. (Specifying a shape will override the radius property, if both radius and shape are specified in the same element.) The shape coordinates must be defined in clockwise order, and the resulting shape must be convex-only.
        A body shape is simply a table of local (x,y) coordinates, relative to the center of the display object; see example below.
        Finally, a more complex body may be constructed by specifying multiple body elements and shapes. In cases where the overall shape of the object is concave, or the shape has more than eight sides, you can use multiple body elements to construct it.
        Each body element may have its own physical properties, and the body element index is reported as part of each collision event -- so it is possible to detect which part of a complex body was involved in a collision.
        Note

        When you turn a display object into a physics object, the Physics engine owns the object and has its own rules about the object. Physics assumes the reference point of the object is the center of the object so object:setReferencePoint() may change the reference point from Corona's Display Object point of view but not for the Physics engine. This affects collisions and how other physics bodies interact..
        The same goes for scaling and rotating the object. You can scale the object up or down and rotate it but the Physics engine still sees the object as it was before the changes.
        You can see how the Physics engine view the object with physics.setDrawMode("debug").
        For further information, see Physics Bodies.


      </Description>
      <Syntax>

        physics.addBody(object, [bodyType,] {density=d, friction=f, bounce=b [,radius=r] [,filter=f]})

      </Syntax>
      <Example>

        Default (rectangular) bodies

        local physics = require( "physics" )
        physics.start()
         
        local sky = display.newImage( "bkg_clouds.png" )
        sky.x = 160; sky.y = 195
         
        local ground = display.newImage( "ground.png" )
        ground.x = 160; ground.y = 445
         
        physics.addBody( ground, "static", { friction=0.5, bounce=0.3 } )
         
        local crate = display.newImage( "crate.png" )
        crate.x = 180; crate.y = -50; crate.rotation = 5
         
        physics.addBody( crate, { density=3.0, friction=0.5, bounce=0.3 } )
        Circular bodies

        local ball = display.newImage("ball.png")
         
        physics.addBody( ball, { density = 1.0, friction = 0.3, bounce = 0.2, radius = 25 } )
        Polygon bodies

        local pentagon = display.newImage("pentagon.png")
         
        pentagonShape = { 0,-37, 37,-10, 23,34, -23,34, -37,-10 }
         
        physics.addBody( pentagon, { density=3.0, friction=0.8, bounce=0.3,
        shape=pentagonShape } )





      </Example>
      <Parameters>

        object

        object: A display object.
        bodyType

        string: The body type may be specified in an optional string parameter before the first body element. The possible types are â€œstaticâ€, â€œdynamicâ€ and â€œkinematicâ€, and the default type is â€œdynamicâ€ if no value is specified.
        density

        number: Multiplied by the area of the bodyâ€™s shape to determine mass. Based on a standard value of 1.0 for water. Lighter materials (such as wood) have a density below 1.0, and heavier materials (such as stone) have a density greater than 1.0.  Default value is 1.0.
        friction

        number: May be any non-negative value; a value of 0 means no friction and 1.0 means fairly strong friction. The default value is 0.3.
        bounce

        number: Determines how much of an objectâ€™s velocity is returned after a collision. The default value is 0.2.
        radius

        number: Radius of the bounding circle.
        shape

        number: Shape value in the form of a table with the shape vertices, {x1,y1,x2,y2,...,xn,yn}. For example: squareShape = { -20,-10, 20,-10, 20,10, -20,10 }

        The coordinates must be defined in clockwise order, and the resulting shape must be convex-only. (Physics assume the 0,0 point of an object, is the center of the object. A -x will be to the left of object's center and -y will be top of object's center.)
        filter

        table: Filter values.

        categoryBits = cb where cb is category of object (generally only one bit set). Defaults to 0x0001 if not set.

        maskBits = mb, where mb is the categories that shape would accept for collision. Defaults to 0xFFFF

        groupIndex = gb, where gb specifies that a certain group of objects will never collide (negative) or always collide (positive). Defaults to 0 (disabled). If groupIndex is set to non-zero, it overrides maskBits setting.

        See Collision categories, masking, and groups.





      </Parameters>
      <Returns>

        Starting with build 2011.598, returns true if the API succeeded or false if it failed. (The API will fail if called in any Collision Event handler.)





      </Returns>
      <Remarks>

        Note: This API should not be used in a Collision Event handler.
        Starting with build 2011.598, this API returns false and display a warning message in the simulator if the API cannot be processed. Before build 2011.598, calling the API may crash the simulator and the app when running on the device.




      </Remarks>
    </physics.addBody>
    <physics.getGravity>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the x,y components of the global gravity vector, in units of m/s2. This takes advantage of the fact that Lua functions can return multiple values.


      </Description>
      <Syntax>

        gx, gy = physics.getGravity()





      </Syntax>
      <Example>

        gx, gy = physics.getGravity()
        print( "X gravity: " .. gx .. ", Y gravity: " .. gy )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        gx

        The global gravity vector in X direction, in units of m/s2.
        gy

        The global gravity vector in Y direction, in units of m/s2.





      </Returns>
      <Remarks>





      </Remarks>
    </physics.getGravity>
    <physics.newJoint>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Joints are used to assemble more complex game objects from multiple rigid bodes. To construct a joint, first construct the bodies that will be joined, and then call this method with the desired joint constructor type.
        To remove a joint, use joint:removeSelf( )
        NOTE: This API reference page is incomplete.  See the Physics Joint Guide to see how to deal with the various joints.


      </Description>
      <Syntax>

        physics.newJoint( jointType, object1, object2, anchorX, anchorY )





      </Syntax>
      <Example>

        myJoint = physics.newJoint( "pivot", crateA, crateB, 200,300 )





      </Example>
      <Parameters>

        jointType

        string: One of the following joint types:

        pivot
        distance
        piston
        friction
        weld
        wheel
        pulley
        touch

        object1

        First object used in joint.
        object2

        Second object used in joint.
        anchorX

        Defines the X-location of the joint anchor point.
        anchorY

        Defines the Y-location of the joint anchor point.





      </Parameters>
      <Returns>

        Joint object
        Starting with build 2011.598, returns joint object if the API succeeded or nil if it failed. (The API will fail if called in any Collision Event handler.)





      </Returns>
      <Remarks>

        Note: This API should not be used in a Collision Event handler.
        Starting with build 2011.598, this API returns nil and display a warning message in the simulator if the API cannot be processed. Before build 2011.598, calling the API may crash the simulator and the app when running on the device.




      </Remarks>
    </physics.newJoint>
    <physics.pause>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Pause the physics engine.


      </Description>
      <Syntax>

        physics.pause()





      </Syntax>
      <Example>

        physics.pause()





      </Example>
      <Parameters>

        none





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </physics.pause>
    <physics.removeBody>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Removes a physics body from a display object without destroying the entire object. This removes the body created with physics.addBody.
        Note: This only removes the physics body from the display object -- the display object still exists after calling this API.


      </Description>
      <Syntax>

        result = physics.removeBody( object )





      </Syntax>
      <Example>

        if not physics.removeBody( object ) then
            print( "Could not remove Physics body" )
        end





      </Example>
      <Parameters>

        Display Object

        The physics object to be removed.





      </Parameters>
      <Returns>

        Boolean

        Returns true if the body was removed and false if the call failed. (The API will fail if called in any Collision Event handler.)





      </Returns>
      <Remarks>

        Note: This API cannot be used in a Collision Event handler.
        *** This API was added starting with Daily Build 2011.598. It's not available in the 2011.591 Release build. ***




      </Remarks>
    </physics.removeBody>
    <physics.setDrawMode>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Selects one of three possible rendering modes for the physics engine. This mode may be changed at any time -- see the "DebugDraw" sample project for an example of how to toggle it on the fly.
        While this feature will also run on devices, it will probably be most useful in the Corona Simulator, when debugging unexpected physics engine behavior.


      </Description>
      <Syntax>

        physics.setDrawMode( mode )





      </Syntax>
      <Example>

        physics.setDrawMode( "debug" ) -- shows collision engine outlines only
        physics.setDrawMode( "hybrid" ) -- overlays collision outlines on normal Corona objects
        physics.setDrawMode( "normal" ) -- the default Corona renderer, with no collision outlines





      </Example>
      <Parameters>

        mode

        Rendering modes: "debug", "hybrid", or "normal"





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        The physics data is displayed using color-coded vector graphics, which reflect different object types and attributes:
        * Orange: dynamic physics bodies (the default body type)

        * Dark blue: kinematic physics bodies

        * Green: static physics bodies, such as the ground or walls

        * Gray: a body that is "sleeping" due to lack of activity

        * Light blue: joints
        NOTE: While the physics debug draw renderer should correctly account for physics objects in nested display groups, it will display misleading results if display groups are rotated or scaled. This will be addressed in a future release.




      </Remarks>
    </physics.setDrawMode>
    <physics.setGravity>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the x,y components of the global gravity vector, in units of m/s2. The default is ( 0, 9.8 ) to simulate standard Earth gravity, pointing downwards on the y-axis.


      </Description>
      <Syntax>

        physics.setGravity( gx, gy )





      </Syntax>
      <Example>

        local function onTilt( event )
                physics.setGravity( 10 * event.xGravity, -10 * event.yGravity )
        end
         
        Runtime:addEventListener( "accelerometer", onTilt )





      </Example>
      <Parameters>

        gx

        Sets the global gravity vector in X direction, in units of m/s2.
        gy

        Sets the global gravity vector in Y direction, in units of m/s2.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </physics.setGravity>
    <physics.setPositionIterations>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the accuracy of the engine's position calculations.


      </Description>
      <Syntax>

        physics.setPositionIterations( value )





      </Syntax>
      <Example>

        physics.setPositionIterations( 16 ) -- changes iterations from the default value of 8





      </Example>
      <Parameters>

        value

        Iteration value. The default value is 8, which means that the engine will iterate through eight position approximations per frame for each object. Increasing this number will cause fewer momentary inaccuracies (overlapping objects. etc.) but will increase computational overhead. The default value should be good for most general cases.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </physics.setPositionIterations>
    <physics.setScale>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the internal pixels-per-meter ratio that is used in converting between onscreen Corona coordinates and simulated physics coordinates. This should be done only once, before any physical objects are instantiated.
        Changing this value has no visual consequences, and simply affects the accuracy of the physical model. The Box2D engine is tuned for simulating medium-sized objects between 0.1m and 10m in size, so it works best when the objects in your game are mapped to physical properties that fall roughly within this range.
        The default scaling value is 30, which means that the optimal 0.1m to 10m range corresponds to visible sprites between 3 and 300 pixels in size, which should cover most typical iPhone content. For higher-resolution devices like iPad, Android, or iPhone 4, you may wish to increase this value to 60 or more.


      </Description>
      <Syntax>

        physics.setScale( value )





      </Syntax>
      <Example>

        physics.setScale( 60 ) -- changes the scale from the default value of 30





      </Example>
      <Parameters>

        value

        Sets the scale value. The default scaling value is 30, which means that the optimal 0.1m to 10m range corresponds to visible sprites between 3 and 300 pixels in size, which should cover most typical iPhone content. For higher-resolution devices like iPad, Android, or iPhone 4, you may wish to increase this value to 60 or more.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        You may also want to increase this value if the objects you are simulating are relatively small. As a rough guide, take the width of a sprite in pixels and divide it by its real-world width, if any. For example, a basketball is about 0.25 meters across, so a 20-pixel basketball sprite suggests a physics scaling factor of roughly (20 / 0.25) = 80. However, the resulting effect also depends on how much your chosen density (mass) values approximate the "real world". Therefore, you should ultimately set this scaling factor to whatever feels right within the context of your game: if objects seem too sluggish, and fall too slowly, then they are too big and heavy for your purposes -- try raising the scaling value and/or reducing their densities.
        Note that this pixels-per-meter factor is relative to your original content dimensions, if you use the Corona content scaling features to deploy the same code across different screen resolutions (such as iPhone and Android). See the Corona API Reference for more information on autoscaling content for multiple screens.
        Also, since onscreen objects are not resized when this value is changed, the visible simulation may behave strangely if it is changed while physical objects are already onscreen. In other words, this setting is not the correct way to visibly scale the world. To do that, you should add all the game objects to a common Corona display group, which will cause the simulation to operate according to the groupâ€™s internal coordinates rather than the global stage coordinates, and then scale or pan that group. See the â€œEggBreakerâ€ sample code for a demonstration of this technique.




      </Remarks>
    </physics.setScale>
    <physics.setVelocityIterations>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the accuracy of the engine's velocity calculations.


      </Description>
      <Syntax>

        physics.setVelocityIterations( value )





      </Syntax>
      <Example>

        physics.setVelocityIterations( 6 ) -- changes number of iterations from the default of 3





      </Example>
      <Parameters>

        value

        The number of iterations. The default value is 3, which means that the engine will iterate through three velocity approximations per frame for each object. Increasing this number will cause fewer momentary inaccuracies (overlapping objects. etc.) but will increase computational overhead. The default value should be good for most general cases.





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>





      </Remarks>
    </physics.setVelocityIterations>
    <physics.start>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This function start the physics simulation and should be called before any other physics functions.
        By default, Box2D bodies not involved in a collision will "sleep" after a couple of seconds. This reduces overhead, but in some cases you may not want this behavior. For example, the "ShapeTumbler" sample code will not work well if bodies are allowed to sleep, since sleeping bodies do not respond to changes in the direction of gravity.
        You can override this behavior on a given body with body.isSleepingAllowed = false, but you can also override this globally for all bodies in the world by using an optional boolean parameter in start:


      </Description>
      <Syntax>

        physics.start( noSleep )





      </Syntax>
      <Example>

        physics.start( true ) -- starts the Physics engine and prevents all bodies from sleeping





      </Example>
      <Parameters>

        boolean

        true prevent all bodies from sleeping.

        false allows all bodies to sleep (default mode).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note:

        require( "physics" ) and physics.start() must be at the top of the main.lua file.




      </Remarks>
    </physics.start>
    <physics.stop>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Stops the physics engine.


      </Description>
      <Syntax>

        physics.stop()





      </Syntax>
      <Example>

        physics.stop()





      </Example>
      <Parameters>

        none





      </Parameters>
      <Returns>

        Nothing (builds before 598).
        Starting with build 2011.598, this API returns false and display a warning message in the simulator if the API cannot be processed. Before build 2011.598, calling the API may crash the simulator and the app when running on the device.





      </Returns>
      <Remarks>

        Note: This API cannot be used in a Collision Event handler.




      </Remarks>
    </physics.stop>
  </Physics>
  <Bodies>
    <body.isBodyActive>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A boolean to set or get the bodies current active state. Inactive bodies are not destroyed, but they are removed from the simulation and cease to interact with other bodies.
        Note:
        You cannot change the body's active state during a collision event. However you can change the body's active state during a collision event if you use a slight (un-noticeable) delay.
        For example :
        --Collision event
        local function delay()
            --Change the body's active state to false
            body.isBodyActive = false
        end
         
        timer.performWithDelay(10, delay)


      </Description>
      <Syntax>

        body.isBodyActive





      </Syntax>
      <Example>

        --Create a rectangle
        local myRect = display.newRect(0, 0, 100, 100)
         
        --Add a body to the rectangle
        physics.addBody(myRect, "kinemetic", {isSensor = false})
         
        --Set the rectangle's body active state
        myRect.isBodyActive = true
         
        -- (Optional) assign a local variable to hold the angular damping value
        local value = myRect.isBodyActive





      </Example>
      <Parameters>

        Boolean

        New state of the physics body: true for active or false for inactive.





      </Parameters>
      <Returns>

        Boolean

        Current state of the physics body: true for active or false for inactive.





      </Returns>
      <Remarks>

        Note: This API cannot be used in a Collision Event handler or unexpected results may occur.
        Starting with build 2011.598, this API displays a warning message in the simulator if the API cannot be processed. Before build 2011.598, calling the API may crash the simulator and the app when running on the device.




      </Remarks>
    </body.isBodyActive>
    <body.isSensor>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A boolean value that, if set to true, prevents any visible collisions from happening to the object, although "began" and "ended" collision events are still fired.
        One use case for setting this property is overriding a collision that is about to happen, such as the "one-sided platform" case, where a character should pass through a platform only in one direction.
        Note that in Box2D, isSensor is a property of a specific fixture, or in Corona terms, a "body element"--it is not a property of the entire body. However, since the Corona physics APIs don't currently expose access to individual body elements, it is not currently possible to set properties on individual body elements. Consequently, setting isSensor is set for the entire body. One implication is that for complex physics bodies, where some elements are sensors and some are not, using the body.isSensor property will permanently override the individual body element settings.
        Note: You can only set this property. Reading the property returns 'nil'.


      </Description>
      <Syntax>

        body.isSensor





      </Syntax>
      <Example>


        In this sample there are two static platforms named platform1 (top) and platform2 (bottom). Another dynamic physics body (box) being acted on by gravity is allowed to conditionally pass through the first platform (#1) by settings the platform's isSensor property to true. The body stops at the second platform.
        local physics = require("physics")
        physics.start()
        display.setStatusBar( display.HiddenStatusBar )
         
        local platform1 = display.newRect( 20, 200, 280, 15 )
        platform1.myName = "platform1"
        physics.addBody(platform1, "static")
         
        local platform2 = display.newRect( 20, 320, 280, 15 )
        platform2.myName = "platform2"
        physics.addBody(platform2, "static")
         
        local box = display.newRect( 20, 20, 50, 50 )
        box:setFillColor(255,255,0,255)
        box.myName = "box"
        physics.addBody(box)
         
        local function onLocalPreCollision( self, event )
                -- Let box pass through platform 1
                local platform = event.other
                if platform.myName == "platform1" then
                        platform.isSensor = true
                end
        end
         
        box.preCollision = onLocalPreCollision
        box:addEventListener( "preCollision", box )





      </Example>
      <Parameters>

        value

        Set to true to prevent the collision. false to allow the collision.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </body.isSensor>
    <body.isSleepingAllowed>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A boolean for whether the body is ever allowed to go to sleep. Keeping bodies awake has a larger overhead, and is often not required, because collisions with other bodies will automatically wake them up. However, forcing awakeness is useful in cases such as the tilt-gravity case (since sleeping bodies do not respond to changes in global gravity). The default is true.


      </Description>
      <Syntax>

        value = body.isSleepingAllowed





      </Syntax>
      <Example>

        local state = myBody.isSleepingAllowed





      </Example>
      <Parameters>

        value

        A boolean for whether the body is ever allowed to go to sleep: true or false. Default is true (body is allowed to sleep).





      </Parameters>
      <Returns>

        A boolean for whether the body is ever allowed to go to sleep.





      </Returns>
      <Remarks>





      </Remarks>
    </body.isSleepingAllowed>
    <body..applyAngularImpulse>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Like applyTorque, except that an angular impulse is a single, momentary jolt.


      </Description>
      <Syntax>

        body:applyAngularImpulse( appliedForce )





      </Syntax>
      <Example>

        myBody:applyAngularImpulse( 100 )





      </Example>
      <Parameters>

        appliedForce

        number: force to apply





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </body..applyAngularImpulse>
    <body..applyForce>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        A function that accepts x,y components of a linear force, applied at a given point with x,y world coordinates. If the target point is the body's center of mass, it will tend to push the body in a straight line; if the target is offset from the body's center of mass, the body will spin about its center of mass.

        For symmetrical objects, the center of mass and the center of the object will have the same position: (object.x, object.y). Also note that the amount of force may need to be fairly high to move heavy objects.


      </Description>
      <Syntax>

        body:applyForce( xForce, yForce, bodyX, bodyY )





      </Syntax>
      <Example>

        myBody:applyForce( 500, 2000, myBody.x, myBody.y )





      </Example>
      <Parameters>

        xForce

        number: force in the x-direction
        yForce

        number: force in the y-direction
        bodyX

        number: point to apply force
        bodyY

        number: point to apply force





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </body..applyForce>
    <body..applyLinearImpulse>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Like applyForce, except that an impulse is a single, momentary jolt.


      </Description>
      <Syntax>

        body:applyLinearImpulse( xForce, yForce, bodyX, bodyY )





      </Syntax>
      <Example>

        myBody:applyLinearImpulse( 600, 200, myBody.x, myBody.y )





      </Example>
      <Parameters>

        xForce

        number: force in the x-direction
        yForce

        number: force in the y-direction
        bodyX

        number: point to apply force
        bodyY

        number: point to apply force





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </body..applyLinearImpulse>
    <body..applyTorque>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        A function that accepts a numerical value for applied rotational force. The body will rotate about its center of mass.


      </Description>
      <Syntax>

        body:applyTorque( appliedForce )





      </Syntax>
      <Example>

        myBody:applyTorque( 100 )





      </Example>
      <Parameters>

        appliedForce





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </body..applyTorque>
    <body..setLinearVelocity>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        A function that accepts x,y components for the body's linear velocity, in pixels per second.


      </Description>
      <Syntax>

        body:setLinearVelocity( xVelocity, yVelocity )





      </Syntax>
      <Example>

        myBody:setLinearVelocity( 2, 4 )





      </Example>
      <Parameters>

        xVelocity

        number: Value for the velocity in the x-direction in pixels per second.
        yVelocity

        number: Value for the velocity in the y-direction in pixels per second.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </body..setLinearVelocity>
  </Bodies>
  <Joints>
    <joint.dampingRatio>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The joint's damping ratio. Valid values ranges from 0 (no damping) to 1 (critical damping).
        For use with Distance joints.


      </Description>
      <Syntax>

        joint.dampingRatio





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.dampingRatio>
    <joint.frequency>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The mass-spring damping frequency (in Hz).
        For use with Distance joints.


      </Description>
      <Syntax>

        joint.frequency





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.frequency>
    <joint.isLimitEnabled>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A boolean that specifies whether the joint is limited (true) or not (false).
        For use with Pivot, Piston, and Wheel joints.


      </Description>
      <Syntax>

        joint.isLimitEnabled





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Format.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.isLimitEnabled>
    <joint.isMotorEnabled>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A boolean that indicates whether the piston joint is enabled by a motor. Note that, unlike the pivot joint, motor-driven motion will be linear, along the specified axis, rather than rotational.
        For use with Pivot, Piston, and Wheel joints.


      </Description>
      <Syntax>

        joint.isMotorEnabled





      </Syntax>
      <Example>

        if myJoint.isMotorEnabled then
          myJoint.motorSpeed = 10000
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.isMotorEnabled>
    <joint.jointAngle>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only that provides the current angle of the joint in degrees.
        For use with Pivot joints.


      </Description>
      <Syntax>

        joint.jointAngle





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.jointAngle>
    <joint.jointSpeed>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A number that provides the speed of the joint in degrees per second. Read-only.
        For use with Pivot, Piston, and Wheel joints.


      </Description>
      <Syntax>

        joint.jointSpeed





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Number





      </Returns>
      <Remarks>





      </Remarks>
    </joint.jointSpeed>
    <joint.jointTranslation>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A number that provides the linear translation of the joint in pixels. This property is read-only.
        For use with Piston and Wheel joints.


      </Description>
      <Syntax>

        joint.jointTranslation





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Number





      </Returns>
      <Remarks>





      </Remarks>
    </joint.jointTranslation>
    <joint.length>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The distance in pixels between the anchor points. The value you assign to this property should not be zero or very short. Consider using a pivot joint if you need to directly anchor one body to another.
        For use with Distance joints.


      </Description>
      <Syntax>

        joint.length





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.length>
    <joint.length1>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that provides the distance in pixels between the first joint anchor point and the stationary pulley anchor point.
        For use with Pulley joints.


      </Description>
      <Syntax>

        joint.length1





      </Syntax>
      <Example>

        myJoint = physics.newJoint( "pulley", crateA, crateB, anchorA_x,anchorA_y, anchorB_x,anchorB_y, crateA.x,crateA.y, crateB.x,crateB.y, 1.0 )
         
        myJoint.length1 -- (get-only; value in pixels)
        myJoint.length2 -- (get-only; value in pixels)
        myJoint.ratio -- (get-only)





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        Number





      </Returns>
      <Remarks>





      </Remarks>
    </joint.length1>
    <joint.length2>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that provides the distance in pixels between the second joint anchor point and the stationary pulley anchor point.
        For use with Pulley joints.


      </Description>
      <Syntax>

        joint.length2





      </Syntax>
      <Example>

        myJoint = physics.newJoint( "pulley", crateA, crateB, anchorA_x,anchorA_y, anchorB_x,anchorB_y, crateA.x,crateA.y, crateB.x,crateB.y, 1.0 )
         
        myJoint.length1 -- (get-only; value in pixels)
        myJoint.length2 -- (get-only; value in pixels)
        myJoint.ratio -- (get-only)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Number





      </Returns>
      <Remarks>





      </Remarks>
    </joint.length2>
    <joint.maxForce>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The maximum force that can be exerted on the joint.
        For use with Friction joints.


      </Description>
      <Syntax>

        joint.maxForce





      </Syntax>
      <Example>

         





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.maxForce>
    <joint.ratio>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        The â€œratioâ€ property is used to optionally simulate a block and tackle arrangement, in which one side of the rope moves faster than the other. By default, this ratio is 1.0, which simulates a simple pulley.
        This is used with the Pulley joint.


      </Description>
      <Syntax>

        value = joint.ratio





      </Syntax>
      <Example>

        myJoint = physics.newJoint( "pulley", crateA, crateB, anchorA_x,anchorA_y, anchorB_x,anchorB_y, crateA.x,crateA.y, crateB.x,crateB.y, 1.0 )
        length1 = myJoint.length1 -- (get-only; value in pixels)
        length2 = myJoint.length2 -- (get-only; value in pixels)
        ratio = myJoint.ratio -- (get-only)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value

        The pulley ratio. Default is 1.0.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.ratio>
    <joint.reactionTorque>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that returns the reaction torque (in N*m) at the joint anchor in the second body.
        This property is common to all joint types.


      </Description>
      <Syntax>

        value = joint.reactionTorque





      </Syntax>
      <Example>

        reactionTorque = myJoint.reactionTorque





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        value

        The reaction torque (in N*m) at the joint anchor in the second body.





      </Returns>
      <Remarks>





      </Remarks>
    </joint.reactionTorque>
    <joint..getLimits>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns the upper and lower limits of linear motion set on the joint with joint.setLimits().
        For use with Piston and Wheel joints.


      </Description>
      <Syntax>

        lower, upper = joint.getLimit()





      </Syntax>
      <Example>

        myJoint.isLimitEnabled = true
        myJoint:setLimits( 100, 200 )
        p1, p2 = myJoint:getLimits()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        The lower and upper motion limits as multiple values.





      </Returns>
      <Remarks>





      </Remarks>
    </joint..getLimits>
    <joint..getRotationLimits>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Returns the joint's rotation limits.


      </Description>
      <Syntax>

        lower, upper = joint:getRotationLimits()





      </Syntax>
      <Example>

        myJoint = physics.newJoint( "pivot", crateA, crateB, 200,300 )
        myJoint.isLimitEnabled = true
        myJoint:setRotationLimits( -45, 45 )
        lowerLimit, upperLimit = myJoint:getRotationLimits()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint..getRotationLimits>
    <joint..setLimits>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets lower and upper limits on the joint's range of linear motion.
        For use with Piston and Wheel joints.


      </Description>
      <Syntax>

        joint:setLimits(upper, lower)





      </Syntax>
      <Example>

        myJoint.isLimitEnabled = true
        myJoint:setLimits( 100, 200 )
        p1, p2 = myJoint:getLimits()





      </Example>
      <Parameters>

        lower

        Number: The joint's lower limit of linear motion.

        upper

        Number: The joint's upper limit of linear motion.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint..setLimits>
    <joint..setRotationLimits>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Sets upper and lower rotation limits on the joint in degrees.
        For use with Pivot joints.


      </Description>
      <Syntax>

        joint:setRotationLimits( lowerLimit, upperLimit )





      </Syntax>
      <Example>

        myJoint = physics.newJoint( "pivot", crateA, crateB, 200,300 )
        myJoint.isLimitEnabled = true
        myJoint:setRotationLimits( -45, 45 )





      </Example>
      <Parameters>

        lowerLimit

        The lower rotation limit in degrees from zero (0).

        upperLimit

        The upper rotation limit in degrees from zero (0).





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </joint..setRotationLimits>
  </Joints>
  <Sprite_Sheets_>
    <sprite.add>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Adds a named sequence to the sprite set with the specified frames. You specify the start frame and the number of frames in the sequence, as well as the length in milliseconds over which the sequence will play, which lets you change the frame rate.


      </Description>
      <Syntax>

        sprite.add( spriteSet, sequenceName, startFrame, frameCount, time, [loopParam] )





      </Syntax>
      <Example>

        local sheet1 = sprite.newSpriteSheet( "runningcat.png", 512, 256 )
        local spriteSet1 = sprite.newSpriteSet(sheet1, 1, 8)
        sprite.add( spriteSet1, "cat", 1, 8, 1000, 0 ) -- play 8 frames every 1000 ms
        local instance1 = sprite.newSprite( spriteSet1 )
        instance1:prepare("cat")
        instance1:play()





      </Example>
      <Parameters>

        spriteSet

        Table: The sprite set object from which to create the sequence.
        sequenceName

        String: The name of the new sequence.
        startFrame

        Number: The number the first frame in the sequence.  The frame number is based on the first frame beginning at 1 (not 0).
        frameCount

        Number: The total number of frames in the sequence. Must be a positive number.
        time

        Number: The length of the animation in milliseconds.
        loopParam

        Number: (Optional) Controls the looping behavior of the sequence.

        A value of 0 (the default) means that the sequence will loop indefinitely.
        A value of 1 means the sequence will play through once and stop on the last frame; 2 means the sequence will play twice; etc.
        A value of -1 means that the sequence will "bounce" back and forth exactly once. For example, a three frame sequence would play frames 1, 2, 3, 2, 1, and then stop.
        Finally, a value of -2 means that the sequence will bounce back and forth forever (for example, 1, 2, 3, 2, 1, 2, 3, 2, 1, etc.).






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </sprite.add>
    <sprite.newSprite>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Create a new instance of a sprite. A sprite is a DisplayObject. Sprites play one animation sequence at a time.


      </Description>
      <Syntax>

        sprite.newSprite( spriteSet )





      </Syntax>
      <Example>

        local sheet1 = sprite.newSpriteSheet( "runningcat.png", 512, 256 )
        local spriteSet1 = sprite.newSpriteSet(sheet1, 1, 8)
        sprite.add( spriteSet1, "cat", 1, 8, 1000, 0 ) -- play 8 frames every 1000 ms
        local instance1 = sprite.newSprite( spriteSet1 )
        instance1:prepare("cat")
        instance1:play()





      </Example>
      <Parameters>

        spriteSet

        Table: The sprite set from which to create the sprite.





      </Parameters>
      <Returns>

        spriteInstance

        A new sprite display object that can be played.





      </Returns>
      <Remarks>





      </Remarks>
    </sprite.newSprite>
    <sprite.newSpriteMultiSet>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a new sprite set from multiple sprite sheets. Allows sprite sets to be define with frames in any order.
        A sprite set is a Lua table containing keys to one or more animation sequences for a given character.
        Note: See the code in the Remarks section when switching sprite sets to avoid the "tearing" effect.


      </Description>
      <Syntax>

        sprite.newSpriteMultiSet({{ sheet = spriteSheet1, frames = { n1, n2, n3, ... }},...})





      </Syntax>
      <Example>

        local evenSheet = sprite.newSpriteSheetFromData( "even.png", require("even").getSpriteSheetData() )
        local oddSheet = sprite.newSpriteSheetFromData( "odd.png", require("odd").getSpriteSheetData() )
         
        -- This set is a series of frames from both sheets.
        local spriteSet2 = sprite.newSpriteMultiSet(
           {
              { sheet = oddSheet, frames = { 1, 2, 3, 4, 5 } },    -- Frames from one sheet
              { sheet = oddSheet, frames = { 3, 3, 3 } },        -- Frames may be duplicated
              { sheet = evenSheet, frames = { 1, 4, 2, 3 } },    -- Frames from another sheet in any order
           }
        )





      </Example>
      <Parameters>

        sheet

        The sprite sheet object from which to create the sprite set.
        frames

        Table defining the frames and frame order to be included in the sprite set. The frame number is based on the first frame beginning at 1 (not 0).





      </Parameters>
      <Returns>

        A sprite set.





      </Returns>
      <Remarks>

        Because of a timing problem when switching from one sprite to another, a delay needs to be added when switching sprites to avoid "tearing". A pause() should be added when switching a sprite that is currently running.

        1
        2
        3
        4
        5
        6
        7
        8
        function switch()
            if anim.sequence == "idle" then
                anim:pause()
                timer.performWithDelay( 33, function() anim:prepare( "walking" ); anim:play() end )
            else
                anim:pause()
                timer.performWithDelay( 33, function() anim:prepare( "idle" ); anim:play() end )
            end




      </Remarks>
    </sprite.newSpriteMultiSet>
    <sprite.newSpriteSet>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a new sprite set from a sprite sheet. Since a single sprite sheet may contain images from unrelated game characters, a â€œsprite setâ€ defines the collection of frames that belong to the same game character, which may then be subdivided into different animation sequences for playback. For example, a fighting game character would probably have different animation sequences for punching and for kicking, but these would be defined within the same sprite set.
        A sprite set is a Lua table containing keys to one or more animation sequences for a given character. Each sprite set is created with an initial sequence named "default", containing all frames in the set, so you can either use this default sequence immediately or define further animation sequences within the set.
        Use sprite.add() to add other sequences to the sprite set.


      </Description>
      <Syntax>

        spriteSet = sprite.newSpriteSet( spriteSheet, startFrame, frameCount )





      </Syntax>
      <Example>

        -- A sprite sheet with a cat
        local sheet1 = sprite.newSpriteSheet( "runningcat.png", 512, 256 )
        local spriteSet1 = sprite.newSpriteSet(sheet1, 1, 8)
        sprite.add( spriteSet1, "cat", 1, 8, 1000, 0 ) -- play 8 frames every 1000 ms          
        local instance1 = sprite.newSprite( spriteSet1 )
        instance1:prepare("cat")
        instance1:play()      





      </Example>
      <Parameters>

        spriteSheet

        The sprite sheet object from which to create the sprite set.
        startFrame

        Number: The index number of the first frame of the sprite, using the index defined in newSpriteSheet() above, and frameCount is the total number of frames in the set. The frame number is based on the first frame beginning at 1 (not 0).
        frameCount

        Number: The number of frames in the set.





      </Parameters>
      <Returns>

        A sprite set.





      </Returns>
      <Remarks>





      </Remarks>
    </sprite.newSpriteSet>
    <sprite.newSpriteSheet>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a new sprite sheet object from an sprite sheet image file whose animation frames are all the same height and width. To use a sprite sheet with non-uniformly spaced animation frames, use newSpriteSheetFromData().


      </Description>
      <Syntax>

        sprite.newSpriteSheet( spriteSheetFile, [baseDir,]  frameWidth, frameHeight )





      </Syntax>
      <Example>

        The following code dreates a new sprite sheet from a sprite sheet image file named "running_man.png" whose animation frames are all 100x100 pixels square.
          local runningMan = sprite.newSpriteSheet("running_man.png", 100, 100)
         





      </Example>
      <Parameters>

        spriteSheetFile

        String: Specifies the name of the sprite sheet image file.
        baseDir (optional)

        The base directory where the sprite sheet image file is located.  If specified, may be system.ResourceDirectory, system.DocumentsDirectory, or

        system.TemporaryDirectory.
        frameWidth

        Number: Specifies the width of each animation frame in the sprite sheet image file.
        frameHeight

        Number: Specifies the height of each animation frame in the sprite sheet image file.





      </Parameters>
      <Returns>

        A sprite sheet object.





      </Returns>
      <Remarks>





      </Remarks>
    </sprite.newSpriteSheet>
    <sprite.newSpriteSheetFromData>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Creates a new sprite sheet from a sprite sheet image file and data, provided in a Lua table, that describes the sizes and positions of each frame in the sprite sheet image file.
        This API is used for sprite sheets that have frames with non-uniform sizes and positions.


      </Description>
      <Syntax>

        sprite.newSpriteSheetFromData( spriteSheetImageFile, [baseDir,] coordinateData )





      </Syntax>
      <Example>

        The code below is an example of a sprite sheet descriptor file named test.lua. It defines a single function named getSpriteSheetData() that returns a Lua table whose elements describe the size, position, and other properties of each frame in the sprite sheet.
        -- test.lua
        module (...)
         
        function getSpriteSheetData()
         
                local sheet =
                {
                        frames =
                        {
                                {
                                textureRect = { x = 2, y = 70, width = 50, height = 50 },
                                spriteTrimmed = true,
                                spriteColorRect = { x = 38, y = 38 },
                                spriteSourceSize = { width = 128, height = 128 }
                                },
         
                                {
                                textureRect = { x = 2, y = 242, width = 50, height = 52 },  
                                spriteTrimmed = true,
                                spriteColorRect = { x = 38, y = 36 },  
                                spriteSourceSize = { width = 128, height = 128 }
                                },
                        }
                }
                return sheet
        end
        textureRect

        Specifies where the frame lies within the sprite sheet image file, in pixels.
        spriteTrimmed

        Set true to indicate that the frame specified by textureRect is a trimmed down version of the original source image. In which case, you must indicate the original size of the frame using spriteSourceSize and where the frame came from in the original source image using spriteColorRect.

        Set false if the frame is not trimmed, in which case the frame takes the size specified by textureRect.
        spriteColorRect

        Only applicable if spriteTrimmed is set true. Provides the x and y coordinates in the original source image (not the sprite sheet image file) that the trimmed frame came from.
        spriteSourceSize

        Only applicable if spriteTrimmed is set true. Indicates the size of the source image (not the sprite sheet image) that the trimmed frame came from. A sprite will display a trimmed frame in proportion to this source size.
        After setting up a Lua table like the above, the following code creates a new sprite sheet object from the source image file ("test.png") and the data file ("test.lua") shown above.
        1
        2
        3
        4
        5
        6
        7
        local sprite = require("sprite")
        -- In this case, test.lua is exported from Zwoptex
        local test = require("test")
        -- Method defined by test.lua that returns table data defining the sprites
        local spriteData = test.getSpriteSheetData()
        -- Load the sprite sheet in test.png using the sprite definitions from spriteData
        local spriteSheet = sprite.newSpriteSheetFromData( "test.png", spriteData )





      </Example>
      <Parameters>

        spriteSheetImageFile

        String: The file name of the sprite sheet image.
        baseDir (optional)

        The base directory of the image file.  If specified, may be system.ResourceDirectory (the default), system.DocumentsDirectory, or system.TemporaryDirectory.
        coordinateData

        Table: Provides coordinates of each frame in the image specified by spriteSheetImageFile. This data is typically exported by a sprite sheet packing utility (such as Zwoptex or TexturePacker) along with the image file.





      </Parameters>
      <Returns>

        A sprite sheet object.





      </Returns>
      <Remarks>





      </Remarks>
    </sprite.newSpriteSheetFromData>
    <spriteInstance.animating>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that returns true if spriteInstance is currently animating, otherwise returns false.


      </Description>
      <Syntax>

        spriteInstance.animating





      </Syntax>
      <Example>

        if spriteInstance.animating then
                -- do something
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        boolean

        Returns true if spriteInstance is currently animating, otherwise returns false.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance.animating>
    <spriteInstance.currentFrame>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets or gets the current frame of the current animation.


      </Description>
      <Syntax>

        value = spriteInstance.currentFrame






      </Syntax>
      <Example>

        local function spriteListener( event )
            print( "Current frame number is " .. event.sprite.currentFrame)
        end
         
        -- Add sprite listener
        instance:addEventListener( "sprite", spriteListener )





      </Example>
      <Parameters>

        number

        The current frame for the current animation.





      </Parameters>
      <Returns>

        number

        The current frame of the current animation.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance.currentFrame>
    <spriteInstance.sequence>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        A read-only property that returns the name of the currently playing sequence.


      </Description>
      <Syntax>

        spriteInstance.sequence





      </Syntax>
      <Example>

        local function spriteListener( event )
            print( "Current sequence is " .. event.sprite.sequence )
        end
         
        -- Add sprite listener
        instance:addEventListener( "sprite", spriteListener )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        string

        The name of the current playing sequence.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance.sequence>
    <spriteInstance.timeScale>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Gets or sets the scale to be applied to the animation time.  This is used to control a sprite's animation speed dynamically.
        For example:

        - A time scale of 1.0 (the default) runs the animation at normal speed.

        - A time scale of 2.0 runs the animation twice as fast.

        - A time scale of 0.5 runs the animation at half speed.
        Constraints:

        - Maximum value allowed is 20.0

        - Minimum value allowed is 0.05.

        - Supports up to 2 decimal places.


      </Description>
      <Syntax>

        spriteInstance.timeScale





      </Syntax>
      <Example>

        -- Set up an animation sequence that plays all of its frames in 1 second.
        local uma = sprite.newSpriteSheetFromData("uma.png", require("uma").getSpriteSheetData())
        local spriteSet = sprite.newSpriteSet(uma, 1, 8)
        sprite.add(spriteSet, "uma", 1, 8, 1000, 0)
         
        -- Create a sprite instance that runs the animation at double speed.
        local spriteInstance = sprite.newSprite(spriteSet)
        spriteInstance.timeScale = 2.0





      </Example>
      <Parameters>

        None





      </Parameters>
      <Returns>

        number

        The current scale applied to the animation time.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance.timeScale>
    <spriteInstance..addEventListener>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Registers a listener function that's notified when the spriteInstance animation has an event. The following events generate a notification and can checked in event.phase:

        "end" - The sprite stops playing
        "loop" - The sprite loops (from last to first, or reverses direction)
        "next" - The sprite's next frame is played



      </Description>
      <Syntax>

        spriteInstance:addEventListener( "sprite", listenerFunction )





      </Syntax>
      <Example>

        local function spriteListener( event )
            print( "Sprite listener" .. event.name, event.sprite, event.phase,
                event.sprite.sequence
        end
         
        -- Add sprite listener
        instance:addEventListener( "sprite", spriteListener )





      </Example>
      <Parameters>

        listenerFunction

        Function: A reference to a function that will be notified when a sprite animation event occurs.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance..addEventListener>
    <spriteInstance..pause>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Pauses the current animation, and frame remains on the last displayed frame. Playback can resume later with spriteInstance:play().


      </Description>
      <Syntax>

        spriteInstance:pause()





      </Syntax>
      <Example>

        local spriteInstance = sprite.newSprite(spriteSet)
        spriteInstance:prepare("running_man")
        spriteInstance:play()
        ...
        -- some time later
        spriteInstance:pause()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance..pause>
    <spriteInstance..play>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Play animation sequence, starting at the current frame. Does not reset looping.
        A call to spriteInstance:prepare() must be called before the sequence can be played. Play can also be called after spriteInstance:pause().


      </Description>
      <Syntax>

        spriteInstance:play()





      </Syntax>
      <Example>

        local instance2 = sprite.newSprite( spriteSet2 )
        instance2.x = display.contentWidth / 2
        instance2:prepare("man")
        instance2:play()  





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance..play>
    <spriteInstance..prepare>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Stops any currently playing animation sequence on the sprite instance spriteInstance, optionally sets the new current sequence, and moves to the first frame of that sequence. This also resets the loop counter, if any. Use spriteInstance.play() to play the sequence.


      </Description>
      <Syntax>

        spriteInstance:prepare( [sequence] )





      </Syntax>
      <Example>

        local spriteSet2 = sprite.newSpriteSet(sheet2, 1, 15)
        sprite.add( spriteSet2, "man", 1, 15, 200, 0 ) -- play 15 frames every 200 ms
         
        local instance2 = sprite.newSprite( spriteSet2 )
        instance2.x = 3 * display.contentWidth / 4 + 30
        instance2.y = baseline - 55
         
        instance2:prepare("man")
        instance2:play()





      </Example>
      <Parameters>

        sequence

        String: (Optional) The name of the sequence to prepare. If not specified, "default" is used as the sprite sequence name.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteInstance..prepare>
    <spriteSheet..dispose>
      <IsFunction>false</IsFunction>
      <IsClassFunction>true</IsClassFunction>
      <Description>
        Disposes of a sprite sheet and releases its texture memory. It also calls removeSelf() on all sprite instances using the sheet, removing them from the stage. All sprites, sequences, and sets that belong to the removed sprite sheet are no longer valid after calling this method, and will be garbage collected when they are no longer referenced by your application's Lua code.


      </Description>
      <Syntax>

        spriteSheet:dispose()





      </Syntax>
      <Example>

        local sprite = require("sprite")
        local spriteSheet = sprite.newSpriteSheet("test.png")
        -- Later dispose of the sprite sheet and all of its associated sprites, sequences and sets.
        spriteSheet:dispose()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </spriteSheet..dispose>
  </Sprite_Sheets_>
  <Storyboard>
    <storyboard.disableAutoPurge>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        NOTE: This requires build 2012.776 or higher.
        By default, storyboard will automatically purge (e.g. remove the scene's display group, while leaving the actual module in memory) the least recently used scene whenever the OS receives a low memory warning.
        If you would like to manage the purging of scenes manually and disable this auto-purging functionality, you can set storyboard.disableAutoPurge to true. The default value is false.


      </Description>
      <Syntax>

        storyboard.disableAutoPurge





      </Syntax>
      <Example>

        -- turn "off" auto-purge on low memory functionality
        storyboard.disableAutoPurge = true





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        Requires build 2012.776 or higher.




      </Remarks>
    </storyboard.disableAutoPurge>
    <storyboard.getPrevious>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the name of the previous scene (as a string).


      </Description>
      <Syntax>

        storyboard.getPrevious()





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- The previous scene was "scene1"
        local lastScene = storyboard.getScene()
         
        print( lastScene ) -- output: scene1





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        String.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.getPrevious>
    <storyboard.getScene>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the specified scene object. If the scene object does not exist, the function will return nil. This is useful for getting a reference to a specific scene object, for example, if you have a function attached to a specific scene that a separate scene needs access to.


      </Description>
      <Syntax>

        storyboard.getScene( sceneName )





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- get a reference to "scene2"
        local scene = storyboard.getScene( "scene2" )
         
        -- the following function is defined in scene2.lua:
        scene.helloWorld()





      </Example>
      <Parameters>

        sceneName

        string (required). This is the name of the scene you want returned.





      </Parameters>
      <Returns>

        Scene object.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.getScene>
    <storyboard.gotoScene>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used to transition to a specific scene (determined by scene's module name). Internally, this will handle all loading/unloading of the scenes. Scenes may also be explicitly unloaded/removed by the user.
        When this function is called, the "exitScene" event will be dispatched for the currently loaded scene (if one exists), followed by the "createScene" event (for the specified sceneâ€”sceneNameâ€”if no "view" property is present), and then the "enterScene" event (also for the specified sceneâ€”sceneName).


      </Description>
      <Syntax>

        storyboard.gotoScene( sceneName [, effect, effectTime] )

      </Syntax>
      <Example>

        Format 1:
        local storyboard = require "storyboard"
         
        storyboard.gotoScene( "scene1", "fade", 500 )
        Format 2: (requires build &gt;= 2012.785)
        local storyboard = require "storyboard"
         
        local options =
        {
            effect = "slideLeft",
            time = 800,
            params = { var1 = "custom", myVar = "another" }
        }
         
        storyboard.gotoScene( "scene1", options )





      </Example>
      <Parameters>

         

        sceneName

        string. Specify the module name of the desired scene to load. The module should return an object created using storyboard.newScene(). This is the only required argument.
        Format 1:
        effect

        string. This optional parameter will determine what effect is used for the scene transition. Here is a listing of all currently available transition effects:

        fade
        zoomOutIn
        zoomOutInFade
        zoomInOut
        zoomInOutFade
        flip
        flipFadeOutIn
        zoomOutInRotate
        zoomOutInFadeRotate
        zoomInOutRotate
        zoomInOutFadeRotate
        fromRight (over original scene)
        fromLeft (over original scene)
        fromTop (over original scene)
        fromBottom (over original scene)
        slideLeft (pushes original scene)
        slideRight (pushes original scene)
        slideDown (pushes original scene)
        slideUp (pushes original scene)
        crossFade

         

        effectTime

        number. This optional parameter will determine how long it will take to perform the transition (in milliseconds). The default value is 500, but will only be considered if the "effect" argument is set.
        Format 2: (requires build &gt;= 2012.785)
        options

        table. This optional table that includes specific keys to be used as options for the scene transition. The following keys are supported:

        effect - string representing effect. All effects listed above are supported.
        time - number representing how long the effect should last. Default is 500.
        params - table that contains any kind of custom data that you want passed to the next scene. This data can be accessed via event.params in the "createScene", "willEnterScene", and "enterScene" events of the next scene. More info on parameter passing here.

        Refer to the 'Format 2' example above for an example of how to use the options table as the second argument of storyboard.gotoScene()





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.gotoScene>
    <storyboard.hideOverlay>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        NOTE: This feature requires build 2012.797 or higher.
        This function will hide/remove the current overlay scene (if one is currently being displayed).
        Overlay (e.g. "pop up") scenes can be shown using storyboard.showOverlay().


      </Description>
      <Syntax>

        storyboard.hideOverlay( [ purgeOnly, effect, effectTime ] )


      </Syntax>
      <Example>

        -- hide the currently shown overlay (if there is one)
        storyboard.hideOverlay( "fade", 800 )
         
        -- or --
         
        -- pureOnly will purge the scene instead of completely remove it
        storyboard.hideOverlay( true, "fade" )





      </Example>
      <Parameters>

         

        purgeOnly

        Boolean (true/false)—optional. If set to true, the scene will only be purged (e.g. the view display group will be removed, but the scene module will remain in memory). Default is false (overlay scene will be completely removed, module and all). Setting this to true is useful if you intend to show the popup again
         

        effect

        String—optional. If you want the overlay to have an effect before being removed, specify a scene effect here. All scene effects from storyboard.gotoScene() are supported.
         

        effectTime

        Number—optional. If an effect is specified, this is the duration of the effect. The default effectTime value is 500.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        This function requires build 2012.797 or higher.




      </Remarks>
    </storyboard.hideOverlay>
    <storyboard.loadScene>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        NOTE: This function requires Corona SDK build 2012.773 or higher. Subscribe now to access daily builds.
        Loads specified scene, without initiating a scene transition. This function is similar to storyboard.gotoScene(), but will not change the currently active scene.
        Optionally, you can set a flag (doNotLoadView) that will load the scene's module only (if you do not want to load the view display group).
        This function is useful for those who want to "preload" a scene, before initiating a transition to it.


      </Description>
      <Syntax>


        storyboard.loadScene( sceneName [, doNotLoadView ] )

      </Syntax>
      <Example>

        Format 1:
            -- load the scene (scene's view will be inserted UNDER current scene)
            local scene2 = storyboard.loadScene( "scene2" )
         
            -- Do something here
         
            -- Later, transition to the scene (no loading necessary)
            storyboard.gotoScene( "scene2", "slideLeft", 800 )
        Format 2: (requires build &gt;= 2012.785)
            -- load the scene (scene's view will be inserted UNDER current scene)
            local customData = { var1 = "hello!", myVar="world" }
            local scene2 = storyboard.loadScene( "scene2", false, customData )
         
            -- Do something here
         
            -- Later, transition to the scene (no loading necessary)
            storyboard.gotoScene( "scene2", "slideLeft", 800 )





      </Example>
      <Parameters>

         

        sceneName

        string. Specify the module name of the desired scene to load. The module should return an object created using storyboard.newScene(). This is the only required argument.
         

        doNotLoadView

        boolean (true/false). This optional parameter that, if set to true, will load the scene's module only and not the scene's view (therefore, no "createScene" event will be dispatched). The default is false (scene's view group will be loaded and a "createScene" event dispatched).
         

        params

        table (requires build &gt;= 2012.785). This is an optional table with custom data that you can pass to the next scene. This table will be accessible via event.params in the scene's "createScene" event.





      </Parameters>
      <Returns>

        storyboard scene object





      </Returns>
      <Remarks>

        This function requires Corona SDK build 2012.773 or higher.




      </Remarks>
    </storyboard.loadScene>
    <storyboard.newScene>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used to create new scene objects to be returned and used with the Storyboard API.
        See the storyboard Scene Template for a better example of usage.


      </Description>
      <Syntax>

            storyboard.newScene( [sceneName] )





      </Syntax>
      <Example>

        -------------------------
        -- scene.lua
        -------------------------
         
        local storyboard = require "storyboard"
        local scene = storyboard.newScene()
         
        --
        -- scene event listeners here
        --
         
        return scene





      </Example>
      <Parameters>

        sceneName

        string. This is an optional parameter that should only be used if you want to create a custom scene, that is not being used as an external module. If creating the scene with an external module (e.g. the same manner as the scene template), then you do not need to set this parameter.





      </Parameters>
      <Returns>

        Scene object.





      </Returns>
      <Remarks>

        The 'sceneName' parameter was added in Corona build 2011.688.




      </Remarks>
    </storyboard.newScene>
    <storyboard.purgeAll>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Will purge all scenes (except for the one that is currently showing). A "destroyScene" event will be dispatched to all scenes before they are purged.


      </Description>
      <Syntax>

        storyboard.purgeAll()





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- Purge all scenes (except for the one currently showing)
        storyboard.purgeAll()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.purgeAll>
    <storyboard.purgeScene>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Unloads the specified scene's "view" property, which is a group that contains all of the scene's objects. It takes one (required) argument, sceneName, which is the module name of the scene you are attempting to unload. This function preserves the scene's module in the global package.loaded table.
        When storyboard.gotoScene() is later called on the scene specified in this function, the module will already be loaded, but the "createScene" event will be dispatched to re-create the view. This function may be automatically called on the LRU (least recently used) scene if a low memory warning is received, or it may be triggered explicitly by the user for memory/performance considerations, in cases where the user plans on loading the scene again at some point in the near future.
        NOTE: Before the "view" is removed, a "destroyScene" event is dispatched to the specified scene (with the module name sceneName).


      </Description>
      <Syntax>

        storyboard.purgeScene( sceneName )





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- unload scene1's "view" group:
        storyboard.purgeScene( "scene1" )





      </Example>
      <Parameters>

         

        sceneName

        string (required). This is a string that represents the module name of the scene you want to purge. For instance, if you want to purge scene1.lua, you would pass "scene1" as the sceneName.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.purgeScene>
    <storyboard.removeAll>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Will purge/remove all scenes (except for the one that is currently showing). A "destroyScene" event will be dispatched to all scenes before they are purged.


      </Description>
      <Syntax>

        storyboard.removeAll()





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- remove all scenes (except for the one currently showing)
        storyboard.removeAll()





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.removeAll>
    <storyboard.removeScene>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Purges the specified scene, and then releases all global references to module from package.loaded table, thus completely releasing the scene from memory.
        When purging occurs, a "destroyScene" event will be dispatched on the specified scene before it is removed.


      </Description>
      <Syntax>

        storyboard.removeScene( sceneName )





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- completely remove scene1
        storyboard.removeScene( "scene1" )





      </Example>
      <Parameters>

         

        sceneName

        string (required). This is a string that represents the module name of the scene you want to purge. For instance, if you want to purge scene1.lua, you would pass "scene1" as the sceneName.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </storyboard.removeScene>
    <storyboard.showOverlay>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        NOTE: This feature requires build 2012.797 or higher.
        This function will load a scene above the currently active scene, leaving the currently active scene in-tact. This is also known as a "pop up" scene. This function supports all scene transition effects that are used with storyboard.gotoScene().
        When an overlay scene is shown (and the transition effect is complete, if an effect is specified), the currently active (non-overlay) storyboard scene will receive an "overlayBegan" event.
        When an overlay scene is closed (via storyboard.hideOverlay()), the currently active (non-overlay) storyboard scene will receive an "overlayEnded" event.
        NOTE: If you want to prevent touches from "going through" the overlay scene to the underlying, currently active scene, as of build 2012.816 you can use the 'isModal' option when calling storyboard.showOverlay().


      </Description>
      <Syntax>

        storyboard.showOverlay( sceneName [, options ] )





      </Syntax>
      <Example>

        -- sample scene
        local storyboard = require "storyboard"
        local scene = storyboard.newScene()
         
        function scene:createScene( event )
            -- scene creation code goes here
        end
        scene:addEventListener( "createScene" )
         
        function scene:enterScene( event )
            -- display scene overlay
            local options =
            {
                effect = "fade",
                time = 400
            }
         
            storyboard.showOverlay( "overlay_scene", options )
        end
        scene:addEventListener( "enterScene" )
         
        -- the following event is dispatched once the overlay is in place
        function scene:overlayBegan( event )
            print( "Showing overlay: " .. event.sceneName )
        end
        scene:addEventListener( "overlayBegan" )
         
        -- the following event is dispatched once overlay is removed
        function scene:overlayEnded( event )
            print( "Overlay removed: " .. event.sceneName )
        end
        scene:addEventListener( "overlayEnded" )
         
        return scene





      </Example>
      <Parameters>

         

        sceneName

        string. Specify the module name of the desired scene to load as an overlay. The module should return an object created using storyboard.newScene(). This is the only required argument for storyboard.showOverlay().
         

        options

        table. This optional table that includes specific keys to be used as options for the overlay transition. The following keys are supported:

        effect - string representing effect. All effects that can be used with storyboard.gotoScene() are valid.
        time - number representing how long the effect should last. Default is 500.
        params - table that contains any kind of custom data that you want passed to the overlay scene. This data can be accessed via event.params in the "createScene", "willEnterScene", and "enterScene" events of the overlay scene.
        isModal - (requires build 2012.816 or higher) When set to true, this prevents touches from "going through" the overlay scene to the underlying "active" scene. Default is false.


        Refer to the 'Format 2' example above for an example of how to use the options table as the second argument of storyboard.gotoScene()





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        This function requires build 2012.797 or higher. The 'isModal' option requires build 2012.816 or higher.




      </Remarks>
    </storyboard.showOverlay>
    <storyboard.stage>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        NOTE: Access to this property requires build 2012.776 or higher.
        This is a reference to the top-level storyboard group, which all scene views are inserted to. It can be thought of as the storyboard "scene layer". This is useful to have, for instance, if you need objects to be placed above or below ALL storyboard scenes (even during transition effects).
        Here are a few examples:

        A persistent background image that you want displayed behind all storyboard scenes, and to stay static even during scene transitions.
        Tab bars often appear above all scenes, even during transitions.
        Heads up displays (such as health/score info, etc.) are things that are often placed above all scenes, and persist during scene transitions.



      </Description>
      <Syntax>

        storyboard.stage





      </Syntax>
      <Example>

        local storyboard = require "storyboard"
         
        -- background should appear behind all scenes
        local background = display.newImage( "bg.png" )
         
        -- tab bar image should appear above all scenes
        local tabBar = display.newImage( "tabbar.png" )
        tabBar:setReferencePoint( display.BottomLeftReferencePoint )
        tabBar.x, tabBar.y = 0, display.contentHeight
         
        -- put everything in the right order
        local display_stage = display.getCurrentStage()
        display_stage:insert( background )
        display_stage:insert( storyboard.stage )
        display_stage:insert( tabBar )
         
        -- go to the first scene
        storyboard.gotoScene( "scene1", "fade", 300 )





      </Example>
      <Parameters>

         





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>

        This requires build 2012.776 or higher.




      </Remarks>
    </storyboard.stage>
  </Storyboard>
  <Strings>
    <string.byte>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the internal numerical codes of the characters in a string.


      </Description>
      <Syntax>

        string.byte( s [, i [, j]] )

      </Syntax>
      <Example>

        print (string.byte("ABCDE"))          ---&gt; 65
        print (string.byte("ABCDE", 1))       ---&gt; 65
        print (string.byte("ABCDE", 3, 5))    ---&gt; 67   68       69
        print (string.byte("ABCDE", 0))       ---&gt; nil
        print (string.byte("ABCDE", -1))      ---&gt; 69
         
        local s = "ABCDE"
        print (s:byte(3, 4))                  ---&gt; 67     68





      </Example>
      <Parameters>

        s

        The string.
        i [, j]

        (Optional)  Specify the characters of the string s[i], s[i+1], ..., s[j] for which to get the codes. The default value for i is 1; the default value for j is i.





      </Parameters>
      <Returns>

        The internal numerical codes of the characters.  Note that numerical codes are not necessarily portable across platforms.





      </Returns>
      <Remarks>





      </Remarks>
    </string.byte>
    <string.char>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a string in which each character has the internal numerical code equal to its corresponding argument.
        Note that numerical codes are not necessarily portable across platforms.


      </Description>
      <Syntax>

        string.char ([arg1 [, ...])





      </Syntax>
      <Example>

        print (string.char(65,66,67)) --&gt; ABC
        print (string.char())         --&gt; empty string





      </Example>
      <Parameters>

        Zero or more integers.





      </Parameters>
      <Returns>

        A string with length equal to the number of arguments.





      </Returns>
      <Remarks>





      </Remarks>
    </string.char>
    <string.find>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Looks for the first match of a pattern in a string. If found, returns the indices where the occurrence starts and ends; otherwise, returns nil.


      </Description>
      <Syntax>

        string.find (s, pattern [, init [, plain]])

      </Syntax>
      <Example>

        print (string.find("Hello Corona user", "Corona"))     --&gt;  7       12
        print (string.find("Hello Corona user", "Bud"))        --&gt;  nil
         
        print (string.find("Hello Corona user", "Corona", 1))    --&gt; start at first character:   7       12
        print (string.find("Hello Corona user", "Corona", 8))    --&gt; start at character 8:   nil
        print (string.find("Hello Corona user", "e", -5))        --&gt; first "e" 5 characters from end:  16      16
        print (string.find("Hello Corona user", "%su", 1, true)) --&gt; nil





      </Example>
      <Parameters>

        s

        A string.
        pattern

        A string specifying the pattern to match.  See Strings:  Patterns.
        init

        (Optional)  Specifies where to start the search.  Default value is 1 and can be negative.
        plain

        (Optional) A value of true turns off the pattern matching facilities, so the function does a plain "find substring" operation with no characters in pattern being considered "magic".

        Note that if plain is given, then init must be given as well.





      </Parameters>
      <Returns>

        Two numbers, or nil.





      </Returns>
      <Remarks>





      </Remarks>
    </string.find>
    <string.format>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a formatted string following the description given in its arguments.


      </Description>
      <Syntax>

        string.format (formatstring [, ...])

      </Syntax>
      <Example>

        print (string.format('%q', 'a string with "quotes" and a\n new line'))  
               ---&gt;      "a string with \"quotes\" and a\      new line"
        print (string.format("%s %q", "Hello", "Corona user!"))  
               --&gt; string and quoted string
        print (string.format("%c%c%c", 76,117,97))            
               --&gt; char: Lua
        print (string.format("%e, %E", math.pi,math.pi))
               --&gt; exponent: 3.141593e+00, 3.141593E+00
        print (string.format("%f, %g", math.pi,math.pi))
               --&gt; float and compact float: 3.141593, 3.14159
        print (string.format("%d, %i, %u", -100,-10.1,-100))
               --&gt; signed, signed, unsigned integer:  -100, -10, 0
        print (string.format("%o, %x, %X", 10, 10, 10))
               --&gt; octal, hex, hex:           12, a, A





      </Example>
      <Parameters>

        formatstring[ , ...]

        A string, and optional additional string parameters.

        These follow the same rules as the printf family of standard C functions. The only differences are that the options/modifiers *, l, L, n, p, and h are not supported and that there is an extra option, q.

        The q option formats a string in a form suitable to be safely read back by the Lua interpreter: the string is written between double quotes, and all double quotes, newlines, embedded zeros, and backslashes in the string are correctly escaped when written.

        The options c, d, E, e, f, g, G, i, o, u, X, and x all expect a number as argument, whereas q and s expect a string.

        string.format() does not accept string values containing embedded zeros, except as arguments to the q option.





      </Parameters>
      <Returns>

        The formatted string.





      </Returns>
      <Remarks>





      </Remarks>
    </string.format>
    <string.gmatch>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a pattern finding iterator.


      </Description>
      <Syntax>

        string.gmatch( s, pattern )

      </Syntax>
      <Example>

        -- Collect all pairs key=value from the given string into a table
        t = {}
        s = "from=world, to=Lua"
        for k, v in string.gmatch(s, "(%w+)=(%w+)") do
            t[k] = v
        end





      </Example>
      <Parameters>

        s

        The string to be searched.
        pattern

        A string specifying the pattern to match.  See Strings:  Patterns.





      </Parameters>
      <Returns>

        An iterator for use in a Lua loop.





      </Returns>
      <Remarks>





      </Remarks>
    </string.gmatch>
    <string.gsub>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Replace all instances of a pattern in a string.


      </Description>
      <Syntax>

        string.gsub( s, pattern, repl [, n] )

      </Syntax>
      <Example>

        print (string.gsub("Hello banana", "banana", "Corona user"))
        print (string.gsub("banana", "a", "A", 2)  -- limit substitutions made to 2
        print (string.gsub("banana", "(an)", "%1-")    -- capture any occurances of "an" and replace
        print (string.gsub("banana", "a(n)", "a(%1)")  -- brackets around n's which follow a's
        print (string.gsub("banana", "(a)(n)", "%2%1") -- reverse any "an"s
        print (string.gsub("Hello Lua user", "(%w+)", print)  -- print any words found
        print (string.gsub("Hello Lua user", "(%w+)", function(w) return string.len(w) end) -- replace with lengths
        print (string.gsub("banana", "(a)", string.upper)     -- make all "a"s found uppercase
        print (string.gsub("banana", "(a)(n)", function(a,b) return b..a end) -- reverse any "an"s
        print (string.gsub("The big {brown} fox jumped {over} the lazy {dog}.","{(.-)}", function(a)  print(a) end )
        print (string.gsub("The big {brown} fox jumped {over} the lazy {dog}.","{(.*)}", function(a)  print(a) end )





      </Example>
      <Parameters>

        s

        The string to search.
        pattern

        A string specifying the pattern to match.  See Strings:  Patterns.
        repl

        If repl is a string, then its value is used for the replacement. The character % works as an escape character: any sequence in repl of the form %n, with n between 1 and 9, stands for the value of the n-th captured substring. The sequence %0 stands for the whole match. The sequence %% stands for a single %.
        If repl is a table, then the table is queried for every match, using the first capture as the key; if the pattern specifies no captures, then the whole match is used as the key.
        If repl is a function, then this function is called every time a match occurs, with all captured substrings passed as arguments, in order; if the pattern specifies no captures, then the whole match is passed as a sole argument.
        If the value returned by the table query or by the function call is a string or a number, then it is used as the replacement string; otherwise, if it is false or nil, then there is no replacement (that is, the original match is kept in the string).

        n

        (Optional) Number of occurrences of pattern to replace.





      </Parameters>
      <Returns>

        A string.





      </Returns>
      <Remarks>





      </Remarks>
    </string.gsub>
    <string.len>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the length of a string.


      </Description>
      <Syntax>

        string.len( s )

      </Syntax>
      <Example>

        print (string.len("Lua"))          --&gt; 3
        print (string.len(""))             --&gt; 0
        print (string.len("Lua\000user"))  --&gt; 8





      </Example>
      <Parameters>

        s

        A string.





      </Parameters>
      <Returns>

        A number.





      </Returns>
      <Remarks>





      </Remarks>
    </string.len>
    <string.lower>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Change uppercase characters in a string to lowercase.


      </Description>
      <Syntax>

        string.lower( s )

      </Syntax>
      <Example>

        print (string.lower("Hello, Corona user!"))
             --&gt; hello, corona user!





      </Example>
      <Parameters>

        s

        A string.





      </Parameters>
      <Returns>

        A copy of s with all uppercase letters changed to lowercase. All other characters are left unchanged.
        The definition of uppercase depends on the current locale.





      </Returns>
      <Remarks>





      </Remarks>
    </string.lower>
    <string.match>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Extract substrings by matching a pattern in a string.


      </Description>
      <Syntax>

        string.match( s, pattern [, init] )

      </Syntax>
      <Example>

        print (string.match("I have 2 questions for you.", "%d+ %a+"))
             --&gt; 2 questions
         
        print (string.format("%d, %q", string.match("I have 2 questions for you.", "(%d+) (%a+)")))
             --&gt; 2, "questions"





      </Example>
      <Parameters>

        s

        A string.
        pattern

        A string specifying the pattern to match.  See Strings:  Patterns.
        init

        (Optional) Number specifying where in s to start the search.  The default is 1; can be negative.





      </Parameters>
      <Returns>

        If a match is found, the captures from the pattern; otherwise nil.  If pattern specifies no captures, then the whole match is returned.





      </Returns>
      <Remarks>





      </Remarks>
    </string.match>
    <string.rep>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Replicate a string.


      </Description>
      <Syntax>

        string.rep( s, n )

      </Syntax>
      <Example>

        print (string.rep ("Lua ", 5))   --&gt; Lua Lua Lua Lua Lua





      </Example>
      <Parameters>

        s

        The string to replicate.





      </Parameters>
      <Returns>

        A string that is the concatenation of n copies of the string s.





      </Returns>
      <Remarks>





      </Remarks>
    </string.rep>
    <string.reverse>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Reverses a string.


      </Description>
      <Syntax>

        string.reverse( s )

      </Syntax>
      <Example>

        print( string.reverse ("Corona") )   --&gt; anoroC





      </Example>
      <Parameters>

        s

        The string to reverse.





      </Parameters>
      <Returns>

        The reversed string.





      </Returns>
      <Remarks>





      </Remarks>
    </string.reverse>
    <string.sub>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a substring.


      </Description>
      <Syntax>

        string.sub( s, i [, j] )

      </Syntax>
      <Example>

        local s = "Hello Corona user"
        print( s:sub(7) )      --&gt; Corona user
        print( s:sub(7, 9) )   --&gt; Cor
        print( s:sub(-11) )     --&gt; Corona user
        print( s:sub(-11, 12) )  --&gt; Corona
        print( string.sub("Hello Corona user",
               -11, -6) ) --&gt; Corona





      </Example>
      <Parameters>

        i

        Index of the start of the substring.
        j

        (Optional) Index of the end of the substring (inclusive).  If not specified, the substring ends at the end of the string.





      </Parameters>
      <Returns>

        A string.





      </Returns>
      <Remarks>





      </Remarks>
    </string.sub>
    <string.upper>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Change lowercase characters in a string to uppercase.


      </Description>
      <Syntax>

        string.upper( s )

      </Syntax>
      <Example>

        print ( string.upper ("Hello, Corona user!") )
               --&gt; HELLO, CORONA USER!





      </Example>
      <Parameters>

        s

        A string.





      </Parameters>
      <Returns>

        A copy of s with all lowercase letters changed to uppercase. All other characters are left unchanged.





      </Returns>
      <Remarks>





      </Remarks>
    </string.upper>
  </Strings>
  <System>
    <system.DocumentsDirectory>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used with system.pathForFile to create a path for storing and retrieving files that need to persist between application sessions. The path is "/Documents".
        This property can also be used with other APIs requesting a "baseDirectory" as a parameter (e.g., display.newImage, display.save, media.playSound, etc.).
        On the Corona Simulator this will be in a sandboxed folder on a per-application basis. You can view the directories and the files by clicking on "Show Project Sandbox" in the Simulator.


      </Description>
      <Syntax>

        path = system.pathForFile( filename, system.DocumentsDirectory )





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.DocumentsDirectory )
         
        -- io.open opens a file at path. returns nil if no file found
        local fh, reason = io.open( path, "r" )
         
        if fh then
           -- read all contents of file into a string
           local contents = fh:read( "*a" )
           print( "Contents of " .. path .. "\n" .. contents )
        else
           print( "Reason open failed: " .. reason )  -- display failure message in terminal
         
           -- create file because it doesn't exist yet
           fh = io.open( path, "w" )
           
           if fh then
                print( "Created file" )
           else
                print( "Create file failed!" )
           end
           
           local numbers = {1,2,3,4,5,6,7,8,9}
           fh:write( "Feed me data!\n", numbers[1], numbers[2], "\n" )
           
           for _,v in ipairs( numbers ) do
               fh:write( v, " " )
           end
           
           fh:write( "\nNo more data\n" )
        end
         
        io.close( fh )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        userdata

        Returns a special userdata constant pointing to the "/Documents" directory. (This is not a string.)





      </Returns>
      <Remarks>

        Use the Documents directory for storing files that need to persist after the application exits. Use the Temporary directory for files only needed while the application is running. Files cannot be written to the Resource directory  -- it's read-only and contains the files bundled in your application's project folder.
        Files in the Documents directory are NOT removed when the app is updated to a new version.




      </Remarks>
    </system.DocumentsDirectory>
    <system.ResourceDirectory>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used with system.pathForFile to create a path for retrieving files where all the application assets exist (e.g., image and sound files). This often called the "app bundle."
        Note: You should never create, modify, or add files to this directory. Doing so will prevent the device from verifying the integrity of your application; in some cases the device will treat your application as malware and refuse to launch your application.
        This property can also be used with other APIs requesting a "baseDirectory" as a parameter (e.g., display.newImage, display.save, media.playSound). The Resource directory is generally the default directory if no directory is specified.
        In the Corona Simulator this will be in a sandboxed folder on a per-application basis.
        Note: Unlike the /Documents and /tmp directories, the Resource directory is not viewable using "Show Project Sandbox" in the simulator.


      </Description>
      <Syntax>

        path = system.pathForFile( filename, system.ResourceDirectory )





      </Syntax>
      <Example>

        This example will read a "data.txt" file located in the assets directory (the same directory that has "main.lua").
        local path = system.pathForFile( "data.txt", system.ResourceDirectory )
         
        local file = io.open( path, "r" )
         
        if file then -- nil if no file found
                local contents = file:read( "*a" )
                print( "Contents of " .. path .. "\n" .. contents )
                io.close( file )
        end





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        userdata

        Returns a special userdata constant pointing to the App Bundle (assets) directory. (This is not a string.)





      </Returns>
      <Remarks>

        To restate what was mentioned above: The system.ResourceDirectory is where your main.lua file and generally all your asset (resource) files are stored. For security reasons, this directory is made read-only and enforced by the operating system and not Corona. If you need to update something in the resource directory, you need to move it to the Documents or Temporary directories first.




      </Remarks>
    </system.ResourceDirectory>
    <system.TemporaryDirectory>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Used with system.pathForFile to create a path for storing and retrieving files that only need to persist while the application is running. The path is "/tmp".
        This property can also be used with other APIs requesting a "baseDirectory" as a parameter (e.g., display.newImage, display.save, media.playSound.
        On the Corona Simulator this will be in a sandboxed folder on a per-application basis. You can view the directories and the files by clicking on "Show Project Sandbox" in the Simulator.
        Note: This directory may not exist after the application exits.


      </Description>
      <Syntax>

        path = system.pathForFile( filename, system.TemporaryDirectory )





      </Syntax>
      <Example>

        local path = system.pathForFile( "data.txt", system.TemporaryDirectory )
         
        -- io.open opens a file at path. returns nil if no file found
        local fh, reason = io.open( path, "r" )
         
        if fh then
           -- read all contents of file into a string
           local contents = fh:read( "*a" )
           print( "Contents of " .. path .. "\n" .. contents )
        else
           print( "Reason open failed: " .. reason )  -- display failure message in terminal
         
           -- create file because it doesn't exist yet
           fh = io.open( path, "w" )
           
           if fh then
                print( "Created file" )
           else
                print( "Create file failed!" )
           end
           
           local numbers = {1,2,3,4,5,6,7,8,9}
           fh:write( "Feed me data!\n", numbers[1], numbers[2], "\n" )
           
           for _,v in ipairs( numbers ) do
               fh:write( v, " " )
           end
           
           fh:write( "\nNo more data\n" )
        end
         
        io.close( fh )





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        userdata

        Returns a special userdata constant pointing to the "/tmp" directory. (This is not a string.)





      </Returns>
      <Remarks>





      </Remarks>
    </system.TemporaryDirectory>
    <system.activate>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Activates a system level feature, such as multitouch. Use system.deactivate to disable a feature.


      </Description>
      <Syntax>

        system.activate( feature )





      </Syntax>
      <Example>

        The following sample activates multitouch and creates a touch listener for a background graphic that displays the location, phase,  and ID of each touch event.
        system.activate("multitouch")
         
        local bg = display.newRect( 0, 0, 320, 480 )
        local output = native.newTextBox( 0, 20, 320, 240 )
        output.size = 12
         
        function showTouch(event)
            -- Display the Event info on the screen
            output.text = output.text .. "\nPhase: " .. event.phase
            output.text = output.text .. "\n(" .. event.x .. "," .. event.y .. ")"
            output.text = output.text .. "\nId: " .. tostring( event.id )
        end
         
        bg:addEventListener("touch", showTouch)





      </Example>
      <Parameters>

        feature

        String: Specifies the system feature to be activated. Currently, the only supported value is "multitouch".





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: Multitouch does not work correctly on some Android devices (e.g., NexusOne, HTC Incredible, etc.). This can be demonstrated in Drag Me Multitouch sample app. This is a limitation of the current Android platforms and not Corona.




      </Remarks>
    </system.activate>
    <system.cancelNotification>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Cancels a notification.


      </Description>
      <Syntax>

        system.cancelNotification( notificationId )





      </Syntax>
      <Example>






      </Example>
      <Parameters>

        notificationId Optional id returned by system.scheduleNotification(). If no id is passed, then all notifications are cancelled.





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </system.cancelNotification>
    <system.deactivate>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Deactivates a system level feature, such as multitouch.


      </Description>
      <Syntax>

        system.deactivate()





      </Syntax>
      <Example>

        The following sample activates multitouch and creates a touch listener for a background graphic that displays the location, phase, and ID of each touch event. Multitouch is deactivated after 8 seconds

        system.activate("multitouch")
         
        local bg = display.newRect( 0, 0, 320, 480 )
        local output = native.newTextBox( 0, 20, 320, 240 )
        output.size = 12
         
        function showTouch(event)
            -- Display the Event info on the screen
            output.text = output.text .. "\nPhase: " .. event.phase
            output.text = output.text .. "\n(" .. event.x .. "," .. event.y .. ")"
            output.text = output.text .. "\nId: " .. tostring( event.id )
        end
         
        bg:addEventListener("touch", showTouch)
         
        -- Deactivate multitouch after 5 seconds
        timer.performWithDelay( 8000, function() system.deactivate("multitouch") end )





      </Example>
      <Parameters>

        feature

        String: Specifies the system feature to be deactivated. Currently, the only supported value is "multitouch".





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>

        Multitouch is disable by default. This API can be called after system.activate was called to disable multitouch.




      </Remarks>
    </system.deactivate>
    <system.getInfo>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns information about the system on which the application is running.


      </Description>
      <Syntax>

        system.getInfo( parm )





      </Syntax>
      <Example>

        print( system.getInfo( "deviceID" ) )  -- display the deviceID





      </Example>
      <Parameters>

        parm
        The first argument param is a string that determines what is returned.
        Valid values for param:
        "name" returns the human readable model name. On iPhone, this would be the name of the phone as it appears in iTunes, e.g. "Steve's iPhone".
        "model" returns the device model (as specified by the manufacturer). These include:

        "iPhone"
        "iPad"
        "iPhone Simulator"
        "iPad Simulator"
        "Nexus One"
        "Droid"
        "Galaxy Tab"

        Note: The above is a list of all the iOS models and the Android devices used in the Corona Simulator. Most Android devices return a model number instead of a model name.
        "deviceID" returns the unique id of the device, e.g. IMEI or similar number.
        "environment" returns the environment that the app is running in. These include:

        "simulator" the Corona Simulator
        "device" iOS, Android device and Xcode Simulator

        "platformName" returns the platform name (the OS name), i.e. one of the following:

        "Mac OS X"  (Corona Simulator on Mac)
        "Win"  (Corona Simulator on Windows)
        "iPhone OS" (all iOS devices and Xcode Simulator)
        "Android"  (all Android devices)

        "platformVersion" returns a string representation of the platform version. This is sometimes, but not always, a number -- for example a Droid X is currently returning "2.1-update1".
        "version" This is deprecated. Use "build" instead to distinguish between different Corona build versions.
        "build" returns the Corona build string as it appears in the About box of the Corona Simulator.
        "textureMemoryUsed" returns the texture memory usage (in bytes). Texture memory (for graphics/images) tends to be the most sharply limited resource in mobile development, since it runs out before normal memory.
        "maxTextureSize" returns the maximum texture width or height supported by the device. (Available starting from Build 2011.310)
        "architectureInfo" returns a string describing the underlying CPU architecture of the device you are running on. This API is mostly for internal debugging but may have uses. Strings may be subject to changes in the future depending on the changing landscape of devices and CPUs. (Available starting from Build 2011.326).
        Android on ARM devices will return "ARM" (typically for ARMv6) or "ARM Neon" (ARMv7). iOS will return values such as: "iPhone1,1", "iPhone1,2", where mappings are:

        "iPhone1,1" = iPhone 1G
        "iPhone1,2" = iPhone 3G
        "iPhone2,1" = iPhone 3GS
        "iPod1,1"   = iPod touch 1G
        "iPod2,1"   = iPod touch 2G

        Mac may return i386, x86_64, ppc, or ppc64. (Currently only i386 is available.)

        Windows is currently unsupported.





      </Parameters>
      <Returns>

        String of parameter requested.





      </Returns>
      <Remarks>

        "maxTextureSize" available in Build 2011.310

        "architectureInfo" available in Build 2011.326




      </Remarks>
    </system.getInfo>
    <system.getPreference>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns a preference value as a string.


      </Description>
      <Syntax>

        system.getPreference( category, name )





      </Syntax>
      <Example>

        print( system.getPreference( "locale", "country" ) )  -- print the country





      </Example>
      <Parameters>

        category
        Valid values of category are: "ui" and "locale"
        name
        Valid values of name for "ui" category is: "language"
        Valid values of name for "locale" category is: "country", "identifier", and "language".





      </Parameters>
      <Returns>

        String of parameter requested.





      </Returns>
      <Remarks>





      </Remarks>
    </system.getPreference>
    <system.getTimer>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns time in milliseconds since application launch.


      </Description>
      <Syntax>

        system.getTimer()





      </Syntax>
      <Example>

        print( system.getTimer() ) -- displays the time running (in milliseconds)





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Number -- time in milliseconds.





      </Returns>
      <Remarks>





      </Remarks>
    </system.getTimer>
    <system.openURL>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Open a web page in the browser; create an email; or call a phone number.
        Note: Executing this function will close the app and switch to the built-in browser, email or phone app.


      </Description>
      <Syntax>


        system.openURL( url )





      </Syntax>
      <Example>

        system.openURL( "http://www.anscamobile.com" ) -- open URL in browser





      </Example>
      <Parameters>

        url
        url can be one of the following:

        Email address:  "mailto:nobody@mycompany.com"

        The email address url can also contain subject and body parameters, both of which must be url encoded. Example: "mailto:nobody@mycompany.com?subject=Hi%20there&amp;body=I%20just%20wanted%20to%20say%2C%20Hi!"  Try this URL encoder to encode your text.


        Phone number: "tel:415-867-5309"
        Web link: "http://www.anscamobile.com"






      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </system.openURL>
    <system.orientation>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Returns the current device orientation. This property will return one of six possible string values, from a set consisting of four orientations plus faceUp and faceDown.
        Note: On Android, the orientation values are limited to portrait and landscapeRight.
        Related Items:
        Orientation Event


      </Description>
      <Syntax>


        system.orientation





      </Syntax>
      <Example>

        print( system.orientation ) -- print the system orientation





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        String -- current orientation.
        The six possible returned values are:

        "portrait"

        "portraitUpsideDown"

        "landscapeRight"

        "landscapeLeft"

        "faceUp"

        "faceDown"





      </Returns>
      <Remarks>





      </Remarks>
    </system.orientation>
    <system.pathForFile>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Generates an absolute path using system-defined directories as the base (see System-defined directories  below). A second, optional parameter baseDirectory specifies which base directory is used to construct the full path; its default value is system.ResourceDirectory.
        If the base directory is system.ResourceDirectory and the generated path points to a non-existent file, "nil" is returned and a warning message is displayed in the Corona terminal.
        Related Items:
        system.ResourceDirectory  -- returns constant to the App Bundle folder

        system.DocumentsDirectory -- returns constant to /Documents folder

        system.TemporaryDirectory -- returns constant to /tmp folder


      </Description>
      <Syntax>


        system.pathForFile( filename [, baseDirectory] )





      </Syntax>
      <Example>

        local path = system.pathForFile(  "data.txt", system.DocumentsDirectory )
        local fhd = io.open( path )
         
        -- Determine if file exists
        if fhd then
           print( "File exists" )
           fhd.close()
        else
            print( "File does not exist!" )
        end





      </Example>
      <Parameters>

        filename
        File name string.
        baseDirectory
        Directory where the file is located. Assumes ResourceDirectory if this parameter is missing.





      </Parameters>
      <Returns>

        String -- absolute path to file.





      </Returns>
      <Remarks>

        Note: On Android devices this API doesn't currently work on system.ResourceDirectory because there is no Resource folder. It's basically a zip file holding the resource files.




      </Remarks>
    </system.pathForFile>
    <system.scheduleNotification>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Schedule a local notification event to be delivered in the future.
        Please see the Local Notifications Guide for a walk-through of this feature.


      </Description>
      <Syntax>

        system.scheduleNotification( secondsFromNow [, options] )






      </Syntax>
      <Example>

        -- Options for iOS
        local options = {
           alert = "Wake up!",
           badge = 2,
           sound = "alarm.caf",
           custom = { foo = "bar" }
        }
         
        -- schedule using seconds from now
        local notification = system.scheduleNotification( 60, options )
         
        -- schedule using UTC (Coordinated Universal Time)
        local utcTime = os.date( "!*t", os.time() + 60 )
        local notification = system.scheduleNotification( utcTime, options )
         
        local listener = function( event )
           print( event.name ) -- ==&gt; "notification"
           print( event.custom.foo ) -- ==&gt; "bar"
        end
         
        Runtime:addEventListener( "notification", listener )





      </Example>
      <Parameters>

        secondsFromNow

        Number of seconds from now when the notification should be delivered.
        coordinatedUniversalTime

        Table containing same properties as returned by os.date( "!*t" ). A common error is to pass "*t" instead of "!*t" which incorrectly gives you the time in your current time zone.
        options

        Table specifying details about the notification to be delivered. The following keys can be specified:

        custom Table that will be delivered in the notification.

        In addition, the following iOS-specific options can be provided and (if specified) will be properties in the notification event that is to be delivered:

        alert String of the message of the notification. If the application is not currently running, a system alert will display this message.
        badge Number to set the badge count. 0 means no change.
        sound String of the sound file to be played. This sound is only played if the app is not currently in the foreground. There are limitations on the kinds of sound that can be played. Consult Apple's documentation..






      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </system.scheduleNotification>
    <system.setAccelerometerInterval>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the frequency of accelerometer events. The min frequency is 10 Hz and the max is 100 Hz on the iPhone. Accelerometer events are a significant drain on battery, so only increase the frequency when you need faster responses as in games. Always try to lower the frequency whenever possible to conserve battery life.
        Related Items:
        Accelerometer Events


      </Description>
      <Syntax>

        system.setAccelerometerInterval( frequency )





      </Syntax>
      <Example>

        -- Set the measurement interval to 50 Hz.
        -- This makes the system take 50 measurements per second.
        system.setAccelerometerInterval( 50 )





      </Example>
      <Parameters>

        frequency
        Sets the sample interval in Hertz.
        Hertz is cycles per second, or in this case, the number of measurements to take per second.  So, if you set the frequency to 10, then the system will take 10 measurements per second.
        Maximum value allowed: 100 Hz

        Minimum value allowed: 10 Hz





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </system.setAccelerometerInterval>
    <system.setGyroscopeInterval>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the frequency of gyroscope events in Hertz. Gyroscope events are a significant drain on battery, so only increase the frequency when you need faster responses as in games. Always try to lower the frequency whenever possible to conserve battery life.


      </Description>
      <Syntax>

        system.setGyroscopeInterval( frequency )





      </Syntax>
      <Example>

        -- Set the measurement interval to 50 Hz.
        -- This makes the system take 50 measurements per second.
        system.setGyroscopeInterval( 50 )





      </Example>
      <Parameters>

        frequency
        Sets the sample interval in Hertz.
        Hertz is cycles per second, or in this case, the number of measurements to take per second.  So, if you set the frequency to 10, then the system will take 10 measurements per second.
        Maximum value allowed: 100 Hz

        Minimum value allowed: 10 Hz





      </Parameters>
      <Returns>

        Nothing





      </Returns>
      <Remarks>





      </Remarks>
    </system.setGyroscopeInterval>
    <system.setIdleTimer>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Controls whether the idle timer is enabled. If enabled is true, the timer will be active (default); inactive if false. When active, the idle timer dims the screen and eventually puts the device to sleep when no user activity occurs (e.g. screen touches).


      </Description>
      <Syntax>


        system.setIdleTimer( enabled )





      </Syntax>
      <Example>

        system.setIdleTimer( false )  -- disable (turn off) the idle timer
         
        system.setIdleTimer( true )  -- enable (turn on) the idle timer





      </Example>
      <Parameters>

        enabled
        Either true or false to enable or disable the idle timer.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        Note: This API will not disable the screen saver on the Mac or Windows simulator.




      </Remarks>
    </system.setIdleTimer>
    <system.setLocationAccuracy>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets the desired accuracy of location (GPS) events to distance in meters. Note: the actual accuracy depends on the capabilities of the device and/or platform. On the iPhone, accuracy is limited to discrete distances:
        Related Items:
        Location Events


      </Description>
      <Syntax>


        system.setLocationAccuracy( distance )





      </Syntax>
      <Example>

        system.setLocationAccuracy( 10 )  -- set GPS accuracy to 10 meters





      </Example>
      <Parameters>

        frequency
        Location accuracy in meters.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </system.setLocationAccuracy>
    <system.setLocationThreshold>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Sets how much distance in meters must be travelled until the next location (GPS) event is sent. Because location events involve hardware that can drain the battery, using larger threshold distances preserve battery life.
        Related Items:
        Location Events


      </Description>
      <Syntax>


        system.setLocationThreshold( distance )





      </Syntax>
      <Example>

        system.setLocationThreshold( 100 )  -- fire the location event every 100 meters





      </Example>
      <Parameters>

        distance
        Location event distance (in meters). Defaults to 0 meters.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>





      </Remarks>
    </system.setLocationThreshold>
    <system.vibrate>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Vibrates the phone. On the Corona simulator this will sound a system beep.


      </Description>
      <Syntax>

        system.vibrate()





      </Syntax>
      <Example>

        system.vibrate()  -- vibrate the device





      </Example>
      <Parameters>

        None.





      </Parameters>
      <Returns>

        Nothing.





      </Returns>
      <Remarks>

        To enable the vibrate function on Android devices, you must set the permission level in the build.settings file.

        1
        2
        3
        4
        5
        6
        7
        settings =
        {
           androidPermissions =
           {
               "android.permission.VIBRATE"
           },
        }




      </Remarks>
    </system.vibrate>
  </System>
  <Timer>
    <timer.cancel>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Cancel a timer operation initiated with  timer.performWithDelay()


      </Description>
      <Syntax>

        timer.cancel( timerId )





      </Syntax>
      <Example>

         local t = {}
         function t:timer( event )
            local count = event.count
            print( "Table listener called " .. count .. " time(s)" )
            if count &gt;= 3 then
                timer.cancel( event.source ) -- after 3rd invocation, cancel timer
            end
         end
         
         
         -- Register to call t's timer method an infinite number of times
         timer.performWithDelay( 1000, t, 0 )





      </Example>
      <Parameters>

        timerId

        Handle returned by the call to timer.performWithDelay().





      </Parameters>
      <Returns>

        Starting with build 2011.596, returns two numbers:
        * Time Remaining

        * Number of iterations left





      </Returns>
      <Remarks>





      </Remarks>
    </timer.cancel>
    <timer.pause>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Pauses a timer started with timer.performWithDelay.


      </Description>
      <Syntax>

        result = timer.pause( timerId )





      </Syntax>
      <Example>

        local function listener( event )
            print( "listener called" )
         end
         
        timer1 = timer.performWithDelay( 2000, listener )  -- wait 2 seconds
        ...
        result = timer.pause( timer1 )
        print( "Time remaining is " .. result )





      </Example>
      <Parameters>

        timerId

        The Timer ID from timer.performWithDelay.





      </Parameters>
      <Returns>

        Number

        The time remaining at the time of the pause.





      </Returns>
      <Remarks>





      </Remarks>
    </timer.pause>
    <timer.performWithDelay>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Call a specified function after a delay.


      </Description>
      <Syntax>

        timer.performWithDelay( delay, listener [, iterations] )





      </Syntax>
      <Example>

        Function Listener
        1
        2
        3
        4
        5
        6
         local function listener( event )
            print( "listener called" )
         end
         
         timer.performWithDelay(
            1000, listener )
        Table Listener
        1
        2
        3
        4
        5
        6
        7
        local listener = {}
        function listener:timer( event )
           print( "listener called" )
        end
         
        timer.performWithDelay(
           1000, listener )
        NOTE: to pass a parameter to the listener, use a Lua closure, as in the following example:
        1
        2
        3
        4
        5
        6
        7
        8
        9
        10
        function newBall()
            local randomPosition = 100 + math.random(200)
            ballPosition = display.newImage("ballPosition.png")
            ballPosition.x = randomPosition
         
            -- wrap spawnBall and randomPosition inside a closure
            local myclosure = function() return spawnBall( randomPosition ) end
            timer.performWithDelay(2000, myclosure, 1)
            --spawnBall()
        end





      </Example>
      <Parameters>

        delay

        The delay in milliseconds.
        listener

        The listener to invoke after the delay.  May be either a function listener or a table listener. If a table, it must have a timer method because timer events are sent to the listener.
        iterations

        Optionally specifies the number of times listener is to be invoked. By default, it is 1; pass 0 if you want it to loop forever.





      </Parameters>
      <Returns>

        A handle that could be passed to timer.cancel() in order to cancel the invocation of  listener.





      </Returns>
      <Remarks>





      </Remarks>
    </timer.performWithDelay>
    <timer.resume>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        Resumes a timer that was paused with timer.pause.


      </Description>
      <Syntax>

        result = timer.resume( timerId )





      </Syntax>
      <Example>

        local function listener( event )
            print( "listener called" )
         end
         
        timer1 = timer.performWithDelay( 2000, listener )  -- wait 2 seconds
        ...
        result = timer.pause( timer1 )
        print( "Time remaining is " .. result )
        ...
        result = timer.resume( timer1 )
        print( "Fire time is " .. result )





      </Example>
      <Parameters>

        timerID

        The Timer ID from timer.performWithDelay.





      </Parameters>
      <Returns>

        Number

        Returns the time remaining.





      </Returns>
      <Remarks>





      </Remarks>
    </timer.resume>
  </Timer>
  <Widget>
    <widget.newButton>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This widget requires Corona build 2011.646 or higher.
        This is a basic button that supports onPress, onRelease, onDrag events (or an onEvent to handle all phases using a single listener). If no custom graphics are passed via options, and no supporting theme has been set, button will default to using a Rounded Rect which also supports customization.
        For a tutorial that walks you through button usage, please see: Adding Buttons to Your Games and Apps.


      </Description>
      <Syntax>

        widget.newButton( [options] )





      </Syntax>
      <Example>

            local widget = require "widget"
         
            local onButtonEvent = function (event )
                if event.phase == "release" then
                    print( "You pressed and released a button!" )
                end
            end
         
            local myButton = widget.newButton{
                id = "btn001",
                left = 100,
                top = 200,
                label = "Widget Button",
                width = 150, height = 28,
                cornerRadius = 8,
                onEvent = onButtonEvent
            }
         
            -- Insert button into a group:
            someGroup:insert( myButton )  -- if using older build, use: myButton.view instead
         
            -- Change the button's label text:
            myButton:setLabel( "My Button" )
         
            -- Remove the button
            display.remove( myButton )





      </Example>
      <Parameters>

        widget.newButton() takes a single argument, options, which is a Lua table that accepts the following parameters:
         

        id

        string. This is an optional id you can use to identify the button. Default is nil.
         

        left, top

        numbers. The initial x/y coordinates of the button's top/left corner.
         

        width, height

        numbers. If using a custom image, set this to the width/height of your default/over images (or you can omit these parameters if you don't want to use content scaling). If not using images, set these to whatever you want. default values for no image are: 124(w) and 42(h).
         

        label

        string. The text you want to appear over the button.
         

        labelColor

        table. This table should hold the red, green, blue, and alpha channels for the color of your label in both its 'default' and 'over' states. Here's an example table:

        { default={ 128, 255, 96, 255 }, over={ 0 } }
         

        xOffset, yOffset

        numbers. Use these options to offset the label text on the x and y-axis.
         

        font

        string. The font you want to be used for your label. default is native.systemFont.
         

        fontSize

        number. The font size (in pixels) for your label text. default is 14.
         

        emboss

        boolean (true/false). If set to true, label text will appear to be embossed (inset effect).
         

        default, over

        strings. These two parameters are the image files that will represent the 'default' and 'over' (pressed) states of the button. If no images are specified, and no theme is set, the button will default to using a rounded rect.
         

        baseDir

        system directory. This is the base directory where your custom images are located. The default is your project folder (system.ResourceDirectory).
         

        defaultColor, overColor

        tables. These two tables will hold the red, green, blue, and alpha channels for the the color of your button in the 'default' and 'over' (pressed) states, IF you're not using a custom image (for Rounded Rect buttons). Here is an example table:

        { 128, 128, 128, 255 }
         

        strokeColor

        table. This table will hold the red, green, blue, and alpha channels for the the color of the button's border, IF you're not using a custom image (for Rounded Rect buttons). Here is an example table:

        { 128, 128, 128, 255 }
         

        strokeWidth

        number. This is the width of the border (stroke) of your button, IF you're not using graphics resources (for rounded rect buttons).
         

        cornerRadius

        number. For rounded rect buttons, this is the corner radius that controls how curved the corners are. default is 8 (pixels).
         

        sheet

        Requires build 2012.824 or higher. Specify the image sheet object for the widget button (instead of graphic files). Requires defaultIndex, overIndex, width, and height to also be set.
         

        defaultIndex

        number. Requires build 2012.824 or higher. If using image sheets, this is the frame index for the button's default (up) state. Requires sheet, overIndex, width, and height to also be set.
         

        overIndex

        number. Requires build 2012.824 or higher. If using image sheets, this is the frame index for the button's over (down) state. Requires sheet, defaultIndex, width, and height to also be set.
         

        onPress

        function. This is an optional function to be called as soon as the button is pressed. This callback function does not require you to test for an event.phase (as it only has one) and should return true.
         

        onRelease

        function. This is an optional function to be called as soon as the user releases the button (while their finger was still over the button). This callback function does not require you to test for an event.phase (as it only has one) and should return true.
         

        onDrag

        function. This is an optional function to be called while user is moving their finger on-screen, after they have already pressed the button. This callback function does not require you to test for an event.phase (as it only has one) and should return true.
         

        onEvent

        function. This optional function should only be set if onPress, onRelease, and onDrag are NOT set. This callback function should test for an event.phase of "press", "moved", or "release" and should return true.
         
        Event Table
        The onPress, onDrag, onRelease, and onEvent callbacks will call the specified listener function and pass an 'event' table as the first argument. Below are the individual keys associated with the button's event table:
         

        event.name

        This will always be "buttonEvent".
         

        event.target

        This is a reference to the actual button widget that triggered the event (not the button's .view property, which doesn't exist after build 2012.721).
         

        event.phase

        For onEvent listeners only, this is so you can detect which "phase" of the event is occurring. Phases include: "press", "moved", and "release".
         
        Properties and Methods:
         

        view
        [NOTE: Deprecated as of build 2012.721â€”the widget is now the display object]
        If you need to do something with the widget's display object (such as place the button into a display group), you need to do so using the object's .view property. Example:
            local myButton = widget.newButton{ label="My Button" }
         
            -- WRONG, will produce error:
            myGroup:insert( myButton )
         
            -- CORRECT: access display group with .view property
            myGroup:insert( myButton.view )
         

        x, y

        Numbers. Normally, to access display object properties of the widget, you'd do so by using the .view property of the widget. However, you can optionally use the x/y property shortcut to change the on-screen location of the widget. Example:
            -- move the button to specific location on screen:
            myButton.x = 125
            myButton.y = 300
         

        button:setLabel()

        To change the button's label text, use the setLabel() method. Example:
            myButton:setLabel( "New Label" )
        Removing the widget:
        This widget can be removed in the same manner as any other display object, by using display.remove() or the removeSelf() method. Example:
            display.remove( myButton )
            myButton = nil
         
            -- or...
         
            myButton:removeSelf()
            myButton = nil
         
            -- IMPORTANT NOTE:
            -- Don't forget to set the reference variable to nil! (as shown above)





      </Parameters>
      <Returns>

        widget.newButton() returns a widget with it's own properties, methods, and a display object that can be accessed via its .view property. If using a build greater than 2012.721, then the .view property does not exist—the widget itself is the display object in that case.





      </Returns>
      <Remarks>





      </Remarks>
    </widget.newButton>
    <widget.newPickerWheel>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This widget requires Corona build 2011.646 or higher.

        The pickerWheel widget supports custom columns and the ability to extract values from column rows that are within the "selection area". As of version 0.2 (beta) of the widget library, there are no more presets (may be added in future versions). Additionally, it is a known issue that rows do not 'snap' or 'soft-land' into the selection area. There is also no longer an option for 'infinite' columns. We are working on bringing an update that will restore these behaviors.

        IMPORTANT
        It is currently a known issue that you cannot move the pickerWheel widget to a different location, or the getValues() function will cease to work. We are working on fixing this in a future update. Many people like to "slide-up" their pickerWheels, so instead, we suggest you make it "fade-in" for the time being if you want some kind of animation when the pickerWheel is shown.



      </Description>
      <Syntax>

        widget.newPickerWheel( [options] )





      </Syntax>
      <Example>

        local widget = require "widget"
               
        -- create table to hold all column data
        local columnData = {}
         
        -- create first column
        columnData[1] = { "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12" }
        columnData[1].alignment = "right"
        columnData[1].width = 120
        columnData[1].startIndex = 7
         
        -- second column (lots of rows)
        columnData[2] = {}
        columnData[2].alignment = "center"
        for i=1,59 do
           columnData[2][i] = i
        end
        columnData[2].startIndex = 30
         
        -- third column
        columnData[3] = { "AM", "PM" }
        columnData[3].startIndex = 2
         
        -- create the actual picker widget with column data
        local picker = widget.newPickerWheel{
                id="myPicker",
                font="Helvetica-Bold",
                top=258,
                columns=columnData
        }





      </Example>
      <Parameters>

        widget.newPickerWheel() takes a single argument, options, which is a Lua table that accepts quite a few parameters. It is recommended you choose a supporting theme and let the them file handle most of the custom graphics parameters for you, but the options are there for you to change if you want to create your own picker theme.
         

        id

        string. Can be set to anything you want, for easier identification of your widget. Default is "".
         

        width, height

        numbers. These correspond to the actual picker widget (not the background that can be stretched). The default values are 296 (width) and 222 (height). If you encounter unusual behavior when changing these from their defaults, please try to stick with the default values.
         

        left, top

        numbers. These numbers correspond to the location at with the top, left corner of the widget will be placed upon creation.
         

        totalWidth

        number. This corresponds to the width you want the entire background to be stretched to. In most instances, this will be the default, which is display.contentWidth.
         

        selectionHeight

        number. This is the height of your "selection area" graphic. If you experience unusual behavior, please stick with the default value, which is 46.
         

        font

        string. This is the font that will be used when rendering column rows. Default is native.systemFontBold.
         

        fontSize

        number. This is the size (in pixels) of the text for the pickerWheel's columns. Default is 22.
         

        fontColor

        table. This is a table that will hold the red, green, blue, and alpha channels for the text for each column. The default is black:

        { 0, 0, 0, 255 }
         

        columnColor

        table. This is a table that will hold the red, green, blue, and alpha channels for the column background color. The default is white:

        { 255, 255, 255, 255 }
         

        background

        string. If you choose to customize on your own (without using theme defaults), this will be the filename for your pickerWheel's background (it will be stretched to totalWidth, so we recommend using some kind of vertical gradient that's 2px or less in width).
         

        backgroundWidth, backgroundHeight

        numbers. If you specified a background parameter, set this to the width and height of your background image.
         

        glassFile

        string. If you choose to customize on your own (without using theme defaults), this will be the filename for your pickerWheel's selection area graphic (it appears as a glass strip in iOS).
         

        glassWidth, glassHeight

        numbers. If you specified a glassFile parameter, these should correspond to that image's width and height.
         

        separator

        string. If you choose to customize on your own (without using theme defaults), this will be the filename for the separator graphic that is used between each column. It will be stretched vertically, so we recommend using a graphic with a 1-2 pixel height.
         

        separatorWidth, separatorHeight

        numbers. If you specified a separator parameter, these should correspond to that image's width and height.
         

        maskFile

        string. This is the maskFile used to crop columns properly. We recommend going with theme defaults with this one, but once again, the parameter is there for you to use if ever the need arises.
         

        baseDir

        system directory. This is the base directory at which all of the above graphics resources are located, if you specified any, and if you're using a different base directory than system.ResourceDirectory (default).
         

        columns

        table. This is a table that should have sub-tables representing the individual columns in your picker wheel. The numerical keys in each column table will represent the individual rows (see Example section above). Additionally, each column table can have the following properties:
         
        Column Properties
         

        width

        number. By default, columns are split evenly between the pickerWheel's viewable area, but there are some cases where you want some columns to be wider than the others. Use the width property to set a custom width on a per-column basis.
         

        startIndex

        number. If you want a column to start at a specific row, specify the index number of that row here (much requested feature!).
         

        alignment

        string. This can either be set to "right" or "center". If this property is not set, text will be left-aligned for that column by default.
        Properties and Methods
         

        view

        If you need to do something with the widget's display object (such as place the button into a display group), you need to do so using the object's .view property. Example:
            -- WRONG, will produce error:
            myGroup:insert( myPicker )
         
            -- CORRECT: access display group with .view property
            myGroup:insert( myPicker.view )
         

        id

        string. Use this to access your picker's id property.
         

        x, y

        Numbers. Normally, to access display object properties of the widget, you'd do so by using the .view property of the widget. However, you can optionally use the x/y property shortcut to change the on-screen location of the widget. Example:
            -- move the picker to specific location on screen:
            myPicker.x = 160
            myPicker.y = 240
         

        picker:getValues()

        function that returns a table holding the value/index of the rows that are currently in the selection area. Example (for a picker with 3 columns):
        local selectedRows = myPicker:getValues()
               
        for i=1,#selectedRows do
                print( selectedRows[i].value, selectedRows[i].index )
        end
         
        -- output:
        -- 7    7
        -- 30   30
        -- PM   2
        Removing the widget:
        This widget can be removed in the same manner as any other display object, by using display.remove() or the removeSelf() method. Example:
            display.remove( myPicker )
            myPicker = nil
         
            -- or...
         
            myPicker:removeSelf()
            myPicker = nil
         
            -- IMPORTANT NOTE:
            -- Don't forget to set the reference variable to nil! (as shown above)





      </Parameters>
      <Returns>

        Corona widget object.





      </Returns>
      <Remarks>





      </Remarks>
    </widget.newPickerWheel>
    <widget.newTabBar>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This widget requires Corona build 2011.646 or higher.

        Creates a customizable bar with tab buttons. Buttons will be auto-positioned, depending on how many buttons you add to the tabBar. There is no limit to how many buttons you can add technically, but you want to avoid cramming too many buttons on any one tabBar (depending on the width of your target device's screen).


      </Description>
      <Syntax>

        widget.newTabBar( [options] )





      </Syntax>
      <Example>

        1
        2
        3
        4
        5
        6
        7
        8
        9
        10
        11
        12
        13
        14
        15
        16
        17
        18
        19
        20
        21
        22
        23
        24
        25
        26
        27
        28
            local widget = require "widget"
         
            local function onBtnPress( event )
                print( "You pressed tab button: " .. event.target.id )
            end
         
            local tabButtons = {
                {
                    label="First Tab",
                    up="firstIcon.png",
                    down="firstIcon-down.png",
                    width=32, height=32,
                    onPress=onBtnPress,
                    selected=true
                },
                {
                    label="Second Tab",
                    up="secondIcon.png",
                    down="secondIcon-down.png",
                    width=32, height=32,
                    onPress=onBtnPress
                },
            }
           
            local tabs = widget.newTabBar{
                top=430,
                buttons=tabButtons
            }





      </Example>
      <Parameters>

        widget.newTabBar() takes a single argument, options, which is a Lua table that accepts the following parameters:
         

        width, height

        numbers. Set these if you want to use a custom width/height for your tab bar. The default width is equal to display.contentWidth, and the default height is 50.
         

        left, top

        numbers. This is the position where you want your tab bar to be created. Most iOS apps place the tabBar at the bottom of the screen (which would be display.contentHeight - tabBar.height, or default 50). The default values for left and top are 0, 0.
         

        background

        string. If you'd rather use a static image for the background of your tab bar, specify the filename to your graphics resource here.
         

        baseDir

        system folder. If using a background image and need to specify a base directory different from the default (system.ResourceDirectory), you may set this to system.DocumentsDirectory, system.TemporaryDirectory, or system.CachesDirectory).
         

        topGradient

        gradient object via graphics.newGradient(). If no graphics asset is specified with the 'background' parameter, by default the tabBar background will consist of a gradient for the top half of the background, and a solid color for the bottom. If you want to use a custom gradient for the top-half of the tabBar, create one using graphics.newGradient() and set a reference to it here.
         

        bottomFill

        table. If no custom graphic is being used, you can optionally set the color of the bottom half of the tabBar. Pass the red, green, blue, and alpha channels in a table. The default is black:

        { 0, 0, 0, 255 }
         

        buttons

        table. This is a table that will hold all parameters and options for the individual tab buttons. Please see the Buttons Table section below for more information.
         
        Buttons Table
        The buttons table is a parameter that is referenced as an option for the tabBar widget. This table should have sub-tables that represent the individual buttons that will be placed on the tabBar.
        In the example shown above, tabButtons is the buttons table that has two buttons (see it for further demonstration).
        Button Parameters
        You can set the following parameters for each button table:
         

        id

        string. You can set this to be whatever you want. By default this will equal the number that represents the button's index on the tabBar. For instance, the second button would have a default id of 2.
         

        up

        string. This represents the filename for the 'up'-state icon for this button. This should not be omitted.
         

        upWidth, upHeight

        [NOTE: Deprecated as of build 2012.721—use width/height instead] numbers. These parameters should be equal to the width and height of your 'up'-state icon for the button. Recommended icon size is 32 x 32.
         

        down

        string. This represents the filename for the 'down'-state (selected tab) icon for this button. This should not be omitted.
         

        downWidth, downHeight

        [NOTE: Deprecated as of build 2012.721—use width/height instead]numbers. These parameters should be equal to the width and height of your 'down'-state (selected tab) icon for the button. Recommended icon size is 32 x 32.
         

        width, height

        numbers. Requires build 2012.721 or higher (and should be used in place of upWidth/upHeight and downWidth/downHeight. These numbers should represent the width and height of the tab button image size. Default is 32 x 32.
         

        baseDir

        system directory. If the icon graphics for your button are not in system.ResourceDirectory (default), specify the alternate base directory here.
         

        label

        string. This is the text that will appear below the button's icon. If no label is specified, no text will be shown, and the icon will be shifted down. It is recommended you remain consistent with all buttons on your tab bar (if you set a label for one, you should set one for all).
         

        font

        string. The font that will be used for your label text, if label text is specified. Default is native.systemFontBold.
         

        size

        number. The font size (in pixels) for your label text. Default is 10 (in most cases, this should be very small).
         

        labelColor

        table. This is a table that will hold values that represent the red, green, blue, and alpha channels for the color of your label text. The default is:

        { 124, 124, 124, 255 }
         

        cornerRadius

        number. When a tab button is selected, a rounded rectangle appears over the button. This parameter sets the roundness of the corners of that rectangle. The default is 4.
         

        selected

        boolean (true/false). This determines if the button is in it's 'selected' (down) state upon creation. No more than ONE of your buttons should have this parameter set to true when you create your buttons table.
         

        onPress

        function. This is the listener function that is called when the tab button is pressed.
         
        Event Table
        Your onPress event listener can have up to one argument, which will be an event table that holds specific event-related data, which includes:
         

        event.name

        This will always be "tabButtonPress"
         

        event.target

        This is a reference to the actual tab button that triggered the event.
         

        event.targetParent

        This is a reference to the tabBar widget which is the parent of the button that triggered the event.
         
        Properties and Methods:
        Below are the individual properties and methods associated with the tabBar widget (not the buttons):
         

        pressButton( buttonIndex [, invokeListener] )

        Available since build 2011.700. If you need to make a specific button on the tab bar pressed, you can call the pressButton() method and specify the button index you want to be in the "down" state. Optionally, you can invoke the 'onPress' listener for the button at this time (default is false). Example:
            myTabBar:pressButton( 1 )  -- put first button in 'down' state
         
            myTabBar:pressButton( 3, true )  -- 3rd button in down state and invoke onPress listener
         

        view

        [NOTE: Deprecated as of build 2012.721—the widget is now the display object]
        If you need to do something with the widget's display object (such as place the button into a display group), you need to do so using the object's .view property. Example:
            -- prior to build 2012.721:  
         
            -- WRONG, will produce error:
            myGroup:insert( myTabBar )
         
            -- CORRECT: access display group with .view property
            myGroup:insert( myTabBar.view )
         
            - after build 2012.72:
         
            myGroup:insert( myTabBar ) -- correct
         

        x, y

        numbers. Normally, to access display object properties of the widget, you'd do so by using the .view property of the widget. However, you can optionally use the x/y property shortcut to change the on-screen location of the widget. Example:
            -- move the tabBar to specific location on screen:
            myTabBar.x = 160
            myTabBar.y = 480-25
        Removing the widget:
        This widget can be removed in the same manner as any other display object, by using display.remove() or the removeSelf() method. Example:
            display.remove( myTabBar )
            myTabBar = nil
         
            -- or...
         
            myTabBar:removeSelf()
            myTabBar = nil
         
            -- IMPORTANT NOTE:
            -- Don't forget to set the reference variable to nil! (as shown above)





      </Parameters>
      <Returns>

        Corona widget object.





      </Returns>
      <Remarks>





      </Remarks>
    </widget.newTabBar>
    <widget.newTableView>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This widget requires Corona build 2011.646 or higher. Some features require build 2012.721 or later.

        tableViews allow you to create scrolling lists. As of widget version 0.2 (beta), you will now control 100% of the rendering of the individual rows (to include category rows). This allows for much greater flexibility, however, it also requires a bit more work getting them set up.
        Additionally, it is a known issue that scroll bars are no longer present in this version. Please be patient as we are working on restoring scrollbars in a future update to this widget.

        WARNING:
        If you want a tableView that does not extend to the full height of the device's screen, you need to create a bitmap mask that corresponds to the width/height of your tableView. Read this tutorial to learn how to properly create a bitmap mask specifically for scrollViews and tableViews.


      </Description>
      <Syntax>

        widget.newTableView( [options] )





      </Syntax>
      <Example>

        local widget = require "widget"
         
        local listOptions = {
                top = display.statusBarHeight,
                height = 410,
                maskFile = "mask-410.png"
        }
         
        local list = widget.newTableView( listOptions )
         
        -- onEvent listener for the tableView
        local function onRowTouch( event )
                local row = event.target
                local rowGroup = event.view
         
                if event.phase == "press" then
                        if not row.isCategory then rowGroup.alpha = 0.5; end
         
                elseif event.phase == "swipeLeft" then
                        print( "Swiped left." )
         
                elseif event.phase == "swipeRight" then
                        print( "Swiped right." )
         
                elseif event.phase == "release" then
         
                        if not row.isCategory then
                                -- reRender property tells row to refresh if still onScreen when content moves
                                row.reRender = true
                                print( "You touched row #" .. event.index )
                        end
                end
         
                return true
        end
         
        -- onRender listener for the tableView
        local function onRowRender( event )
                local row = event.target
                local rowGroup = event.view
         
                local text = display.newRetinaText( "Row #" .. event.index, 12, 0, "Helvetica-Bold", 18 )
                text:setReferencePoint( display.CenterLeftReferencePoint )
                text.y = row.height * 0.5
                if not row.isCategory then
                        text.x = 15
                        text:setTextColor( 0 )
                end
         
                -- must insert everything into event.view:
                rowGroup:insert( text )
        end
         
        -- Create 100 rows, and two categories to the tableView:
        for i=1,100 do
                local rowHeight, rowColor, lineColor, isCategory
         
                -- make the 25th item a category
                if i == 25 then
                        isCategory = true; rowHeight = 24; rowColor={ 70, 70, 130, 255 }; lineColor={0,0,0,255}
                end
         
                -- make the 45th item a category as well
                if i == 45 then
                        isCategory = true; rowHeight = 24; rowColor={ 70, 70, 130, 255 }; lineColor={0,0,0,255}
                end
           
                -- function below is responsible for creating the row
                list:insertRow{
                        onEvent=onRowTouch,
                        onRender=onRowRender,
                        height=rowHeight,
                        isCategory=isCategory,
                        rowColor=rowColor,
                        lineColor=lineColor
                }
        end
         
        -- delete the tenth row in the tableView
        list:deleteRow( 10 )    -- can be an index number or an actual row table (from within an event)





      </Example>
      <Parameters>

        widget.newTableView() takes a single argument, options, which is a Lua table that accepts specific parameters. Please read over Properties and Methods section before using this widget, and study the example above.
         

        bgColor

        table. This table should have the red, green, blue, and alpha channels for the color of the rectangle to be placed behind the tableView. Default is white:

        { 255, 255, 255, 255 }
         

        hideBackground

        [Requires build 2012.721 or later] boolean (true/false). If you set this parameter to false, the background of the tableView widget will be hidden (but still receive touches).
         

        left, top

        numbers. The left and top coordinate in which the tableView will be placed upon creation. The default value for both is 0.
         

        width, height

        numbers. The width represents the maximum width that rows will be rendered. The height represents the total height of the tableView. The default values are the full width and height of the screen. Remember, if you set a height, you must provide a matching bitmap mask so the tableView is cropped correctly. Read this tutorial to learn how to create a bitmap mask for use with tableViews and scrollViews.
         

        topPadding, bottomPadding

        numbers. These are numbers that represent the number of pixels from the top and bottom of the tableView in which rows will stop when you reach the top/bottom of the list. The default value for both is 0.
         

        renderThresh

        number. This is the pixel amount to the top and bottom of the tableView in which rows are rendered and de-rendered. If for whatever reason you're able to see the rows being de-rendered, you should increase this value from the default of 150. In most cases, you should never have to touch this.
         

        friction

        number. This determines how fast the rows travel when they are flicked up or down. The default value is 0.935, which should be sufficient for most cases. In previous versions of this widget, you were not able to set this property, but we realized there may be times you want the "flick speed" to be faster or slower.
         

        maxVelocity

        [Requires build 2012.721 or later] number. Use this to limit the maximum scrolling speed of the TableView widget. The default value is 10.
         

        maskFile

        string. If you set a custom height, you need to specify the maskFile parameter, which is the filename of the bitmap mask which will be used on your tableView. Read this tutorial to learn how to create a bitmap mask for use with tableViews and scrollViews.
        Properties and Methods
         

        view

        NOTE: As of build 2012.721, there is no longer a .view property. The widget IS the display object.. If you need to do something with the widget's display object (such as place the button into a display group), you need to do so using the object's .view property. Example:
            -- Only applies to builds prior to 2012.721:
         
            -- WRONG, will produce error:
            myGroup:insert( list )
               
            -- CORRECT: access display group with .view property
            myGroup:insert( list.view )
         

        view.content

        This is the display group that represent the content that holds all the display objects of every row. The rows table is accessed from view.content.rows
         

        isLocked

        boolean (true/false). If set to true, the tableView will be prevented from scrolling.
         

        tableView:insertRow( [params] )

        This method is used for inserting rows into the tableView (see example for usage demonstration). This function accepts the following parameters:
        id (string, can be used to identify row)

        width, height (numbers)

        rowColor, lineColor (tables with r, g, b, a values)

        isCategory (boolean, true/false - will cause row to "stick" to top of tableView)

        listener build 2012.721 (function - see Row Events section)

        onEvent (function - see Row Events section)

        onRender (function - see Row Events section)
         

        tableView:deleteRow( rowOrIndex )

        Use this method to delete specific row by index number, or by passing the actual row table (if in an event listener, that would be event.target).
         

        tableView:deleteAllRows()

        Use this method to clear all rows from a tableView widget instance. Requires build 2012.826 or later.
         

        tableView:getScrollPosition()

        NOTE: If you're using build 2012.721 or later, this method is no longer available. It has been replaced with getContentPosition(). This will return the current yPosition of the tableView content. This is mostly used to mark a position of the tableView, and then scroll to that stored position using the scrollToY() method. Since tableViews can't be rotated, it's recommended you use this function to mark the content position, destroy the tableView, then recreate it in the correct position (orientation?) and use scrollToY() to return it to it's previous position.
         

        tableView:getContentPosition()

        [Requires build 2012.721 or later] See getScrollPosition() (above).
         

        tableView:scrollToY( yPosition, timeInMs )

        Make tableView scroll to a specific y position (Note: this will most-likely be a negative number). This method is normally used after the getScrollPosition() method. timeInMs is the time in milliseconds it will take to scroll to the desired position. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 1500.
         

        tableView:scrollToIndex( index, timeInMs )

        Make tableView scroll to a specific row that has the index position 'index'. The top of the row will be at the top position of the tableView (plus topPadding, if any). timeInMs is the time in milliseconds it will take to scroll to the desired position. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 1500.
         
        Row Events
        When you call the insertRow() method with your tableView, you pass a table of parameters. Two of the parameters are onEvent and onRender, which correspond to your touch listener (onEvent) for that specific row item, and the render listener (onRender) which is responsible for creating the row's visual elements (all controlled by you). Please see the example for basic usage demonstration.
        When you create your event listeners, they will have a table passed as the first argument, which includes the following keys:
         

        event.name

        For onRender listeners, this will be "tableView_onRender", and for onEvent listeners, it will be "tableView_onEvent".
         

        event.tableView

        NOTE: If using build 2012.721 or later, use event.parent instead. This is a reference to the tableView widget object that the row belongs to (onRender, onEvent)
         

        event.parent

        [Requires build 2012.721 or later] Direct reference to the tableView that the row belongs to.
         

        1
        2
        3
        4
        event.backgroundstrong&gt;
        [strong&gt;Requires build 2012.721 or laterstrong&gt;] Direct reference to the background rectangle for the row.
         
        code&gt;

        1
        2
        3
        4
        event.linestrong&gt;
        [strong&gt;Requires build 2012.721 or laterstrong&gt;] Direct reference to the vector line object for the row (appears at the bottom of the row, used to help visually separate it from other rows).
         
        code&gt;

        event.target

        This is a reference to the actual row that triggered the event (onRender, onEvent). This can be passed as the first argument of tableView:deleteRow() method to delete the row.
         

        event.view

        This is a reference to the display group that holds all of the row's display objects. If you create a display object for a specific row in your onRender listener (such as a text object, or an image), you MUST insert those objects into the event.view group or they will not get rendered properly, and may even cause memory leaks (see example for usage).
         

        event.phase

        For onEvent listeners, the event.phase will either be "press" or "release". For onEvent listeners, you should always test for a phase, and return true on success. As build 2011.701, two are available: "leftSwipe" and "rightSwipe". As of build 2012.721, another phase has been added: "tap"
         

        event.index

        This is a number that represent's the row's position in the tableView. For instance, if the first row item triggered the onRender or onEvent callback listener, the event.index would be 1.
        Removing the widget:
        This widget can be removed in the same manner as any other display object, by using display.remove() or the removeSelf() method. Example:
            display.remove( list )
            list = nil
               
            -- or...
               
            list:removeSelf()
            list = nil
               
            -- IMPORTANT NOTE:
            -- Don't forget to set the reference variable to nil! (as shown above)





      </Parameters>
      <Returns>

        Corona widget object.
        After build 2012.721: Corona widget display object.





      </Returns>
      <Remarks>

        Some features require build 2012.721 or later. As of this build, the tableView widget is a display object and no longer has to be removed separately from its parent group.




      </Remarks>
    </widget.newTableView>
    <widget.setTheme>
      <IsFunction>true</IsFunction>
      <IsClassFunction>false</IsClassFunction>
      <Description>
        This function requires Corona build 2011.646 or higher.
        Used to set the theme you want the widget library to use when creating widgets. This widget should be called immediately after require "widget" if you plan on using a widget theme.
        Theme files consist of Lua files with theme tables that correspond to individual widgets. You may edit existing theme files or create new ones depending on your needs.
        You can find an updated listing of the official Corona SDK widget themes here:

        http://developer.anscamobile.com/content/widget#Using_Widget_Themes


      </Description>
      <Syntax>

        widget.setTheme( themeFile )





      </Syntax>
      <Example>

            local widget = require "widget"
            widget.setTheme( "theme_ios" )    -- relies on theme_ios.lua inside of project folder





      </Example>
      <Parameters>

         

        themeFile

        string. This is the filename of the theme's Lua file (without the .lua). For instance, if your theme file is "theme_ios.lua" then the string you'd use would be "theme_ios".





      </Parameters>
      <Returns>






      </Returns>
      <Remarks>





      </Remarks>
    </widget.setTheme>
  </Widget>
  <widget.newScrollView>
    <IsFunction>true</IsFunction>
    <IsClassFunction>false</IsClassFunction>
    <Description>
      The scrollView widget allows you to create scrolling content areas. Objects are inserted into the scrollView just as with any other display group, using the insert() method.
      For a more hands-on approach, please read this tutorial to learn how to use the scrollView widget.

      WARNING:
      If you want a scrollView that does not extend to the full width and height of the device's screen (e.g. you need it to be clipped), you must create a bitmap mask that corresponds to the width/height of your scrollView. Read this tutorial to learn how to properly create a bitmap mask specifically for scrollViews and tableViews.
      Important Changes

      There is no more ".view" property for any widget as of version 0.5b — widgets now return display groups and can be tweened/removed as such. If you have any code where you insert a widget's view property into a group, that code will now throw an error.
      There are two new parameters: scrollWidth and scrollHeight which corresponds to the scrollable content area. If you do not specify these parameters, they will be set to the width/height of your scrollView.
      scrollViews can scroll horizontally and vertically. Setting the scrollWidth/scrollHeight to less than or equal to the width/height of the widget will disable scrolling in that direction.
      You can now specify a listener function to listen to the following event types: "beganScroll", "endedScroll", "movingToTopLimit", "movingToBottomLimit", "movingToLeftLimit", "movingToRightLimit"



    </Description>
    <Syntax>

      widget.newScrollView( [options] )





    </Syntax>
    <Example>

      local widget = require "widget"
       
      -- function to listen to scrollView events
      local function scrollViewListener( event )
          local s = event.target    -- reference to scrollView object
       
          if event.type == "beganScroll" then
              print( "beganScroll event type" )
         
          elseif event.type == "endedScroll" then
              print( "endedScroll event type" )
       
          elseif event.type == "movingToTopLimit" then
              print( "movingToTopLimit event type" )
       
          elseif event.type == "movingToBottomLimit" then
              print( "movingToBottomLimit event type" )
       
          elseif event.type == "movingToLeftLimit" then
              print( "movingToLeftLimit event type" )
       
          elseif event.type == "movingToRightLimit" then
              print( "movingToRightLimit event type" )
          end
      end
       
      -- Create a new ScrollView widget:
      local scrollView = widget.newScrollView{
          width = 320
          height = 320,
          scrollWidth = 768,
          scrollHeight = 1024,
          maskFile="mask-320x320.png",
          listener = scrollViewListener
      }
       
      -- Create an object and place it inside of ScrollView:
      local myObject = display.newImage( "myobj.png" )
      scrollView:insert( myObject )
       
      -- Place the ScrollView into a group:
      local someGroup = display.newGroup()
      someGroup:insert( scrollView )
       
      -- Remove the ScrollView (will also remove content inserted into, e.g. myObject):
      display.remove( scrollView )
      scrollView = nil





    </Example>
    <Parameters>

      widget.newScrollView() takes a single argument, options, which is a Lua table that accepts specific parameters. Please read over Properties and Methods section before using this widget, and study the example above.
       

      id

      string. Can be set to optionally identify the widget. Default value is "widget_scrollView".
       

      left, top

      numbers. The left and top coordinate in which the scrollView will be placed upon creation. The default value for both is 0.
       

      width, height

      numbers. The width and height of the scrollView widget in pixels. The default values are the full width and height of the screen. Remember, if you set a height, you must provide a matching bitmap mask so the scrollView's content is cropped correctly. Read this tutorial to learn how to create a bitmap mask for use with scrollViews and tableViews.
       

      scrollWidth, scrollHeight

      numbers. These required values represent the width/height of the total scrollable content area. This cannot be changed after the scrollView widget has been created.
       

      topPadding, bottomPadding

      numbers. These are numbers that represent the number of pixels from the top and bottom of the scrollView in which content will stop when content reaches top/bottom of scrollable area. The default value for both is 0.
       

      friction

      number. This determines how fast the rows travel when they are flicked up or down. The default value is 0.935, which should be sufficient for most cases. In previous versions of this widget, you were not able to set this property, but we realized there may be times you want the "flick speed" to be faster or slower.
       

      maskFile

      string. If you set a custom height, you need to specify the maskFile parameter, which is the filename of the bitmap mask which will be used on your tableView. Read this tutorial to learn how to create a bitmap mask for use with scrollViews and tableViews.
       

      bgColor

      array. An optional array with four keys that represent the red, green, blue, and alpha values of the scrollView's background. Default is white: { 255, 255, 255, 255 }.
       

      hideBackground

      boolean (true/false). If set to true, the background of the scrollView will be not be visible.
       

      listener

      function. Used to listen for scrollView events, with event types of: beganScroll, endedScroll, movingToTopLimit, movingToBottomLimit, movingToLeftLimit, movingToRightLimit. In your listener, event.target is a reference to the scrollView display object that the listener is attached to. See the example above for how to write your listener function.
      Properties and Methods
       

      scrollView.content

      This property is the actual display group with the scrolling content (objects you insert into scrollView). You can modify the x/y values of this group to move the content manually.
       

      scrollView.isLocked

      boolean (true/false). When set to true, scrollView will be prevented from scrolling.
       

      scrollView.content.horizontalScrollDisabled

      boolean (true/false). Set this to true if you need to explicitly disable horizontal scrolling.
       

      scrollView.content.verticalScrollDisabled

      boolean (true/false). Set this to true if you need to explicitly disable vertical scrolling.
       

      scrollView:getContentPosition()

      Returns two values: the x and y coordinates of scrollView content.
       

      scrollView:takeFocus( event )

      If you have an object with a touch listener (such as a button widget) inside of your scrollView, you should call this method within the "moved" phase of your object's touch listener, and pass the touch event's event table as the 'event' parameter of this method. This prevents the touch events of objects from interfering with scrollView behavior and vice-versa.
       

      scrollView:scrollToPosition( x, y, timeInMs, onComplete )

      Make scrollView scroll to a specific x or y position (Note: this should be 0 or a negative number). timeInMs is the time in milliseconds it will take to scroll to the desired position. onComplete is an optional function you can specify to be called after scrolling is complete. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 500. If you only want the scrollView to scroll in one direction, set the x or y value to equal the scrollView's current x or y, or simply set the corresponding argument to nil.
       

      scrollView:scrollToTop( timeInMs, onComplete )

      Make scrollView scroll to very top content position. timeInMs is the time in milliseconds it will take to scroll. onComplete is an optional function you can specify to be called after scrolling is complete. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 500.
       

      scrollView:scrollToBottom( timeInMs, onComplete )

      Make scrollView scroll to very bottom content position. timeInMs is the time in milliseconds it will take to scroll. onComplete is an optional function you can specify to be called after scrolling is complete. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 500.
       

      scrollView:scrollToLeft( timeInMs, onComplete )

      Make scrollView scroll to very left content position. timeInMs is the time in milliseconds it will take to scroll. onComplete is an optional function you can specify to be called after scrolling is complete. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 500.
       

      scrollView:scrollToRight( timeInMs, onComplete )

      Make scrollView scroll to very right content position. timeInMs is the time in milliseconds it will take to scroll. onComplete is an optional function you can specify to be called after scrolling is complete. If you want the scrolling to be instantaneous (no effect), set timeInMs to 0. The default value for timeInMs is 500.
       

      insert()
      Function. This is the same function used by normal display groups. Use this to add items to your scrollView, as you would any other group. Example:
          local myObj = display.newImage( "obj.png" )
       
          -- add myObj to existing ScrollView:
          scrollView:insert( myObj )





    </Parameters>
    <Returns>

      Corona widget display group.





    </Returns>
    <Remarks>

      This widget as described on this page requires build 2012.721 or later.




    </Remarks>
  </widget.newScrollView>
  <widget.newSlider>
    <IsFunction>true</IsFunction>
    <IsClassFunction>false</IsClassFunction>
    <Description>
      Slider widget which returns a Corona widget display group. The slider can be customized with your own graphics. If no custom graphics are specified (or supported theme), the widget will be constructed using vector shapes.
      For an example of how to use the slider, and how you should create graphics assets for this widget, please see the WidgetDemo sample in the Corona download, in the following folder:
      /SampleCode/Interface/WidgetDemo


    </Description>
    <Syntax>

      widget.newSlider( [options] )





    </Syntax>
    <Example>

          local widget = require "widget"
         
          -- slider listener function
          local function sliderListener( event )
              print( "Slider at " .. event.value .. "%" )
          end
             
          local slider = widget.newSlider{
              top = 200,
              left = 50,
              listener = sliderListener
          }
         
          -- insert slider into another display group
          local group = display.newGroup()
          group:insert( slider )
         
          -- remove the slider
          display.remove( slider )
          slider = nil





    </Example>
    <Parameters>

      widget.newSlider() takes a single argument, options, which is a Lua table that accepts specific parameters. Please read over Properties and Methods section before using this widget, and study the example above.
       

      id

      string. Can be set to optionally identify the widget. Default value is "widget_slider".
       

      left, top

      numbers. The left and top coordinate in which the slider will be placed upon creation. The default value for both is 0.
       

      width, height

      numbers. This is the width/height of your slider widget. If you are using custom graphical resources (or a supported theme), this should match your background image exactly. If you're not using custom graphical resources or a supported theme, this can be anything you want. The default is 200 and 10 respectively.
       

      background

      string (optional). To use a custom background image for your slider, this should represent the filename and path relative to your chosen baseDir (or your project folder if you don't specify a baseDir). To see how you might create your own slider background, please see the slider theme graphics from the WidgetDemo sample project. If no background is specified, the slider background will be constructed with a rounded rect vector object.
       

      handle, handleWidth, handleHeight

      string, number, number (optional). This is the image file of your slider's handle. If you do not specify a handle, the handle will be constructed with a circle vector object.
       

      leftWidth

      number. Represents the width of the left "cap" of the slider. Default is 16. If you use the slider theme from the WidgetDemo as a template, you should be safe with the default value here.
       

      fillImage, fillWidth

      string, number (optional). This is the "fill" image that will be stretched as the handle is dragged and is usually 1-2px wide. If you set the fillImage, you must also set fillWidth.
       

      baseDir

      system directory. If you are using custom graphical resources (or a supported theme), this is the base directory in which those assets reside. The default is system.ResourceDirectory (your project folder).
       

      cornerRadius

      number. If you are NOT using custom graphical assets (or a supported theme), this will represent the corner radius of the slider background, which will be constructed with a rounded rect. Default is 5.
       

      fillColor, handleColor, handleScroke, bgFill, bgStroke

      tables. If you're not using custom graphical resources (or a supported theme), you can set these parameters as Lua tables as arrays with keys representing the red, green, blue, and alpha values for the corresponding object. Example: { 128, 233, 255, 255 }
       

      width, height

      numbers.
       

      value

      number (0-100). Represents the starting value of the slider upon creation. Default is 50.
       

      listener

      function. Listen to slider movement events. You can get the new value of the slider via event.value, and a reference to the slider value via event.target.
      Properties and Methods
       

      slider:setValue( value )

      Set a new value for the slider widget. The value parameter is a number (0-100). This is the value of the slider widget, which is a number 0-100, which corresponds to the percentage position of the handle from left to right.





    </Parameters>
    <Returns>

      Corona widget display object.





    </Returns>
    <Remarks>

      This widget as described on this page requires build 2012.721 or later.




    </Remarks>
  </widget.newSlider>
</CoronaAPI>