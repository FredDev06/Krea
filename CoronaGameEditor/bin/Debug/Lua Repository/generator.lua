--- This module is provided  as it by Native-Software for use into a Krea project.
-- @author Frederic Raimondi
-- @copyright Native-Software 2012 - All Rights Reserved.
-- @release 1.0 
-- @description Generator is a module to duplicate a Object Instance (see also object.lua)
-- <br>Changing the content of this file is at your own risk.
-- As the software Krea uses this file to auto-generate code, it can create errors during generation if you change his content.</br>

module("generator", package.seeall)

--- 
-- Members of the Generator Instance
-- @class table
-- @name Fields
-- @field params The table params used to create the generator instance
-- @field name The name of the generator
-- @field objectAttached The fastener of the generator if existing
-- @field objectToDuplicate The Object instance to duplicate
-- @field iteration The number of object to generate (-1 = Infinite)
-- @field delay The delay in milliseconds between two object generation
-- @field copyPhysicBody Indicates whether the generator should also copy the physics body of the object to duplicate
-- @field map The instance of a Tiles map if existing in the scene
-- @field isGenerating Indicates whether the generator is generating objects or not
-- @field tabObjects A table containing all object instances generated by the generator

	
	
Generator = {}
Generator.__index = Generator

--- 
-- @description Create a new Generator Instance
-- @return Return a new Generator Instance
-- @param params Lua Table containing the params
-- @see object
-- @usage Usage:
-- <ul>
-- <li><code>local params = {}
-- <br>params.name = "name"
-- <br>params.objectToDuplicate = objectInstance1
-- <br>params.delay = 1000 (in milliseconds)
-- <br>params.iteration = 10 (-1 is infinite)
-- <br>params.map = tilesmapInstance1, (can be nil)
-- <br>params.attachToObject = objectInstance1</li>
-- <li> local generatorInstance = require("generator").Generator.create(params)</code></li>
-- </ul>
function Generator.create(params)
	
	--Init attributes of instance
	local gen = {}           
	setmetatable(gen,Generator)
	
	--Init attributes
	gen.name = params.name
	gen.objectAttached = params.objectAttached
	gen.objectToDuplicate = params.objectToDuplicate
	gen.iteration = params.iteration
	gen.delay = params.delay
	gen.copyPhysicBody = params.copyPhysicBody
	gen.idTimerGeneration = nil
	gen.map = params.map
	gen.isGenerating = false
	gen.tabObjects = {}
	gen.insertCloneAtEndOfGroup = params.insertCloneAtEndOfGroup
	
	-- Generator Emission Type
	gen.emissionType = params.emissionType
	
	-- FADE IN
	gen.fadeInSpeed = params.fadeInSpeed
	gen.fadeInEnabled = params.fadeInEnabled
	
	-- FADE OUT
	gen.fadeOutSpeed = params.fadeOutSpeed
	gen.fadeOutEnabled = params.fadeOutEnabled
	gen.removeOnCompleteFadeOut = params.removeOnCompleteFadeOut
	--Delay between fades
	gen.delayBetweenFades = params.delayBetweenFades
	
	-- GENERATION IMPULSION
	gen.xImpulse = params.xImpulse
	gen.yImpulse = params.yImpulse
	gen.angularImpulse = params.angularImpulse
	
	gen.generate = function()

		if(gen.objectToDuplicate) then 

			if(gen.objectToDuplicate.isEntity) then 
			
				local newEntity = gen.objectToDuplicate:clone(gen.insertCloneAtEndOfGroup)
				table.insert(gen.tabObjects,newEntity)
				
				for k,newObj in pairs(newEntity.tabObjects) do
					if(newObj) then 
						
						newObj:startInteractions()
						if(newObj.hasBody == true) then 
							newObj.object:applyLinearImpulse(gen.xImpulse,gen.yImpulse,newObj.object.x,newObj.object.y)
							newObj.object:applyAngularImpulse(gen.angularImpulse)
						end
					end
				end
				
				if(gen.fadeInEnabled == true and gen.fadeOutEnabled == false) then 
					for k,newObj in pairs(newEntity.tabObjects) do
						if(newObj) then 
							newObj.object.alpha = 0
							transition.to(newObj.object,{time = gen.fadeInSpeed,alpha = 1})
						end
					end
				elseif(gen.fadeInEnabled == true and gen.fadeOutEnabled == true) then 
					
					for k,newObj in pairs(newEntity.tabObjects) do
						if(newObj) then 
							newObj.object.alpha = 0
						end
					end
					
					local onCompleteFadeIn = function()
						local onTick = function()
							if(gen.removeOnCompleteFadeOut == true) then 
								local onCompleteFadeOut = function()
									newEntity:clean()
									newEntity = nil
								end
								
								local count = 0
								for k,newObj in pairs(newEntity.tabObjects) do
									count = count+1
									if(newObj and count ==1) then 
										transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0,onComplete = onCompleteFadeOut})
									elseif(newObj) then 
										transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0})
									end
								end
								
							else
								for k,newObj in pairs(newEntity.tabObjects) do
									if(newObj) then 
										transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0})
									end
								end
								
							end
						end

						for k,newObj in pairs(newEntity.tabObjects) do
							if(newObj) then 
								newObj.object.alpha = 1
							end
						end
						
						timer.performWithDelay(gen.delayBetweenFades,onTick,1)
					end
					
					local count = 0
					for k,newObj in pairs(newEntity.tabObjects) do
						count = count+1
						if(newObj and count ==1) then 
							transition.to(newObj.object,{time = gen.fadeInSpeed,alpha = 1,onComplete = onCompleteFadeIn})
						elseif(newObj) then 
							transition.to(newObj.object,{time = gen.fadeInSpeed,alpha = 1})
						end
					end
					
				
				elseif(gen.fadeInEnabled == false and gen.fadeOutEnabled == true) then 
					
					if(gen.removeOnCompleteFadeOut == true) then 
						local onCompleteFadeOut = function()
							newEntity:clean()
							newEntity = nil
						end
						
						local count = 0
						for k,newObj in pairs(newEntity.tabObjects) do
							count = count+1
							
							if(newObj and count ==1) then 
								newObj.object.alpha = 1
								transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0,onComplete = onCompleteFadeOut})
							elseif(newObj) then 
								newObj.object.alpha = 1
								transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0})
							end
						end
						
					else
						for k,newObj in pairs(newEntity.tabObjects) do
							if(newObj) then 
								transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0})
							end
						end
						
					end
				end
				
				return newEntity
				
			else
				
				local newObj = gen.objectToDuplicate:clone(gen.insertCloneAtEndOfGroup)
				if(gen.objectAttached) then 
					if(gen.objectAttached.object.removeSelf) then 
						newObj.object.x = gen.objectAttached.object.x
						newObj.object.y = gen.objectAttached.object.y
					end
				end
				
				
				
				if(gen.emissionType == "LINE") then
					local xDest = math.random(newObj.object.x - newObj.object.contentWidth*2,
										newObj.object.x + newObj.object.contentWidth*2)
					newObj.object.x = xDest
					
				elseif(gen.emissionType == "DISC") then
					local xDest = math.random(newObj.object.x - newObj.object.contentWidth*2,
										newObj.object.x + newObj.object.contentWidth*2)
										
					local yDest = math.random(newObj.object.y - newObj.object.contentHeight*2,
					newObj.object.y + newObj.object.contentHeight*2)
					
					newObj.object.x = xDest
					newObj.object.y = yDest
				end
				
				table.insert(gen.tabObjects,newObj)

				if(gen.map) then 
					if(gen.objectToDuplicate.isHandledByTilesMap == true) then 
						gen.map:addExternalObjectToInteractWith(newObj)
					end
				end
				
				newObj:startInteractions()
				
				if(newObj.hasBody == true) then 
					newObj.object:applyLinearImpulse(gen.xImpulse,gen.yImpulse,newObj.object.x,newObj.object.y)
					newObj.object:applyAngularImpulse(gen.angularImpulse)
				end
				
				if(gen.fadeInEnabled == true and gen.fadeOutEnabled == false) then 
					newObj.object.alpha = 0
					transition.to(newObj.object,{time = gen.fadeInSpeed,alpha = 1})
				elseif(gen.fadeInEnabled == true and gen.fadeOutEnabled == true) then 
					newObj.object.alpha = 0
					local onCompleteFadeIn = function()
						local onTick = function()
							if(gen.removeOnCompleteFadeOut == true) then 
								local onCompleteFadeOut = function()
									newObj:clean()
									newObj = nil
								end
								transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0,onComplete = onCompleteFadeOut})
							else
								transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0})
							end
						end
						
						timer.performWithDelay(gen.delayBetweenFades,onTick,1)
					end
					transition.to(newObj.object,{time = gen.fadeInSpeed,alpha = 1,onComplete = onCompleteFadeIn})
				
				elseif(gen.fadeInEnabled == false and gen.fadeOutEnabled == true) then 
					newObj.object.alpha = 1
					if(gen.removeOnCompleteFadeOut == true) then 
						local onCompleteFadeOut = function()
							newObj:clean()
							newObj = nil
						end
						transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0,onComplete = onCompleteFadeOut})
					else
						transition.to(newObj.object,{time = gen.fadeOutSpeed,alpha = 0})
					end
				end
				
				return newObj
			end
		end

	end

	return gen
end

--- 
-- @description Clean the Generator Instance
-- @usage Usage:
-- <ul>
-- <li><code>generatorEngine:clean()</li>
-- <li>generatorEngine = nil</code></li>
-- </ul>
function Generator:clean()
	self:stopGeneration()
	self:cleanObjectsGenerated()
	self.name =nil
	self.objectToDuplicate =nil
	self.iteration = nil
	self.delay =nil
	self.copyPhysicBody =nil
	self.idTimerGeneration = nil
	self.map = nil

	self.generate = nil

end

function Generator:cleanObjectsGenerated()
	local tabObjects = self.tabObjects
	if(tabObjects) then 
		for i = 1,#tabObjects do 
			local obj = tabObjects[i]
			if(obj) then 
				obj:clean()
				obj = nil
			end
		end 	
	end
	tabObjects = nil
	self.tabObjects = {}
end
--- 
-- @description Start the generator
-- @usage Usage:
-- <ul>
-- <li><code>generatorEngine:startGeneration()</code></li>
-- </ul>
function Generator:startGeneration()
	if(self.idTimerGeneration) then self:stopGeneration() end
	if(self.iteration >=1) then 
		self.idTimerGeneration = timer.performWithDelay(self.delay,self.generate,self.iteration)
		self.isGenerating = true
	elseif(self.iteration == -1) then 
		self.idTimerGeneration = timer.performWithDelay(self.delay,self.generate,-1)
		self.isGenerating = true
	end
	
end

--- 
-- @description Stop the generator
-- @usage Usage:
-- <ul>
-- <li><code>generatorEngine:stopGeneration()</code></li>
-- </ul>
function Generator:stopGeneration()

	if(self.idTimerGeneration) then 
		timer.cancel(self.idTimerGeneration)
		self.idTimerGeneration = nil
		self.isGenerating = false
	end

end

--- 
-- @description Stop the interactions of each object created
-- @see object
-- @usage Usage:
-- <ul>
-- <li><code>generatorEngine:stopObjectsInteractions()</code></li>
-- </ul>
function Generator:stopObjectsInteractions()
	local tabObjects = self.tabObjects
	if(tabObjects) then 
		for i = 1,#tabObjects do 
			local obj = tabObjects[i]
			if(obj and obj.isEntity) then 
				for k,child in pairs(obj.tabObjects) do
					child:pauseInteractions()
				end
			elseif(obj) then 
				obj:pauseInteractions()
			end
		end 	
	end
end

--- 
-- @description Start the interactions of each object created
-- @see object
-- @usage Usage:
-- <ul>
-- <li><code>generatorEngine:startObjectsInteractions()</code></li>
-- </ul>
function Generator:startObjectsInteractions()
	local tabObjects = self.tabObjects
	if(tabObjects) then 
		for i = 1,#tabObjects do 
			local obj = tabObjects[i]
			if(obj and obj.isEntity) then 
				for k,child in pairs(obj.tabObjects) do
					child:startInteractions()
				end
			elseif(obj) then 
				obj:startInteractions()
			end
		end 	
	end
end




